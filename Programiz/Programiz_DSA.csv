,main_headings,main_contents,video_headings,video_urls,sub_headings_h2,sub_headings_h3,image_urls,facts,definitions,explanations,snippets,codes,outputs,table_data,list_items
0,['What is an Algorithm?'],"['In this tutorial, we will learn what algorithms are with the help of examples.']",[],[],"['Qualities of Good Algorithms', 'Algorithm Examples']","['Algorithm 1: Add two numbers entered by the user', 'Algorithm 2: Find the largest number among three numbers', 'Algorithm 3: Find Root of the quadratic equatin ax2 + bx + c = 0', 'Algorithm 4: Find the factorial of a number', 'Algorithm 5: Check whether a number is prime or not', 'Algorithm 6: Find the Fibonacci series till the term less than 1000']",[],"['An algorithm to add two numbers:', 'Take two number inputs', 'Add numbers using the + operator', 'Display the result', 'Algorithm to add two numbers', 'Algorithm to find the largest among three numbers', 'Algorithm to find all the roots of the quadratic equation', 'Algorithm to find the factorial', 'Algorithm to check prime number', 'Algorithm of Fibonacci series']",[],"['In computer programming terms, an algorithm is a set of well-defined instructions to solve a particular problem. It takes a set of input and produces a desired output. For example,']",[],[],"['Step 1: Start', 'Step 2: Declare variables num1, num2 and sum. ', 'Step 3: Read values num1 and num2. ', 'Step 4: Add num1 and num2 and assign the result to sum.', '        sum←num1+num2 ', 'Step 5: Display sum ', 'Step 6: Stop', 'Step 1: Start', 'Step 2: Declare variables a,b and c.', 'Step 3: Read variables a,b and c.', 'Step 4: If a > b', '           If a > c', '              Display a is the largest number.', '           Else', '              Display c is the largest number.', '        Else', '           If b > c', '              Display b is the largest number.', '           Else', '              Display c is the greatest number.  ', 'Step 5: Stop', 'Step 1: Start', 'Step 2: Declare variables a, b, c, D, x1, x2, rp and ip;', 'Step 3: Calculate discriminant', '         D ← b2-4ac', 'Step 4: If D ≥ 0', '              r1 ← (-b+√D)/2a', '              r2 ← (-b-√D)/2a ', '              Display r1 and r2 as roots.', '        Else     ', '              Calculate real part and imaginary part', '              rp ← -b/2a', '              ip ← √(-D)/2a', '              Display rp+j(ip) and rp-j(ip) as roots', 'Step 5: Stop             ', 'Step 1: Start', 'Step 2: Declare variables n, factorial and i.', 'Step 3: Initialize variables', '          factorial ← 1', '          i ← 1', 'Step 4: Read value of n', 'Step 5: Repeat the steps until i = n', '     5.1: factorial ← factorial*i', '     5.2: i ← i+1', 'Step 6: Display factorial', 'Step 7: Stop', 'Step 1: Start', 'Step 2: Declare variables n, i, flag.', 'Step 3: Initialize variables', '        flag ← 1', '        i ← 2  ', 'Step 4: Read n from the user.', 'Step 5: Repeat the steps until i=(n/2)', '     5.1 If remainder of n÷i equals 0', '            flag ← 0', '            Go to step 6', '     5.2 i ← i+1', 'Step 6: If flag = 0', '           Display n is not prime', '        else', '           Display n is prime', 'Step 7: Stop ', 'Step 1: Start ', 'Step 2: Declare variables first_term,second_term and temp. ', 'Step 3: Initialize variables first_term ← 0 second_term ← 1 ', 'Step 4: Display first_term and second_term ', 'Step 5: Repeat the steps until second_term ≤ 1000 ', '     5.1: temp ← second_term ', '     5.2: second_term ← second_term + first_term ', '     5.3: first_term ← temp ', '     5.4: Display second_term ', 'Step 6: Stop']",[],"[""Input and output should be defined precisely.|||Each step in the algorithm should be clear and unambiguous.|||Algorithms should be most effective among many different ways to solve a problem.|||An algorithm shouldn't include computer code. Instead, the algorithm should be written in such a way that it can be used in different programming languages.|||&&&|||Take two number inputs|||||||||Add numbers using the + operator|||||||||Display the result||||||""]"
1,['Data Structure and Types'],"['In this article, you will learn about data strucrture and its types.']",[],[],"['What are Data Structures?', 'Types of Data Structure', 'Linear data structures', 'Non linear data structures', 'Linear Vs Non-linear Data Structures']","['1. Array Data Structure', '2. Stack Data Structure', '3. Queue Data Structure', '4. Linked List Data Structure', '1. Graph Data Structure', '2. Trees Data Structure', 'Why Data Structure?']","['//cdn.programiz.com/cdn/farfuture/xl3N_KXHJEeqp83aLDgy9mO6yAKNM93I_rTfJXz8I0Q/mtime:1623152250/sites/tutorial2program/files/array_dsa.png', '//cdn.programiz.com/cdn/farfuture/CvSYKIrQaK-KlCU2PC0qZULI9kZa33XK3-HH1uipQIE/mtime:1623152231/sites/tutorial2program/files/array_.png', '//cdn.programiz.com/cdn/farfuture/kDcDcLDytJ7-aLU-7zVQAIiMLfh4TOvi-mZR10hOCFg/mtime:1623152242/sites/tutorial2program/files/stack_dsa.png', '//cdn.programiz.com/cdn/farfuture/Li6chlo-utkw-FHPvLC_IiManoc41y1yEpUzwkj8iY8/mtime:1623152237/sites/tutorial2program/files/queue_dsa.png', '//cdn.programiz.com/cdn/farfuture/m9VXEfUlR739aTq0OmxoCW3z5sgKYuMLajEmP-q3J88/mtime:1623152210/sites/tutorial2program/files/linked-list_dsa.png', '//cdn.programiz.com/cdn/farfuture/9QtvaweNfvWiBsAgt81aNynEhJXovky4lCoFgyU_Y-0/mtime:1623152219/sites/tutorial2program/files/graph_dsa.png', '//cdn.programiz.com/cdn/farfuture/oJBsOWQ4sBd6DYjtaDq4MtU2fIxMWfuD-eMU0ePauIE/mtime:1623152223/sites/tutorial2program/files/tree_dsa.png']","['Basically, data structures are divided into two categories:', ""Let's learn about each type in detail."", 'Popular linear data structures are:', 'To learn more, visit Java Array.', 'To learn more, visit Linked List Data Structure.\n\t\xa0', 'To learn more, visit Graph Data Structure.', 'Popular Graph Based Data Structures:', 'To learn more, visit Tree Data Structure.', 'Popular Tree based Data Structure', 'This helps you write memory and time efficient code.']","['Non-linear data structures are further divided into graph and tree based data structures.', 'In graph data structure, each node is called vertex and each vertex is connected to other vertices through edges.', ""Now that we know about linear and non-linear data structures, let's see the major differences between them."", 'To learn more about the importance of data structure, visit Why Learn Data Structure?']","['Data structure is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently.', 'Depending on your requirement and project, it is important to choose the right data structure for your project. For example, if you want to store data sequentially in the memory, then you can go for the Array data structure.', 'Note: Data structure and data types are slightly different. Data structure is the collection of data types arranged in a specific order.', 'In linear data structures, the elements are arranged in sequence one after the other. Since elements are arranged in particular order, they are easy to implement.', 'However, when the complexity of the program increases, the linear data structures might not be the best choice because of operational complexities.', 'In an array, elements in memory are arranged in continuous memory. All the elements of an array are of the same type. And, the type of elements that can be stored in the form of arrays is determined by the programming language.', 'In stack data structure, elements are stored in the LIFO principle. That is, the last element stored in a stack will be removed first.', 'It works just like a pile of plates where the last plate kept on the pile will be removed first. To learn more, visit Stack Data Structure.', 'Unlike stack, the queue data structure works in the FIFO principle where first element stored in the queue will be removed first.', 'It works just like a queue of people in the ticket counter where first person on the queue will get the ticket first. To learn more, visit Queue Data Structure.\n\t\xa0', 'In linked list data structure, data elements are connected through a series of nodes. And, each node contains the data items and address to the next node.', 'Unlike linear data structures, elements in non-linear data structures are not in any sequence. Instead they are arranged in a hierarchical manner where one element will be connected to one or more elements.', 'Similar to a graph, a tree is also a collection of vertices and edges. However, in tree data structure, there can only be one edge between two vertices.', 'Knowledge about data structures help you understand the working of each data structure. And, based on that you can select the right data structures for your project.']",[],[],[],"['inear Data Structures|||Non Linear Data Structures&&&he data items are arranged in sequential order, one after the other.|||The data items are arranged in non-sequential order (hierarchical manner).&&&ll the items are present on the single layer.|||The data items are present at different layers.&&&t can be traversed on a single run. That is, if we start from the first element, we can traverse all the elements sequentially in a single pass.|||It requires multiple runs. That is, if we start from the first element it might not be possible to traverse all the elements in a single pass.&&&he memory utilization is not efficient.|||Different structures utilize memory in different efficient ways depending on the need.&&&he time complexity increase with the data size.|||Time complexity remains the same.&&&xample: Arrays, Stack, Queue|||Example: Tree, Graph, Map']",['Linear data structure|||Non-linear data structure|||Spanning Tree and Minimum Spanning Tree|||Strongly Connected Components|||Adjacency Matrix|||Adjacency List|||Binary Tree|||Binary Search Tree|||AVL Tree|||B-Tree|||B+ Tree|||Red-Black Tree|||']
2,['Why Learn Data Structures and Algorithms?'],"['In this article, we will learn why every programmer should learn data structures and algorithms with the help of examples.']",[],[],"['What are Algorithms?', 'Use of Data Structures and Algorithms to Make Your Code Scalable', ""Examples of an Algorithm's Efficiency"", 'Final Words']","['More on Scalability', 'Memory is expensive', 'Example 1: Age Group Problem', ""Example 2: Rubik's Cube Problem"", 'Example 3: DNA Problem']",[],"['Problem: Find the factorial of n', 'Time is precious.', 'Algorithm (by Bob)', 'Code (by Alice)', 'The time taken by the computer to run code is:', 'Converting it into code will look something like this:', 'What if the number of students increased to 1000?', 'What is a scalable solution then?', 'The * operator replaced by + makes a lot of change.', 'And there are infinite such stories...']","['Informally, an algorithm is nothing but a mention of steps to solve a problem. They are essentially a solution.', 'For example, an algorithm to solve the problem of factorials might look something like this:', 'Two of the most valuable resources for a computer program are time and memory.', 'I am sure that you already guessed the right method. The sum of first N natural numbers is given by the formula:', 'Scalability is scale plus ability, which means the quality of an algorithm/system to handle the problem of larger size.', 'But what if the size of the problem increases? What if the number of students increased to 200?', 'Here are some examples of what learning algorithms and data structures enable you to do:', 'Suppose, it takes 1 second to find all the people at a certain age for a group of 1000. Then for a group of 1 million people,', 'The same binary search algorithm is used to find the square root of a number.', ""Imagine you are writing a program to find the solution of a Rubik's cube."", 'It is a famous problem in computer science academia. And, the simplest algorithm takes the time proportional to']","['This article is for those who have just started learning algorithms and wondered how impactful it will be to boost their career/programming skills. It is also for those who wonder why big companies like Google, Facebook, and Amazon hire programmers who are exceptionally good at optimizing Algorithms.', 'Here, the algorithm is written in English. If it was written in a programming language, we would call it to code instead. Here is a code for finding the factorial of a number in C++.', 'Programming is all about data structures and algorithms. Data structures are used to hold data while algorithms are used to solve the problem using that data.', 'Data structures and algorithms (DSA) goes through solutions to standard problems in detail and gives you an insight into how efficient it is to use each one of them. It also teaches you the science of evaluating the efficiency of an algorithm. This enables you to choose the best of various choices.', 'Suppose, Alice and Bob are trying to solve a simple problem of finding the sum of the first 1011 natural numbers. While Bob was writing the algorithm, Alice implemented it proving that it is as simple as criticizing Donald Trump.', ""Alice and Bob are feeling euphoric of themselves that they could build something of their own in almost no time. Let's sneak into their workspace and listen to their conversation."", ""Oops, something went wrong! A computer is the most deterministic machine. Going back and trying to run it again won't help. So let's analyze what's wrong with this simple code."", 'The number of instructions depends on the code you used, and the time taken to execute each code depends on your machine and compiler.', ""In this case, the total number of instructions executed (let's say x) are x = 1 + (1011 + 1) + (1011) + 1, which is x = 2 * 1011 + 3"", 'Let us assume that a computer can execute y = 108 instructions in one second (it can vary subject to machine configuration). The time taken to run above code is', 'Is it possible to optimize the algorithm so that Alice and Bob do not have to wait for 16 minutes every time they run this code?', 'This code executes in just one instruction and gets the task done no matter what the value is. Let it be greater than the total number of atoms in the universe. It will find the result in no time.', 'The time taken to solve the problem, in this case, is 1/y (which is 10 nanoseconds). By the way, the fusion reaction of a hydrogen bomb takes 40-50 ns, which means your program will complete successfully even if someone throws a hydrogen bomb on your computer at the same time you ran your code. :)', 'Note: Computers take a few instructions (not 1) to compute multiplication and division. I have said 1 just for the sake of simplicity.', 'Consider the problem of setting up a classroom of 50 students. One of the simplest solutions is to book a room, get a blackboard, a few chalks, and the problem is solved.', 'The solution still holds but it needs more resources. In this case, you will probably need a much larger room (probably a theater), a projector screen and a digital pen.', ""The solution fails or uses a lot of resources when the size of the problem increases. This means, your solution wasn't scalable."", 'Consider a site like Khanacademy, millions of students can see videos, read answers at the same time and no more resources are required. So, the solution can solve the problems of larger size under resource crunch.', ""If you see our first solution to find the sum of first N natural numbers, it wasn't scalable. It's because it required linear growth in time with the linear growth in the size of the problem. Such algorithms are also known as linearly scalable algorithms."", ""Our second solution was very scalable and didn't require the use of any more time to solve a problem of larger size. These are known as constant-time algorithms."", 'Memory is not always available in abundance. While dealing with code/system which requires you to store or produce a lot of data, it is critical for your algorithm to save the usage of memory wherever possible. For example: While storing data about people, you can save memory by storing only their date of birth, not their age. You can always calculate it on the fly using their date of birth and current date.', 'Problems like finding the people of a certain age group can easily be solved with a little modified version of the binary search algorithm (assuming that the data is sorted).', 'The naive algorithm which goes through all the persons one by one, and checks if it falls in the given age group is linearly scalable. Whereas, binary search claims itself to be a logarithmically scalable algorithm. This means that if the size of the problem is squared, the time taken to solve it is only doubled.', 'This cute looking puzzle has annoyingly 43,252,003,274,489,856,000 positions, and these are just positions! Imagine the number of paths one can take to reach the wrong positions.', ""Fortunately, the way to solve this problem can be represented by the graph data structure. There is a graph algorithm known as Dijkstra's algorithm which allows you to solve this problem in linear time. Yes, you heard it right. It means that it allows you to reach the solved position in a minimum number of states."", 'DNA is a molecule that carries genetic information. They are made up of smaller units which are represented by Roman characters A, C, T, and G.', 'Imagine yourself working in the field of bioinformatics. You are assigned the work of finding out the occurrence of a particular pattern in a DNA strand.', 'A typical DNA strand has millions of such units. Eh! worry not. KMP algorithm can get this done in time which is proportional to', 'Considering that the pattern was of 100 characters, your algorithm is now 100 times faster. If your pattern was of 1000 characters, the KMP algorithm would be almost 1000 times faster. That is, if you were able to find the occurrence of pattern in 1 second, it will now take you just 1 ms. We can also put this in another way. Instead of matching 1 strand, you can match 1000 strands of similar length at the same time.', 'Generally, software development involves learning new technologies on a daily basis. You get to learn most of these technologies while using them in one of your projects. However, it is not the case with algorithms.', ""If you don't know algorithms well, you won't be able to identify if you can optimize the code you are writing right now. You are expected to know them in advance and apply them wherever possible and critical."", 'We specifically talked about the scalability of algorithms. A software system consists of many such algorithms. Optimizing any one of them leads to a better system.', ""However, it's important to note that this is not the only way to make a system scalable. For example, a technique known as distributed computing allows independent parts of a program to run to multiple machines together making it even more scalable.""]","['int factorial(int n) {', '    int fact = 1;', '        fact = fact * v;', '    return fact;', 'int findSum() {', '    int sum = 0;', '        sum += v;', '    return sum;']","['    for (int v = 1; v <= n; v++) {', '    for (int v = 1; v <= 100000000000; v++) {']","['Initialize fact = 1', 'For every value v in range 1 to n:', '    Multiply the fact by v', 'fact contains the factorial of n', 'Initialize sum = 0', 'for every natural number n in range 1 to 1011 (inclusive):', '    add n to sum', 'sum is your answer', ""Alice: Let's run this code and find out the sum."", ""Bob: I ran this code a few minutes back but it's still not showing the output. What's wrong with it?"", 'Time to run code = number of instructions * time to execute each instruction', 'Time taken to run code = x/y (greater than 16 minutes)', 'Sum = N * (N + 1) / 2', 'int sum(int N) {', '    return N * (N + 1) / 2;', '}', '(number of character in DNA strand) * (number of characters in pattern)', '(number of character in DNA strand) + (number of characters in pattern)']",[],"['the binary search algorithm will take only 2 seconds to solve the problem|||the naive algorithm might take 1 million seconds, which is around 12 days|||']"
3,['Asymptotic Analysis: Big-O Notation and More'],"['In this tutorial, you will learn what asymptotic notations are. Also, you will learn about Big-O notation, Theta notation and Omega notation.']",[],[],"['Asymptotic Notations', 'Big-O Notation (O-notation)', 'Omega Notation (Ω-notation)', 'Theta Notation (Θ-notation)']",[],"['//cdn.programiz.com/sites/tutorial2program/files/big0.png', '//cdn.programiz.com/sites/tutorial2program/files/omega.png', '//cdn.programiz.com/sites/tutorial2program/files/theta.png']","['There are mainly three asymptotic notations:', 'For a function g(n), Θ(g(n)) is given by the relation:']","['For any value of n, the running time of an algorithm does not cross the time provided by O(g(n)).', 'For any value of n, the minimum time required by the algorithm is given by Omega Ω(g(n)).']","['The efficiency of an algorithm depends on the amount of time, storage and other resources required to execute the algorithm. The efficiency is measured with the help of asymptotic notations.', 'An algorithm may not have the same performance for different types of inputs. With the increase in the input size, the performance will change.', 'The study of change in performance of the algorithm with the change in the order of the input size is defined as asymptotic analysis.', 'Asymptotic notations are the mathematical notations used to describe the running time of an algorithm when the input tends towards a particular value or a limiting value.', 'For example: In bubble sort, when the input array is already sorted, the time taken by the algorithm is linear i.e. the best case.', 'But, when the input array is in reverse condition, the algorithm takes the maximum time (quadratic) to sort the elements i.e. the worst case.', 'When the input array is neither sorted nor in reverse order, then it takes average time. These durations are denoted using asymptotic notations.', 'Big-O notation represents the upper bound of the running time of an algorithm. Thus, it gives the worst-case complexity of an algorithm.', 'The above expression can be described as a function f(n) belongs to the set O(g(n)) if there exists a positive constant c such that it lies between 0 and cg(n), for sufficiently large n.', 'Since it gives the worst-case running time of an algorithm, it is widely used to analyze an algorithm as we are always interested in the worst-case scenario.', 'Omega notation represents the lower bound of the running time of an algorithm. Thus, it provides the best case complexity of an algorithm.', 'The above expression can be described as a function f(n) belongs to the set Ω(g(n)) if there exists a positive constant c such that it lies above cg(n), for sufficiently large n.', 'Theta notation encloses the function from above and below. Since it represents the upper and the lower bound of the running time of an algorithm, it is used for analyzing the average-case complexity of an algorithm.', 'The above expression can be described as a function f(n) belongs to the set Θ(g(n)) if there exist positive constants c1 and c2 such that it can be sandwiched between c1g(n) and c2g(n), for sufficiently large n.', 'If a function f(n) lies anywhere in between c1g(n) and c2g(n) for all n ≥ n0, then f(n) is said to be asymptotically tight bound.']",[],[],"['O(g(n)) = { f(n): there exist positive constants c and n0', '            such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }', 'Ω(g(n)) = { f(n): there exist positive constants c and n0 ', '            such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }', 'Θ(g(n)) = { f(n): there exist positive constants c1, c2 and n0', '            such that 0 ≤ c1g(n) ≤ f(n) ≤ c2g(n) for all n ≥ n0 }']",[],['Big-O notation|||Omega notation|||Theta notation|||']
4,['Master Theorem'],"['In this tutorial, you will learn what master theorem is and how it is used for solving recurrence relations.']",[],[],"['Master Theorem', 'Solved Example of Master Theorem', 'Master Theorem Limitations']",[],[],"['Each of the above conditions can be interpreted as:', 'The master theorem cannot be used if:']","['The master method is a formula for solving recurrence relations of the form:', 'An asymptotically positive function means that for a sufficiently large value of n, we have f(n) > 0.']","['The master theorem is used in calculating the time complexity of recurrence relations (divide and conquer algorithms) in a simple and quick way.', 'If a ≥ 1 and b > 1 are constants and f(n) is an asymptotically positive function, then the time complexity of a recursive relation is given by']",[],[],"['T(n) = aT(n/b) + f(n),', 'where,', 'n = size of input', 'a = number of subproblems in the recursion', 'n/b = size of each subproblem. All subproblems are assumed ', '     to have the same size.', 'f(n) = cost of the work done outside the recursive call, ', '      which includes the cost of dividing the problem and', '      cost of merging the solutions', 'Here, a ≥ 1 and b > 1 are constants, and f(n) is an asymptotically positive function.', 'T(n) = aT(n/b) + f(n)', 'where, T(n) has the following asymptotic bounds:', '    1. If f(n) = O(nlogb a-ϵ), then T(n) = Θ(nlogb a).', '    2. If f(n) = Θ(nlogb a), then T(n) = Θ(nlogb a * log n).', '    3. If f(n) = Ω(nlogb a+ϵ), then T(n) = Θ(f(n)).', 'ϵ > 0 is a constant.    ', 'T(n) = 3T(n/2) + n2', 'Here,', 'a = 3', 'n/b = n/2', 'f(n) = n2', 'logb a = log2 3 ≈ 1.58 < 2', 'ie. f(n) < nlogb a+ϵ , where, ϵ is a constant.', 'Case 3 implies here.', 'Thus, T(n) = f(n) = Θ(n2) ']",[],"['T(n) is not monotone. eg. T(n) = sin n|||f(n) is not a polynomial. eg. f(n) = 2n|||a is not a constant. eg. a = 2n|||a < 1|||&&&If the cost of solving the sub-problems at each level increases by a certain factor, the value of f(n) will become polynomially smaller than nlogb a. Thus, the time complexity is oppressed by the cost of the last level ie. nlogb a|||If the cost of solving the sub-problem at each level is nearly equal, then the value of f(n) will be nlogb a. Thus, the time complexity will be f(n) times the total number of levels ie. nlogb a * log n|||If the cost of solving the subproblems at each level decreases by a certain factor, the value of f(n) will become polynomially larger than nlogb a. Thus, the time complexity is oppressed by the cost of f(n).|||']"
5,['Divide and Conquer Algorithm'],"['In this tutorial, you will learn how the divide and conquer algorithm works. We will also compare the divide and conquer approach versus other approaches to solve a recursive problem.']",[],[],"['How Divide and Conquer Algorithms Work?', 'Time Complexity', 'Divide and Conquer Vs Dynamic approach', 'Advantages of Divide and Conquer Algorithm', 'Divide and Conquer Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/divide-and-conquer-0.png', '//cdn.programiz.com/sites/tutorial2program/files/divide-and-conquer-1.png', '//cdn.programiz.com/sites/tutorial2program/files/divide-and-conquer-2.png', '//cdn.programiz.com/sites/tutorial2program/files/divide-and-conquer-3.png']","['Here are the steps involved:', 'Let us understand this concept with the help of an example.', 'For a merge sort, the equation can be written as:', 'Divide and Conquer approach:', 'Dynamic approach:', 'In a dynamic approach, mem stores the result of each subproblem.']","['A divide and conquer algorithm is a strategy of solving a large problem by', 'To use the divide and conquer algorithm, recursion is used. Learn about recursion in different programming languages:', 'Here, we will sort an array using the divide and conquer approach (ie. merge sort).', 'The complexity of the divide and conquer algorithm is calculated using the master theorem.', 'Let us take an example to find the time complexity of a recursive problem.', 'Let us understand this with an example. Suppose we are trying to find the Fibonacci series. Then,']","['The divide and conquer approach divides a problem into smaller subproblems; these subproblems are further solved recursively. The result of each subproblem is not stored for future reference, whereas, in a dynamic approach, the result of each subproblem is stored for future reference.', 'Use the divide and conquer approach when the same subproblem is not solved multiple times. Use the dynamic approach when the result of a subproblem is to be used multiple times in the future.']",[],[],"['T(n) = aT(n/b) + f(n),', 'where,', 'n = size of input', 'a = number of subproblems in the recursion', 'n/b = size of each subproblem. All subproblems are assumed to have the same size.', 'f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions', 'T(n) = aT(n/b) + f(n)', '     = 2T(n/2) + O(n)', 'Where, ', 'a = 2 (each time, a problem is divided into 2 subproblems)', 'n/b = n/2 (size of each sub problem is half of the input)', 'f(n) = time taken to divide the problem and merging the subproblems', 'T(n/2) = O(n log n) (To understand this, please refer to the master theorem.)', 'Now, T(n) = 2T(n log n) + O(n)', '          ≈ O(n log n)', 'fib(n)', '    If n < 2, return 1', '    Else , return f(n - 1) + f(n -2)', 'mem = []', 'fib(n)', '    If n in mem: return mem[n] ', '    else,     ', '        If n < 2, f = 1', '        else , f = f(n - 1) + f(n -2)', '        mem[n] = f', '        return f']",[],"[""Recursion in Java|||Recursion in Python|||Recursion in C++|||The complexity for the multiplication of two matrices using the naive method is O(n3), whereas using the divide and conquer approach (i.e. Strassen's matrix multiplication) is O(n2.8074). This approach also simplifies other problems, such as the Tower of Hanoi.|||This approach is suitable for multiprocessing systems.|||It makes efficient use of memory caches.|||Binary Search|||Merge Sort|||Quick Sort|||Strassen's Matrix multiplication|||Karatsuba Algorithm|||&&&breaking the problem into smaller sub-problems|||solving the sub-problems, and|||combining them to get the desired output.|||Divide: Divide the given problem into sub-problems using recursion.|||Conquer: Solve the smaller sub-problems recursively. If the subproblem is small enough, then solve it directly.|||Combine: Combine the solutions of the sub-problems that are part of the recursive process to solve the actual problem.|||Let the given array be:|||Array for merge sort|||Divide the array into two halves.|||Divide the array into two subparts|||Again, divide each subpart recursively into two halves until you get individual elements.|||Divide the array into smaller subparts|||Now, combine the individual elements in a sorted manner. Here, conquer and combine steps go side by side.|||Combine the subparts|||""]"
6,['Stack Data Structure'],"['In this tutorial, you will learn about the stack data structure and its implementation in Python, Java and C/C++.']",[],[],"['LIFO Principle of Stack', 'Basic Operations of Stack', 'Working of Stack Data Structure', 'Stack Implementations in Python, Java, C, and C++', 'Stack Time Complexity', 'Applications of Stack Data Structure']",[],"['//cdn.programiz.com/sites/tutorial2program/files/stack-of-plates_0.png', '//cdn.programiz.com/sites/tutorial2program/files/stack.png', '//cdn.programiz.com/sites/tutorial2program/files/stack-operations.png']","['Here, you can:', 'The operations work as follows:']","['You can think of the stack data structure as the pile of plates on top of another.', 'In programming terms, putting an item on top of the stack is called push and removing an item is called pop.', 'There are some basic operations that allow us to perform different actions on a stack.', 'The most common stack implementation is using arrays, but it can also be implemented using lists.', 'For the array-based implementation of a stack, the push and pop operations take constant time, i.e. O(1).', 'Although stack is a simple data structure to implement, it is very powerful. The most common uses of a stack are:']","['A stack is a linear data structure that follows the principle of Last In First Out (LIFO). This means the last element inserted inside the stack is removed first.', 'And, if you want the plate at the bottom, you must first remove all the plates on top. This is exactly how the stack data structure works.', 'In the above image, although item 3 was kept last, it was removed first. This is exactly how the LIFO (Last In First Out) Principle works.', 'We can implement a stack in any programming language like C, C++, Java, Python or C#, but the specification is pretty much the same.']","['# Creating a stack', 'def create_stack():', '    stack = []', '    return stack', '# Creating an empty stack', 'def check_empty(stack):', '    return len(stack) == 0', '# Adding items into the stack', 'def push(stack, item):', '    stack.append(item)', 'def pop(stack):', '    if (check_empty(stack)):', '    return stack.pop()', 'stack = create_stack()', 'push(stack, str(1))', 'push(stack, str(2))', 'push(stack, str(3))', 'push(stack, str(4))', 'class Stack {', '  private int arr[];', '  private int top;', '  private int capacity;', '  Stack(int size) {', '    arr = new int[size];', '    capacity = size;', '    top = -1;', '  public void push(int x) {', '    if (isFull()) {', '      System.exit(1);', '    arr[++top] = x;', '  public int pop() {', '    if (isEmpty()) {', '      System.exit(1);', '    return arr[top--];', '  public int size() {', '    return top + 1;', '  public Boolean isEmpty() {', '    return top == -1;', '  public Boolean isFull() {', '  public void printStack() {', '    stack.push(1);', '    stack.push(2);', '    stack.push(3);', '    stack.push(4);', '    stack.pop();', '    stack.printStack();', '#include <stdio.h>', '#include <stdlib.h>', '#define MAX 10', 'int count = 0;', 'struct stack {', '  int items[MAX];', '  int top;', 'typedef struct stack st;', 'void createEmptyStack(st *s) {', '  s->top = -1;', 'int isfull(st *s) {', '  if (s->top == MAX - 1)', '    return 1;', '    return 0;', 'int isempty(st *s) {', '  if (s->top == -1)', '    return 1;', '    return 0;', '  if (isfull(s)) {', '    printf(""STACK FULL"");', '  } else {', '    s->top++;', '  count++;', 'void pop(st *s) {', '  if (isempty(s)) {', '  } else {', '    s->top--;', '  count--;', '  printf(""\\n"");', 'void printStack(st *s) {', '  printf(""Stack: "");', '  printf(""\\n"");', 'int main() {', '  int ch;', '  createEmptyStack(s);', '  push(s, 1);', '  push(s, 2);', '  push(s, 3);', '  push(s, 4);', '  printStack(s);', '  pop(s);', '  printStack(s);', '#include <stdlib.h>', '#include <iostream>', 'using namespace std;', '#define MAX 10', 'int size = 0;', 'struct stack {', '  int items[MAX];', '  int top;', 'typedef struct stack st;', 'void createEmptyStack(st *s) {', '  s->top = -1;', 'int isfull(st *s) {', '  if (s->top == MAX - 1)', '    return 1;', '    return 0;', 'int isempty(st *s) {', '  if (s->top == -1)', '    return 1;', '    return 0;', '  if (isfull(s)) {', '    cout << ""STACK FULL"";', '  } else {', '    s->top++;', '  size++;', 'void pop(st *s) {', '  if (isempty(s)) {', '  } else {', '    s->top--;', '  size--;', '  cout << endl;', 'void printStack(st *s) {', '  printf(""Stack: "");', '  cout << endl;', 'int main() {', '  int ch;', '  createEmptyStack(s);', '  push(s, 1);', '  push(s, 2);', '  push(s, 3);', '  push(s, 4);', '  printStack(s);', '  pop(s);', '  printStack(s);']","['# Stack implementation in python', '    print(""pushed item: "" + item)', '# Removing an element from the stack', 'print(""popped item: "" + pop(stack))', 'print(""stack after popping an element: "" + str(stack))', '      System.out.println(""OverFlow\\nProgram Terminated\\n"");', '    System.out.println(""Inserting "" + x);', '      System.out.println(""STACK EMPTY"");', '    for (int i = 0; i <= top; i++) {', '      System.out.println(arr[i]);', '  public static void main(String[] args) {', '    System.out.println(""\\nAfter popping out"");', '    printf(""\\n STACK EMPTY \\n"");', '    printf(""Item popped= %d"", s->items[s->top]);', '  for (int i = 0; i < count; i++) {', '  st *s = (st *)malloc(sizeof(st));', '  printf(""\\nAfter popping out\\n"");', '    cout << ""\\n STACK EMPTY \\n"";', '    cout << ""Item popped= "" << s->items[s->top];', '  for (int i = 0; i < size; i++) {', '  st *s = (st *)malloc(sizeof(st));', '  cout << ""\\nAfter popping out\\n"";']",[],[],"['Put a new plate on top|||Remove the top plate|||Push: Add an element to the top of a stack|||Pop: Remove an element from the top of a stack|||IsEmpty: Check if the stack is empty|||IsFull: Check if the stack is full|||Peek: Get the value of the top element without removing it|||To reverse a word - Put all the letters in a stack and pop them out. Because of the LIFO order of stack, you will get the letters in reverse order.|||In compilers - Compilers use the stack to calculate the value of expressions like 2 + 4 / 5 * (7 - 9) by converting the expression to prefix or postfix form.|||In browsers - The back button in a browser saves all the URLs you have visited previously in a stack. Each time you visit a new page, it is added on top of the stack. When you press the back button, the current URL is removed from the stack, and the previous URL is accessed.|||&&&A pointer called TOP is used to keep track of the top element in the stack.|||When initializing the stack, we set its value to -1 so that we can check if the stack is empty by comparing TOP == -1.|||On pushing an element, we increase the value of TOP and place the new element in the position pointed to by TOP.|||On popping an element, we return the element pointed to by TOP and reduce its value.|||Before pushing, we check if the stack is already full|||Before popping, we check if the stack is already empty|||']"
7,['Queue Data Structure'],"['In this tutorial, you will learn what a queue is. Also, you will find implementation of queue in C, C++, Java and Python.']",[],[],"['Basic Operations of Queue', 'Working of Queue', 'Queue Implementations in Python, Java, C, and C++', 'Limitations of Queue', 'Complexity Analysis', 'Applications of Queue']","['Enqueue Operation', 'Dequeue Operation', 'Recommended Readings']","['//cdn.programiz.com/sites/tutorial2program/files/queue.png', '//cdn.programiz.com/sites/tutorial2program/files/Queue-program-enqueue-dequeue.png', '//cdn.programiz.com/sites/tutorial2program/files/why-circular-queue_0.png']",['Queue operations work as follows:'],"['Queue follows the First In First Out (FIFO) rule - the item that goes in first is the item that comes out first.', 'In programming terms, putting items in the queue is called enqueue, and removing items from the queue is called dequeue.', 'A queue is an object (an abstract data structure - ADT) that allows the following operations:', 'We usually use arrays to implement queues in Java and C/++. In the case of Python, we use lists.', 'As you can see in the image below, after a bit of enqueuing and dequeuing, the size of the queue has been reduced.', 'And we can only add indexes 0 and 1 only when the queue is reset (when all the elements have been dequeued).']","['A queue is a useful data structure in programming. It is similar to the ticket queue outside a cinema hall, where the first person entering the queue is the first person who gets the ticket.', 'In the above image, since 1 was kept in the queue before 2, it is the first to be removed from the queue as well. It follows the FIFO rule.', 'We can implement the queue in any programming language like C, C++, Java, Python or C#, but the specification is pretty much the same.', 'After REAR reaches the last index, if we can store extra elements in the empty spaces (0 and 1), we can make use of the empty spaces. This is implemented by a modified queue called the circular queue.', 'The complexity of enqueue and dequeue operations in a queue using an array is O(1). If you use pop(N) in python code, then the complexity might be O(n) depending on the position of the item to be popped.']","['class Queue:', '    def __init__(self):', '        self.queue = []', '    # Add an element', '    def enqueue(self, item):', '    # Remove an element', '    def dequeue(self):', '            return None', '    # Display  the queue', '    def display(self):', '        print(self.queue)', '    def size(self):', '        return len(self.queue)', 'q = Queue()', 'q.enqueue(1)', 'q.enqueue(2)', 'q.enqueue(3)', 'q.enqueue(4)', 'q.enqueue(5)', 'q.display()', 'q.dequeue()', 'q.display()', 'public class Queue {', '  int SIZE = 5;', '  int items[] = new int[SIZE];', '  int front, rear;', '  Queue() {', '    front = -1;', '    rear = -1;', '  boolean isFull() {', '      return true;', '    return false;', '  boolean isEmpty() {', '    if (front == -1)', '      return true;', '    else', '      return false;', '  void enQueue(int element) {', '    if (isFull()) {', '    } else {', '      if (front == -1)', '        front = 0;', '      rear++;', '      items[rear] = element;', '  int deQueue() {', '    int element;', '    if (isEmpty()) {', '      return (-1);', '    } else {', '      element = items[front];', '      if (front >= rear) {', '        front = -1;', '        rear = -1;', '      else {', '        front++;', '      return (element);', '  void display() {', '    int i;', '    if (isEmpty()) {', '    } else {', '    Queue q = new Queue();', '    q.deQueue();', '    q.enQueue(1);', '    q.enQueue(2);', '    q.enQueue(3);', '    q.enQueue(4);', '    q.enQueue(5);', '    q.enQueue(6);', '    q.display();', '    q.deQueue();', '    q.display();', '#include <stdio.h>', '#define SIZE 5', 'void enQueue(int);', 'void deQueue();', 'void display();', 'int main() {', '  deQueue();', '  enQueue(1);', '  enQueue(2);', '  enQueue(3);', '  enQueue(4);', '  enQueue(5);', '  enQueue(6);', '  display();', '  deQueue();', '  display();', '  return 0;', 'void enQueue(int value) {', '  if (rear == SIZE - 1)', '  else {', '    if (front == -1)', '      front = 0;', '    rear++;', '    items[rear] = value;', 'void deQueue() {', '  if (front == -1)', '  else {', '    front++;', '    if (front > rear)', '      front = rear = -1;', 'void display() {', '  if (rear == -1)', '  else {', '    int i;', '  printf(""\\n"");', '#include <iostream>', '#define SIZE 5', 'using namespace std;', 'class Queue {', '   private:', '   public:', '  Queue() {', '    front = -1;', '    rear = -1;', '  bool isFull() {', '      return true;', '    return false;', '  bool isEmpty() {', '    if (front == -1)', '      return true;', '    else', '      return false;', '  void enQueue(int element) {', '    if (isFull()) {', '      cout << ""Queue is full"";', '    } else {', '      rear++;', '      items[rear] = element;', '      cout << endl', '  int deQueue() {', '    int element;', '    if (isEmpty()) {', '      return (-1);', '    } else {', '      element = items[front];', '      if (front >= rear) {', '        front = -1;', '        rear = -1;', '      else {', '        front++;', '      cout << endl', '      return (element);', '  void display() {', '    int i;', '    if (isEmpty()) {', '      cout << endl', '    } else {', '      cout << endl', '      cout << endl', '         << ""Items -> "";', '      cout << endl', 'int main() {', '  Queue q;', '  q.deQueue();', '  q.enQueue(1);', '  q.enQueue(2);', '  q.enQueue(3);', '  q.enQueue(4);', '  q.enQueue(5);', '  q.enQueue(6);', '  q.display();', '  q.deQueue();', '  q.display();', '  return 0;']","['# Queue implementation in Python', '        return self.queue.pop(0)', 'print(""After removing an element"")', '    if (front == 0 && rear == SIZE - 1) {', '      System.out.println(""Queue is full"");', '      System.out.println(""Inserted "" + element);', '      System.out.println(""Queue is empty"");', '      } /* Q has only one element, so we reset the queue after deleting it. */', '      System.out.println(""Deleted -> "" + element);', '    /* Function to display elements of Queue */', '      System.out.println(""Empty Queue"");', '      System.out.println(""\\nFront index-> "" + front);', '      System.out.println(""Items -> "");', '      for (i = front; i <= rear; i++)', '        System.out.print(items[i] + ""  "");', '      System.out.println(""\\nRear index-> "" + rear);', '  public static void main(String[] args) {', 'int items[SIZE], front = -1, rear = -1;', '    printf(""\\nQueue is Full!!"");', '    printf(""\\nInserted -> %d"", value);', '    printf(""\\nQueue is Empty!!"");', '    printf(""\\nDeleted : %d"", items[front]);', '    printf(""\\nQueue is Empty!!!"");', '    printf(""\\nQueue elements are:\\n"");', '    for (i = front; i <= rear; i++)', '    if (front == 0 && rear == SIZE - 1) {', '      if (front == -1) front = 0;', '         << ""Inserted "" << element << endl;', '      cout << ""Queue is empty"" << endl;', '      } /* Q has only one element, so we reset the queue after deleting it. */', '         << ""Deleted -> "" << element << endl;', '    /* Function to display elements of Queue */', '         << ""Empty Queue"" << endl;', '         << ""Front index-> "" << front;', '      for (i = front; i <= rear; i++)', '        cout << items[i] << ""  "";', '         << ""Rear index-> "" << rear << endl;']",[],[],"['Enqueue: Add an element to the end of the queue|||Dequeue: Remove an element from the front of the queue|||IsEmpty: Check if the queue is empty|||IsFull: Check if the queue is full|||Peek: Get the value of the front of the queue without removing it|||two pointers FRONT and REAR|||FRONT track the first element of the queue|||REAR track the last element of the queue|||initially, set value of FRONT and REAR to -1|||check if the queue is full|||for the first element, set the value of FRONT to 0|||increase the REAR index by 1|||add the new element in the position pointed to by REAR|||check if the queue is empty|||return the value pointed by FRONT|||increase the FRONT index by 1|||for the last element, reset the values of FRONT and REAR to -1|||CPU scheduling, Disk Scheduling|||When data is transferred asynchronously between two processes.The queue is used for synchronization. For example: IO Buffers, pipes, file IO, etc|||Handling of interrupts in real-time systems.|||Call Center phone systems use Queues to hold people calling them in order.|||Types of Queue|||Circular Queue|||Deque Data Structure|||Priority Queue|||']"
8,['Types of Queues'],"['In this tutorial, you will learn different types of queues with along with illustration.']",[],[],"['Simple Queue', 'Circular Queue', 'Priority Queue', 'Deque (Double Ended Queue)']",[],"['//cdn.programiz.com/sites/tutorial2program/files/simple-queue_0.png', '//cdn.programiz.com/sites/tutorial2program/files/circular-queue.png', '//cdn.programiz.com/sites/tutorial2program/files/priority-queue.png', '//cdn.programiz.com/sites/tutorial2program/files/double-ended-queue.png']","['There are four different types of queues:', 'To learn more, visit Queue Data Structure.', 'To learn more, visit Circular Queue Data Structure.', 'To learn more, visit Priority Queue Data Structure.', 'To learn more, visit Deque Data Structure.']","['In a circular queue, the last element points to the first element making a circular link.', 'Insertion occurs based on the arrival of the values and removal occurs based on priority.']","['A queue is a useful data structure in programming. It is similar to the ticket queue outside a cinema hall, where the first person entering the queue is the first person who gets the ticket.', 'In a simple queue, insertion takes place at the rear and removal occurs at the front. It strictly follows the FIFO (First in First out) rule.', 'The main advantage of a circular queue over a simple queue is better memory utilization. If the last position is full and the first position is empty, we can insert an element in the first position. This action is not possible in a simple queue.', 'A priority queue is a special type of queue in which each element is associated with a priority and is served according to its priority. If elements with the same priority occur, they are served according to their order in the queue.', 'In a double ended queue, insertion and removal of elements can be performed from either from the front or rear. Thus, it does not follow the FIFO (First In First Out) rule.']",[],[],[],[],['Simple Queue|||Circular Queue|||Priority Queue|||Double Ended Queue|||']
9,['Circular Queue Data Structure'],"['In this tutorial, you will learn what a circular queue is. Also, you will find implementation of circular queue in C, C++, Java and Python.']",[],[],"['How Circular Queue Works', 'Circular Queue Operations', 'Circular Queue Implementations in Python, Java, C, and C++', 'Circular Queue Complexity Analysis', 'Applications of Circular Queue']","['1. Enqueue Operation', '2. Dequeue Operation']","['//cdn.programiz.com/sites/tutorial2program/files/circular-increment.png', '//cdn.programiz.com/sites/tutorial2program/files/why-circular-queue.png', '//cdn.programiz.com/sites/tutorial2program/files/circular-queue-program.png']","['The circular queue work as follows:', 'However, the check for full queue has a new additional case:']","['Here, the circular increment is performed by modulo division with the queue size. That is,', 'The most common queue implementation is using arrays, but it can also be implemented using lists.', 'The complexity of the enqueue and dequeue operations of a circular queue is O(1) for (array implementations).']","['A circular queue is the extended version of a regular queue where the last element is connected to the first element. Thus forming a circle-like structure.', 'The circular queue solves the major limitation of the normal queue. In a normal queue, after a bit of insertion and deletion, there will be non-usable empty space.', 'Here, indexes 0 and 1 can only be used after resetting the queue (deletion of all elements). This reduces the actual size of the queue.', 'Circular Queue works by the process of circular increment i.e. when we try to increment the pointer and we reach the end of the queue, we start from the beginning of the queue.', 'The second case happens when REAR starts from 0 due to circular increment and when its value is just 1 less than FRONT, the queue is full.']","['class MyCircularQueue():', '    def __init__(self, k):', '        self.k = k', '    def enqueue(self, data):', '            self.head = 0', '            self.tail = 0', '        else:', '    def dequeue(self):', '        if (self.head == -1):', '            self.head = -1', '            self.tail = -1', '            return temp', '        else:', '            return temp', '    def printCQueue(self):', '        if(self.head == -1):', '            print()', '        else:', '            print()', 'obj = MyCircularQueue(5)', 'obj.enqueue(1)', 'obj.enqueue(2)', 'obj.enqueue(3)', 'obj.enqueue(4)', 'obj.enqueue(5)', 'print(""Initial queue"")', 'obj.printCQueue()', 'obj.dequeue()', 'obj.printCQueue()', 'public class CQueue {', '  int front, rear;', '  int items[] = new int[SIZE];', '  CQueue() {', '    front = -1;', '    rear = -1;', '  boolean isFull() {', '      return true;', '    if (front == rear + 1) {', '      return true;', '    return false;', '  boolean isEmpty() {', '    if (front == -1)', '      return true;', '    else', '      return false;', '  void enQueue(int element) {', '    if (isFull()) {', '    } else {', '      if (front == -1)', '        front = 0;', '      items[rear] = element;', '  int deQueue() {', '    int element;', '    if (isEmpty()) {', '      return (-1);', '    } else {', '      element = items[front];', '      if (front == rear) {', '        front = -1;', '        rear = -1;', '      else {', '      return (element);', '  void display() {', '    int i;', '    if (isEmpty()) {', '    } else {', '    CQueue q = new CQueue();', '    q.deQueue();', '    q.enQueue(1);', '    q.enQueue(2);', '    q.enQueue(3);', '    q.enQueue(4);', '    q.enQueue(5);', '    q.enQueue(6);', '    q.display();', '    int elem = q.deQueue();', '    if (elem != -1) {', '    q.display();', '    q.enQueue(7);', '    q.display();', '    q.enQueue(8);', '#include <stdio.h>', '#define SIZE 5', 'int items[SIZE];', 'int front = -1, rear = -1;', 'int isFull() {', '  return 0;', 'int isEmpty() {', '  if (front == -1) return 1;', '  return 0;', 'void enQueue(int element) {', '  if (isFull())', '  else {', '    rear = (rear + 1) % SIZE;', '    items[rear] = element;', 'int deQueue() {', '  int element;', '  if (isEmpty()) {', '    return (-1);', '  } else {', '    element = items[front];', '    if (front == rear) {', '      front = -1;', '      rear = -1;', '    else {', '    return (element);', 'void display() {', '  int i;', '  if (isEmpty())', '  else {', '    printf(""\\n Items -> "");', '      printf(""%d "", items[i]);', '    printf(""%d "", items[i]);', 'int main() {', '  deQueue();', '  enQueue(1);', '  enQueue(2);', '  enQueue(3);', '  enQueue(4);', '  enQueue(5);', '  enQueue(6);', '  display();', '  deQueue();', '  display();', '  enQueue(7);', '  display();', '  enQueue(8);', '  return 0;', '#include <iostream>', 'using namespace std;', 'class Queue {', '   private:', '   public:', '  Queue() {', '    front = -1;', '    rear = -1;', '  bool isFull() {', '      return true;', '    if (front == rear + 1) {', '      return true;', '    return false;', '  bool isEmpty() {', '    if (front == -1)', '      return true;', '    else', '      return false;', '  void enQueue(int element) {', '    if (isFull()) {', '      cout << ""Queue is full"";', '    } else {', '      items[rear] = element;', '      cout << endl', '  int deQueue() {', '    int element;', '    if (isEmpty()) {', '      return (-1);', '    } else {', '      element = items[front];', '      if (front == rear) {', '        front = -1;', '        rear = -1;', '      else {', '      return (element);', '  void display() {', '    int i;', '    if (isEmpty()) {', '      cout << endl', '    } else {', '      cout << endl', '         << ""Items -> "";', '        cout << items[i];', '      cout << items[i];', '      cout << endl', 'int main() {', '  Queue q;', '  q.deQueue();', '  q.enQueue(1);', '  q.enQueue(2);', '  q.enQueue(3);', '  q.enQueue(4);', '  q.enQueue(5);', '  q.enQueue(6);', '  q.display();', '  int elem = q.deQueue();', '  if (elem != -1)', '    cout << endl', '  q.display();', '  q.enQueue(7);', '  q.display();', '  q.enQueue(8);', '  return 0;']","['if REAR + 1 == 5 (overflow!), REAR = (REAR + 1)%5 = 0 (start of queue)', '# Circular Queue implementation in Python', '        self.head = self.tail = -1', '    # Insert an element into the circular queue', '        if ((self.tail + 1) % self.k == self.head):', '            print(""The circular queue is full\\n"")', '            self.queue[self.tail] = data', '            self.tail = (self.tail + 1) % self.k', '            self.queue[self.tail] = data', '    # Delete an element from the circular queue', '            print(""The circular queue is empty\\n"")', '        elif (self.head == self.tail):', '            temp = self.queue[self.head]', '            temp = self.queue[self.head]', '            self.head = (self.head + 1) % self.k', '            print(""No element in the circular queue"")', '        elif (self.tail >= self.head):', '            for i in range(self.head, self.tail + 1):', '                print(self.queue[i], end="" "")', '            for i in range(self.head, self.k):', '                print(self.queue[i], end="" "")', '            for i in range(0, self.tail + 1):', '                print(self.queue[i], end="" "")', '# Your MyCircularQueue object will be instantiated and called as such:', 'print(""After removing an element from the queue"")', '  int SIZE = 5; // Size of Circular Queue', '    if (front == 0 && rear == SIZE - 1) {', '      System.out.println(""Queue is full"");', '      System.out.println(""Inserted "" + element);', '      System.out.println(""Queue is empty"");', '      } /* Q has only one element, so we reset the queue after deleting it. */', '        front = (front + 1) % SIZE;', '    /* Function to display status of Circular Queue */', '      System.out.println(""Empty Queue"");', '      System.out.println(""Front -> "" + front);', '      System.out.println(""Items -> "");', '      for (i = front; i != rear; i = (i + 1) % SIZE)', '        System.out.print(items[i] + "" "");', '      System.out.println(items[i]);', '      System.out.println(""Rear -> "" + rear);', '  public static void main(String[] args) {', '      System.out.println(""Deleted Element is "" + elem);', '  if ((front == rear + 1) || (front == 0 && rear == SIZE - 1)) return 1;', '    printf(""\\n Queue is full!! \\n"");', '    printf(""\\n Inserted -> %d"", element);', '    printf(""\\n Queue is empty !! \\n"");', '      front = (front + 1) % SIZE;', '    printf(""\\n Deleted element -> %d \\n"", element);', '    printf("" \\n Empty Queue\\n"");', '    printf(""\\n Front -> %d "", front);', '    for (i = front; i != rear; i = (i + 1) % SIZE) {', '    printf(""\\n Rear -> %d \\n"", rear);', '#define SIZE 5 /* Size of Circular Queue */', '    if (front == 0 && rear == SIZE - 1) {', '      if (front == -1) front = 0;', '         << ""Inserted "" << element << endl;', '      cout << ""Queue is empty"" << endl;', '        front = (front + 1) % SIZE;', '         << ""Empty Queue"" << endl;', '      cout << ""Front -> "" << front;', '      for (i = front; i != rear; i = (i + 1) % SIZE)', '       << ""Deleted Element is "" << elem;']",[],[],"['two pointers FRONT and REAR|||FRONT track the first element of the queue|||REAR track the last elements of the queue|||initially, set value of FRONT and REAR to -1|||check if the queue is full|||for the first element, set value of FRONT to 0|||circularly increase the REAR index by 1 (i.e. if the rear reaches the end, next it would be at the start of the queue)|||add the new element in the position pointed to by REAR|||check if the queue is empty|||return the value pointed by FRONT|||circularly increase the FRONT index by 1|||for the last element, reset the values of FRONT and REAR to -1|||Case 1: FRONT = 0 && REAR == SIZE - 1|||Case 2: FRONT = REAR + 1|||CPU scheduling|||Memory management|||Traffic Management|||']"
10,['Priority Queue'],"[""In this tutorial, you will learn what priority queue is. Also, you will learn about it's implementations in Python, Java, C, and C++.""]",[],[],"['Implementation of Priority Queue', 'Priority Queue Operations', 'Priority Queue Implementations in Python, Java, C, and C++', 'Priority Queue Applications']","['Difference between Priority Queue and Normal Queue', '1. Inserting an Element into the Priority Queue', '2. Deleting an Element from the Priority Queue', '3. Peeking from the Priority Queue (Find max/min)', '4. Extract-Max/Min from the Priority Queue']","['//cdn.programiz.com/sites/tutorial2program/files/Introduction.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-3.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-4.png']","['Assigning Priority Value', 'We can also set priorities according to our needs.', 'For both Max heap and Min Heap', 'Some of the applications of a priority queue are:']","['However, if elements with the same priority occur, they are served according to their order in the queue.', 'Generally, the value of the element itself is considered for assigning the priority. For example,', 'A comparative analysis of different implementations of priority queue is given below.', 'Basic operations of a priority queue are inserting, removing, and peeking elements.', 'Inserting an element into a priority queue (max-heap) is done by the following steps.', 'Algorithm for insertion of an element into priority queue (max-heap)', 'For Min Heap, the above algorithm is modified so that parentNode is always smaller than newNode.', 'Deleting an element from a priority queue (max-heap) is done as follows:', 'Algorithm for deletion of an element in the priority queue (max-heap)', 'For Min Heap, the above algorithm is modified so that the both childNodes are smaller than currentNode.', 'Peek operation returns the maximum element from Max Heap or minimum element from Min Heap without deleting the node.']","['A priority queue is a special type of queue in which each element is associated with a priority value. And, elements are served on the basis of their priority. That is, higher priority elements are served first.', 'The element with the highest value is considered the highest priority element. However, in other cases, we can assume the element with the lowest value as the highest priority element.', 'In a queue, the first-in-first-out rule is implemented whereas, in a priority queue, the values are removed on the basis of priority. The element with the highest priority is removed first.', 'Priority queue can be implemented using an array, a linked list, a heap data structure, or a binary search tree. Among these data structures, heap data structure provides an efficient implementation of priority queues.', 'Hence, we will be using the heap data structure to implement the priority queue in this tutorial. A max-heap is implement is in the following operations. If you want to learn more about it, please visit max-heap and mean-heap.', 'Before studying the priority queue, please refer to the heap data structure for a better understanding of binary heap as it is used to implement the priority queue in this article.', 'Extract-Max returns the node with maximum value after removing it from a Max Heap whereas Extract-Min returns the node with minimum value after removing it from Min Heap.']","['# Function to heapify the tree', 'def heapify(arr, n, i):', '    largest = i', '    l = 2 * i + 1', '    r = 2 * i + 2', '        largest = l', '        largest = r', '    if largest != i:', 'def insert(array, newNum):', '    size = len(array)', '    if size == 0:', '        array.append(newNum)', '    else:', '        array.append(newNum)', 'def deleteNode(array, num):', '    size = len(array)', '    i = 0', '    for i in range(0, size):', '        if num == array[i]:', '            break', '    array.remove(size - 1)', 'arr = []', 'insert(arr, 3)', 'insert(arr, 4)', 'insert(arr, 9)', 'insert(arr, 5)', 'insert(arr, 2)', 'deleteNode(arr, 4)', 'import java.util.ArrayList;', 'class Heap {', '    int size = hT.size();', '    int largest = i;', '    int l = 2 * i + 1;', '    int r = 2 * i + 2;', '      largest = l;', '      largest = r;', '    if (largest != i) {', '      hT.set(i, temp);', '      heapify(hT, largest);', '    int size = hT.size();', '    if (size == 0) {', '      hT.add(newNum);', '    } else {', '      hT.add(newNum);', '        heapify(hT, i);', '    int size = hT.size();', '    int i;', '      if (num == hT.get(i))', '        break;', '    int temp = hT.get(i);', '    hT.set(size - 1, temp);', '    hT.remove(size - 1);', '      heapify(hT, j);', '    for (Integer i : array) {', '    System.out.println();', '    int size = array.size();', '    Heap h = new Heap();', '    h.insert(array, 3);', '    h.insert(array, 4);', '    h.insert(array, 9);', '    h.insert(array, 5);', '    h.insert(array, 2);', '    h.printArray(array, size);', '    h.deleteNode(array, 4);', '    h.printArray(array, size);', '#include <stdio.h>', 'int size = 0;', 'void swap(int *a, int *b) {', '  int temp = *b;', '  *b = *a;', '  *a = temp;', '  if (size == 1) {', '  } else {', '    int largest = i;', '    int l = 2 * i + 1;', '    int r = 2 * i + 2;', '      largest = l;', '      largest = r;', '    if (largest != i) {', '  if (size == 0) {', '    array[0] = newNum;', '    size += 1;', '  } else {', '    array[size] = newNum;', '    size += 1;', '      heapify(array, size, i);', '  int i;', '  for (i = 0; i < size; i++) {', '    if (num == array[i])', '      break;', '  size -= 1;', '    heapify(array, size, i);', '    printf(""%d "", array[i]);', '  printf(""\\n"");', 'int main() {', '  int array[10];', '  insert(array, 3);', '  insert(array, 4);', '  insert(array, 9);', '  insert(array, 5);', '  insert(array, 2);', '  printf(""Max-Heap array: "");', '  printArray(array, size);', '  deleteRoot(array, 4);', '  printArray(array, size);', '#include <iostream>', '#include <vector>', 'using namespace std;', 'void swap(int *a, int *b) {', '  int temp = *b;', '  *b = *a;', '  *a = temp;', '  int size = hT.size();', '  int largest = i;', '  int l = 2 * i + 1;', '  int r = 2 * i + 2;', '    largest = l;', '    largest = r;', '  if (largest != i) {', '    heapify(hT, largest);', '  int size = hT.size();', '  if (size == 0) {', '    hT.push_back(newNum);', '  } else {', '    hT.push_back(newNum);', '      heapify(hT, i);', '  int size = hT.size();', '  int i;', '  for (i = 0; i < size; i++) {', '    if (num == hT[i])', '      break;', '  swap(&hT[i], &hT[size - 1]);', '  hT.pop_back();', '    heapify(hT, i);', '    cout << hT[i] << "" "";', '  cout << ""\\n"";', 'int main() {', '  vector<int> heapTree;', '  insert(heapTree, 3);', '  insert(heapTree, 4);', '  insert(heapTree, 9);', '  insert(heapTree, 5);', '  insert(heapTree, 2);', '  cout << ""Max-Heap array: "";', '  printArray(heapTree);', '  deleteNode(heapTree, 4);', '  printArray(heapTree);']","['# Priority Queue implementation in Python', '    # Find the largest among root, left child and right child', '    if l < n and arr[i] < arr[l]:', '    if r < n and arr[largest] < arr[r]:', '    # Swap and continue heapifying if root is not largest', '        arr[i], arr[largest] = arr[largest], arr[i]', '        heapify(arr, n, largest)', '# Function to insert an element into the tree', '        for i in range((size // 2) - 1, -1, -1):', '            heapify(array, size, i)', '# Function to delete an element from the tree', '    array[i], array[size - 1] = array[size - 1], array[i]', '    for i in range((len(array) // 2) - 1, -1, -1):', '        heapify(array, len(array), i)', 'print (""Max-Heap array: "" + str(arr))', 'print(""After deleting an element: "" + str(arr))', '  void heapify(ArrayList<Integer> hT, int i) {', '    if (l < size && hT.get(l) > hT.get(largest))', '    if (r < size && hT.get(r) > hT.get(largest))', '      int temp = hT.get(largest);', '      hT.set(largest, hT.get(i));', '  void insert(ArrayList<Integer> hT, int newNum) {', '      for (int i = size / 2 - 1; i >= 0; i--) {', '  void deleteNode(ArrayList<Integer> hT, int num) {', '    for (i = 0; i < size; i++) {', '    hT.set(i, hT.get(size - 1));', '    for (int j = size / 2 - 1; j >= 0; j--) {', '  void printArray(ArrayList<Integer> array, int size) {', '      System.out.print(i + "" "");', '  public static void main(String args[]) {', '    ArrayList<Integer> array = new ArrayList<Integer>();', '    System.out.println(""Max-Heap array: "");', '    System.out.println(""After deleting an element: "");', 'void heapify(int array[], int size, int i) {', '    printf(""Single element in the heap"");', '    if (l < size && array[l] > array[largest])', '    if (r < size && array[r] > array[largest])', '      swap(&array[i], &array[largest]);', '      heapify(array, size, largest);', 'void insert(int array[], int newNum) {', '    for (int i = size / 2 - 1; i >= 0; i--) {', 'void deleteRoot(int array[], int num) {', '  swap(&array[i], &array[size - 1]);', '  for (int i = size / 2 - 1; i >= 0; i--) {', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i)', '  printf(""After deleting an element: "");', 'void heapify(vector<int> &hT, int i) {', '  if (l < size && hT[l] > hT[largest])', '  if (r < size && hT[r] > hT[largest])', 'void insert(vector<int> &hT, int newNum) {', '    for (int i = size / 2 - 1; i >= 0; i--) {', 'void deleteNode(vector<int> &hT, int num) {', '  for (int i = size / 2 - 1; i >= 0; i--) {', 'void printArray(vector<int> &hT) {', '  for (int i = 0; i < hT.size(); ++i)', '  cout << ""After deleting an element: "";']","['If there is no node, ', '  create a newNode.', 'else (a node is already present)', '  insert the newNode at the end (last node from left to right.)', '  ', 'heapify the array', 'If nodeToBeDeleted is the leafNode', '  remove the node', 'Else swap nodeToBeDeleted with the lastLeafNode', '  remove noteToBeDeleted', '   ', 'heapify the array', 'return rootNode']",['perations|||peek|||insert|||delete&&&inked List|||O(1)|||O(n)|||O(1)&&&inary Heap|||O(1)|||O(log n)|||O(log n)&&&inary Search Tree|||O(1)|||O(log n)|||O(log n)'],"[""Insert the new element at the end of the tree.|||Insert an element at the end of the queue|||Heapify the tree.|||Heapify after insertion|||Select the element to be deleted.|||Select the element to be deleted|||Swap it with the last element.|||Swap with the last leaf node element|||Remove the last element.|||Remove the last element leaf|||Heapify the tree.|||Heapify the priority queue|||Dijkstra's algorithm|||for implementing stack|||for load balancing and interrupt handling in an operating system|||for data compression in Huffman code|||""]"
11,['Deque Data Structure'],"['In this tutorial, you will learn what a double ended queue (deque) is. Also, you will find working examples of different operations on a deque in C, C++, Java and Python.']",[],[],"['Types of Deque', 'Operations on a Deque', 'Deque Implementation in Python, Java, C, and C++', 'Time Complexity', 'Applications of Deque Data Structure']","['1. Insert at the Front', '2. Insert at the Rear', '3. Delete from the Front', '4. Delete from the Rear', '5. Check Empty', '6. Check Full']","['//cdn.programiz.com/sites/tutorial2program/files/deque.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-array.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-front-1.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-front-2.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-front-3.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-rear-1.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-rear-2.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-insert-rear-3.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-delete-front-1.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-delete-front-2.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-delete-rear-1.png', '//cdn.programiz.com/sites/tutorial2program/files/deque-delete-rear-2.png']","['This operation adds an element at the front.', 'This operation adds an element to the rear.', 'The operation deletes an element from the front.', 'This operation deletes an element from the rear.']","['Below is the circular array implementation of deque. In a circular array, if the array is full, we start from the beginning.', 'Before performing the following operations, these steps are followed.', 'This operation checks if the deque is empty. If front = -1, the deque is empty.', 'This operation checks if the deque is full. If front = 0 and rear = n - 1 OR front = rear + 1, the deque is full.', 'The time complexity of all the above operations is constant i.e. O(1).']","['Deque or Double Ended Queue is a type of queue in which insertion and removal of elements can either be performed from the front or the rear. Thus, it does not follow FIFO rule (First In First Out).', 'But in a linear array implementation, if the array is full, no more elements can be inserted. In each of the operations below, if the array is full, ""overflow message"" is thrown.']","['class Deque:', '    def __init__(self):', '        self.items = []', '    def isEmpty(self):', '    def addRear(self, item):', '    def addFront(self, item):', '    def removeFront(self):', '    def removeRear(self):', '    def size(self):', '        return len(self.items)', 'd = Deque()', 'print(d.isEmpty())', 'd.addRear(8)', 'd.addRear(5)', 'd.addFront(7)', 'd.addFront(10)', 'print(d.size())', 'print(d.isEmpty())', 'd.addRear(11)', 'print(d.removeRear())', 'print(d.removeFront())', 'd.addFront(55)', 'd.addRear(45)', 'print(d.items)', 'class Deque {', '  static final int MAX = 100;', '  int arr[];', '  int front;', '  int rear;', '  int size;', '  public Deque(int size) {', '    arr = new int[MAX];', '    front = -1;', '    rear = 0;', '    this.size = size;', '  boolean isFull() {', '  boolean isEmpty() {', '    return (front == -1);', '  void insertfront(int key) {', '    if (isFull()) {', '      return;', '    if (front == -1) {', '      front = 0;', '      rear = 0;', '    else if (front == 0)', '      front = size - 1;', '    else', '      front = front - 1;', '    arr[front] = key;', '  void insertrear(int key) {', '    if (isFull()) {', '      return;', '    if (front == -1) {', '      front = 0;', '      rear = 0;', '    else if (rear == size - 1)', '      rear = 0;', '    else', '      rear = rear + 1;', '    arr[rear] = key;', '  void deletefront() {', '    if (isEmpty()) {', '      return;', '    if (front == rear) {', '      front = -1;', '      rear = -1;', '      front = 0;', '    else', '      front = front + 1;', '  void deleterear() {', '    if (isEmpty()) {', '      return;', '    if (front == rear) {', '      front = -1;', '      rear = -1;', '    } else if (rear == 0)', '      rear = size - 1;', '    else', '      rear = rear - 1;', '  int getFront() {', '    if (isEmpty()) {', '      return -1;', '    return arr[front];', '  int getRear() {', '      return -1;', '    return arr[rear];', '    Deque dq = new Deque(4);', '    dq.insertrear(12);', '    dq.insertrear(14);', '    dq.deleterear();', '    dq.insertfront(13);', '    dq.deletefront();', '#include <stdio.h>', '#define MAX 10', 'void display(int *);', 'int count(int *);', 'int main() {', '  int arr[MAX];', '  int front, rear, i, n;', '  front = rear = -1;', '  for (i = 0; i < MAX; i++)', '    arr[i] = 0;', '  display(arr);', '  display(arr);', '  display(arr);', '  display(arr);', '  n = count(arr);', '  int i, k, c;', '    return;', '  if (*pfront == -1) {', '    *pfront = *prear = 0;', '    arr[*pfront] = item;', '    return;', '  if (*prear != MAX - 1) {', '    c = count(arr);', '    k = *prear + 1;', '    for (i = 1; i <= c; i++) {', '      arr[k] = arr[k - 1];', '      k--;', '    arr[k] = item;', '    *pfront = k;', '    (*prear)++;', '  } else {', '    (*pfront)--;', '    arr[*pfront] = item;', '  int i, k;', '    return;', '  if (*pfront == -1) {', '    *prear = *pfront = 0;', '    arr[*prear] = item;', '    return;', '  if (*prear == MAX - 1) {', '    k = *pfront - 1;', '      k = i;', '      if (k == MAX - 1)', '        arr[k] = 0;', '      else', '        arr[k] = arr[i + 1];', '    (*prear)--;', '    (*pfront)--;', '  (*prear)++;', '  arr[*prear] = item;', '  int item;', '  if (*pfront == -1) {', '    return 0;', '  item = arr[*pfront];', '  arr[*pfront] = 0;', '  if (*pfront == *prear)', '    *pfront = *prear = -1;', '    (*pfront)++;', '  return item;', '  int item;', '  if (*pfront == -1) {', '    return 0;', '  item = arr[*prear];', '  arr[*prear] = 0;', '  (*prear)--;', '  if (*prear == -1)', '    *pfront = -1;', '  return item;', 'void display(int *arr) {', '  int i;', '  printf(""\\n front:  "");', '  for (i = 0; i < MAX; i++)', '    printf(""  %d"", arr[i]);', '  printf(""  :rear"");', 'int count(int *arr) {', '  int c = 0, i;', '  for (i = 0; i < MAX; i++) {', '    if (arr[i] != 0)', '      c++;', '  return c;', '#include <iostream>', 'using namespace std;', '#define MAX 10', 'class Deque {', '  int arr[MAX];', '  int front;', '  int rear;', '  int size;', '   public:', '  Deque(int size) {', '    front = -1;', '    rear = 0;', '    this->size = size;', '  void insertfront(int key);', '  void insertrear(int key);', '  void deletefront();', '  void deleterear();', '  bool isFull();', '  bool isEmpty();', '  int getFront();', '  int getRear();', 'bool Deque::isFull() {', '      front == rear + 1);', 'bool Deque::isEmpty() {', '  return (front == -1);', '  if (isFull()) {', '    cout << ""Overflow\\n""', '       << endl;', '    return;', '  if (front == -1) {', '    front = 0;', '    rear = 0;', '  else if (front == 0)', '    front = size - 1;', '    front = front - 1;', '  arr[front] = key;', '  if (isFull()) {', '    return;', '  if (front == -1) {', '    front = 0;', '    rear = 0;', '  else if (rear == size - 1)', '    rear = 0;', '    rear = rear + 1;', '  arr[rear] = key;', 'void Deque ::deletefront() {', '  if (isEmpty()) {', '       << endl;', '    return;', '  if (front == rear) {', '    front = -1;', '    rear = -1;', '    front = 0;', '    front = front + 1;', 'void Deque::deleterear() {', '  if (isEmpty()) {', '    cout << "" Underflow\\n""', '       << endl;', '    return;', '  if (front == rear) {', '    front = -1;', '    rear = -1;', '  } else if (rear == 0)', '    rear = size - 1;', '    rear = rear - 1;', 'int Deque::getFront() {', '  if (isEmpty()) {', '    cout << "" Underflow\\n""', '       << endl;', '    return -1;', '  return arr[front];', 'int Deque::getRear() {', '  if (isEmpty() || rear < 0) {', '    cout << "" Underflow\\n""', '       << endl;', '    return -1;', '  return arr[rear];', 'int main() {', '  Deque dq(4);', '  dq.insertrear(5);', '  dq.insertrear(11);', '  cout << ""rear element: ""', '     << dq.getRear() << endl;', '  dq.deleterear();', '  dq.insertfront(8);', '  dq.deletefront();']","['        self.items.insert(0, item)', '        return self.items.pop(0)', '    return ((front == 0 && rear == size - 1) || front == rear + 1);', '      System.out.println(""Overflow"");', '      System.out.println("" Overflow "");', '      System.out.println(""Queue Underflow\\n"");', '    } else if (front == size - 1)', '      System.out.println("" Underflow"");', '      System.out.println("" Underflow"");', '    if (isEmpty() || rear < 0) {', '      System.out.println("" Underflow\\n"");', '  public static void main(String[] args) {', '    System.out.println(""Insert element at rear end : 12 "");', '    System.out.println(""insert element at rear end : 14 "");', '    System.out.println(""get rear element : "" + dq.getRear());', '    System.out.println(""After delete rear element new rear become : "" + dq.getRear());', '    System.out.println(""inserting element at front end"");', '    System.out.println(""get front element: "" + dq.getFront());', '    System.out.println(""After delete front element new front become : "" + +dq.getFront());', 'void addFront(int *, int, int *, int *);', 'void addRear(int *, int, int *, int *);', 'int delFront(int *, int *, int *);', 'int delRear(int *, int *, int *);', '  addRear(arr, 5, &front, &rear);', '  addFront(arr, 12, &front, &rear);', '  addRear(arr, 11, &front, &rear);', '  addFront(arr, 5, &front, &rear);', '  addRear(arr, 6, &front, &rear);', '  addFront(arr, 8, &front, &rear);', '  printf(""\\nElements in a deque: "");', '  i = delFront(arr, &front, &rear);', '  printf(""\\nremoved item: %d"", i);', '  printf(""\\nElements in a deque after deletion: "");', '  addRear(arr, 16, &front, &rear);', '  addRear(arr, 7, &front, &rear);', '  printf(""\\nElements in a deque after addition: "");', '  i = delRear(arr, &front, &rear);', '  printf(""\\nremoved item: %d"", i);', '  printf(""\\nElements in a deque after deletion: "");', '  printf(""\\nTotal number of elements in deque: %d"", n);', 'void addFront(int *arr, int item, int *pfront, int *prear) {', '  if (*pfront == 0 && *prear == MAX - 1) {', '    printf(""\\nDeque is full.\\n"");', 'void addRear(int *arr, int item, int *pfront, int *prear) {', '  if (*pfront == 0 && *prear == MAX - 1) {', '    printf(""\\nDeque is full.\\n"");', '    for (i = *pfront - 1; i < *prear; i++) {', 'int delFront(int *arr, int *pfront, int *prear) {', '    printf(""\\nDeque is empty.\\n"");', 'int delRear(int *arr, int *pfront, int *prear) {', '    printf(""\\nDeque is empty.\\n"");', '  return ((front == 0 && rear == size - 1) ||', 'void Deque::insertfront(int key) {', 'void Deque ::insertrear(int key) {', '    cout << "" Overflow\\n "" << endl;', '  cout << ""insert element at rear end \\n"";', '  cout << ""after deletion of the rear element, the new rear element: "" << dq.getRear() << endl;', '  cout << ""insert element at front end \\n"";', '  cout << ""front element: "" << dq.getFront() << endl;', '  cout << ""after deletion of front element new front element: "" << dq.getFront() << endl;']",[],[],"['Input Restricted Deque|||In this deque, input is restricted at a single end but allows deletion at both the ends.|||Output Restricted Deque|||In this deque, output is restricted at a single end but allows insertion at both the ends.|||&&&Take an array (deque) of size n.|||Set two pointers at the first position and set front = -1 and rear = 0.|||Check the position of front.|||Check the position of front|||If front < 1, reinitialize front = n-1 (last index).|||Shift front to the end|||Else, decrease front by 1.|||Add the new key 5 into array[front].|||Insert the element at Front|||Check if the array is full.|||Check if deque is full|||If the deque is full, reinitialize rear = 0.|||Else, increase rear by 1.|||Increase the rear|||Add the new key 5 into array[rear].|||Insert the element at rear|||Check if the deque is empty.|||Check if deque is empty|||If the deque is empty (i.e. front = -1), deletion cannot be performed (underflow condition).|||If the deque has only one element (i.e. front = rear), set front = -1 and rear = -1.|||Else if front is at the end (i.e. front = n - 1), set go to the front front = 0.|||Else, front = front + 1.|||Increase the front|||Check if the deque is empty.|||Check if deque is empty|||If the deque is empty (i.e. front = -1), deletion cannot be performed (underflow condition).|||If the deque has only one element (i.e. front = rear), set front = -1 and rear = -1, else follow the steps below.|||If rear is at the front (i.e. rear = 0), set go to the front rear = n - 1.|||Else, rear = rear - 1.|||Decrease the rear|||In undo operations on software.|||To store history in browsers.|||For implementing both stacks and queues.|||']"
12,['Linked list Data Structure'],"[""In this tutorial, you will learn about linked list data structure and it's implementation in Python, Java, C, and C++.""]",[],[],"['Representation of Linked List', 'Linked List Utility', 'Linked List Implementations in Python, Java, C, and C++ Examples', 'Linked List Complexity', 'Linked List Applications']","['Recommended Readings', '1. Tutorials', '2. Examples']","['//cdn.programiz.com/sites/tutorial2program/files/linked-list-concept.png', '//cdn.programiz.com/sites/tutorial2program/files/linked-list-with-data.png']","['Time Complexity', 'Space Complexity: O(n)']","[""Let's see how each node of the linked list is represented. Each node consists:"", 'We wrap both the data item and the next node reference in a struct as:', 'Understanding the structure of a linked list node is the key to having a grasp on it.', ""If you didn't understand any of the lines above, all you need is a refresher on pointers and structs."", 'In just a few steps, we have created a simple linked list with three nodes.', 'Doing something similar in an array would have required shifting the positions of all the subsequent elements.', 'In python and Java, the linked list can be implemented using classes as shown in the codes below.']","['A linked list is a linear data structure that includes a series of connected nodes. Here, each node stores the data and the address of the next node. For example,', 'You have to start somewhere, so we give the address of the first node a special name called HEAD. Also, the last node in the linked list can be identified because its next portion points to NULL.', 'Linked lists can be of multiple types: singly, doubly, and circular linked list. In this article, we will focus on the singly linked list. To learn about other types, visit Types of Linked List.', 'Note: You might have played the game Treasure Hunt, where each clue includes the information about the next clue. That is how the linked list operates.', 'Each struct node has a data item and a pointer to another struct node. Let us create a simple Linked List with three items to understand how this works.', 'The power of a linked list comes from the ability to break the chain and rejoin it. E.g. if you wanted to put an element 4 between 1 and 2, the steps would be:', 'Lists are one of the most popular and efficient data structures, with implementation in every programming language like C, C++, Python, Java, and C#.', 'Apart from that, linked lists are a great way to learn how pointers work. By practicing how to manipulate linked lists, you can prepare yourself to learn more advanced data structures like graphs and trees.']","['struct node', '  int data;', '  struct node *next;', '/* Initialize nodes */', 'struct node *head;', 'struct node *one = NULL;', 'struct node *two = NULL;', 'struct node *three = NULL;', '/* Allocate memory */', '/* Assign data values */', 'one->data = 1;', 'two->data = 2;', 'three->data=3;', '/* Connect nodes */', 'one->next = two;', 'two->next = three;', 'three->next = NULL;', 'head = one;', 'class Node:', '    # Creating a node', '    def __init__(self, item):', '        self.item = item', '        self.next = None', 'class LinkedList:', '    def __init__(self):', '        self.head = None', ""if __name__ == '__main__':"", '    linked_list = LinkedList()', '    # Assign item values', '    linked_list.head = Node(1)', '    second = Node(2)', '    third = Node(3)', '    # Connect nodes', '    second.next = third', 'class LinkedList {', '  Node head;', '  static class Node {', '    int value;', '    Node next;', '    Node(int d) {', '      value = d;', '      next = null;', '    Node second = new Node(2);', '    Node third = new Node(3);', '    second.next = third;', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int value;', '  struct node *next;', '  while (p != NULL) {', '    printf(""%d "", p->value);', '    p = p->next;', 'int main() {', '  struct node *head;', '  struct node *one = NULL;', '  struct node *two = NULL;', '  struct node *three = NULL;', '  one->value = 1;', '  two->value = 2;', '  three->value = 3;', '  one->next = two;', '  two->next = three;', '  three->next = NULL;', '  head = one;', '  printLinkedlist(head);', '#include <bits/stdc++.h>', '#include <iostream>', 'using namespace std;', 'class Node {', '   public:', '  int value;', '  Node* next;', 'int main() {', '  Node* head;', '  Node* one = NULL;', '  Node* two = NULL;', '  Node* three = NULL;', '  one = new Node();', '  two = new Node();', '  three = new Node();', '  one->value = 1;', '  two->value = 2;', '  three->value = 3;', '  one->next = two;', '  two->next = three;', '  three->next = NULL;', '  head = one;', '  while (head != NULL) {', '    cout << head->value;', '    head = head->next;']","['one = malloc(sizeof(struct node));', 'two = malloc(sizeof(struct node));', 'three = malloc(sizeof(struct node));', '/* Save address of first node in head */', '# Linked list implementation in Python', '    linked_list.head.next = second', '    # Print the linked list item', '    while linked_list.head != None:', '        print(linked_list.head.item, end="" "")', '        linked_list.head = linked_list.head.next', '  public static void main(String[] args) {', '    LinkedList linkedList = new LinkedList();', '    linkedList.head = new Node(1);', '    linkedList.head.next = second;', '    while (linkedList.head != null) {', '      System.out.print(linkedList.head.value + "" "");', '      linkedList.head = linkedList.head.next;', 'void printLinkedlist(struct node *p) {', '  one = malloc(sizeof(struct node));', '  two = malloc(sizeof(struct node));', '  three = malloc(sizeof(struct node));']",[],['|||Worst case|||Average Case&&&earch|||O(n)|||O(n)&&&nsert|||O(1)|||O(1)&&&eletion|||O(1)|||O(1)'],"['A data item|||An address of another node|||Create a new struct node and allocate memory to it.|||Add its data value as 4|||Point its next pointer to the struct node containing 2 as the data value|||Change the next pointer of ""1"" to the node we just created.|||Dynamic memory allocation|||Implemented in stack and queue|||In undo functionality of softwares|||Hash tables, Graphs|||Linked List Operations (Traverse, Insert, Delete)|||Types of Linked List|||Java LinkedList|||Get the middle element of Linked List in a single iteration|||Convert the Linked List into an Array and vice versa|||Detect loop in a Linked List|||']"
13,"['Linked List Operations: Traverse, Insert and Delete']","['In this tutorial, you will learn different operations on a linked list. Also, you will find implementation of linked list operations in C/C++, Python and Java.']",[],[],"['Traverse a Linked List', 'Insert Elements to a Linked List', 'Delete from a Linked List', 'Search an Element on a Linked List', 'Sort Elements of a Linked List', 'LinkedList Operations in Python, Java, C, and C++']","['Things to Remember about Linked List', '1. Insert at the beginning', '2. Insert at the End', '3. Insert at the Middle', '1. Delete from beginning', '2. Delete from end', '3. Delete from middle']",[],['The output of this program will be:'],"[""Here's a list of basic linked list operations that we will cover in this article."", 'Before you learn about linked list operations in detail, make sure to know about Linked List first.', 'In all of the examples, we will assume that the linked list has three nodes 1 --->2 --->3 with node structure as below:', 'When temp is NULL, we know that we have reached the end of the linked list so we get out of the while loop.', 'You can add elements to either the beginning, middle or end of the linked list.', 'You can delete either from the beginning, end or from a particular position.', 'You can search an element on a linked list using a loop using the following steps. We are finding item on a linked list.', 'We will use a simple sorting algorithm, Bubble Sort, to sort the elements of a linked list in ascending order below.', 'Check the article on bubble sort for better understanding of its working.']","['There are various linked list operations that allow us to perform different actions on linked lists. For example, the insertion operation adds a new element to the linked list.']","['struct node {', '  int data;', '  struct node *next;', 'struct node *temp = head;', 'while(temp != NULL) {', '  temp = temp->next;', 'struct node *newNode;', 'newNode->data = 4;', 'newNode->next = head;', 'head = newNode;', 'struct node *newNode;', 'newNode->data = 4;', 'newNode->next = NULL;', 'struct node *temp = head;', 'while(temp->next != NULL){', '  temp = temp->next;', 'temp->next = newNode;', 'struct node *newNode;', 'newNode->data = 4;', 'struct node *temp = head;', '  if(temp->next != NULL) {', '    temp = temp->next;', 'newNode->next = temp->next;', 'temp->next = newNode;', 'head = head->next;', 'struct node* temp = head;', 'while(temp->next->next!=NULL){', '  temp = temp->next;', 'temp->next = NULL;', '  if(temp->next!=NULL) {', '    temp = temp->next;', 'temp->next = temp->next->next;', '  while (current != NULL) {', '      current = current->next;', '  return false;', '  int temp;', '  if (head_ref == NULL) {', '    return;', '  } else {', '    while (current != NULL) {', '      index = current->next;', '  \twhile (index != NULL) {', '          index->data = temp;', '    \t  }', '    \t  index = index->next;', '  \tcurrent = current->next;', '# Create a node', 'class Node:', '    def __init__(self, data):', '        self.data = data', '        self.next = None', 'class LinkedList:', '    def __init__(self):', '        self.head = None', '    # Insert at the beginning', '        self.head = new_node', '    # Insert after a node', '        if prev_node is None:', '            return', '    # Insert at the end', '        if self.head is None:', '            return', '        last = self.head', '        while (last.next):', '            last = last.next', '        last.next = new_node', '    # Deleting a node', '        if self.head is None:', '            return', '        temp = self.head', '        if position == 0:', '            temp = None', '            return', '            temp = temp.next', '            if temp is None:', '                break', '        if temp is None:', '            return', '        if temp.next is None:', '            return', '        next = temp.next.next', '        temp.next = None', '        temp.next = next', '    # Search an element', '    def search(self, key):', '        current = self.head', '                return True', '        return False', '    # Sort the linked list', '        current = head', '        index = Node(None)', '        if head is None:', '            return', '        else:', '    # Print the linked list', '    def printList(self):', '        temp = self.head', '        while (temp):', '            temp = temp.next', ""if __name__ == '__main__':"", '    llist = LinkedList()', '    llist.insertAtEnd(1)', '    llist.insertAtBeginning(2)', '    llist.insertAtBeginning(3)', '    llist.insertAtEnd(4)', ""    print('linked list:')"", '    llist.printList()', '    llist.deleteNode(3)', '    llist.printList()', '    print()', '    item_to_find = 3', '    else:', '    print(""Sorted List: "")', '    llist.printList()', 'class LinkedList {', '  Node head;', '  class Node {', '    int data;', '    Node next;', '    Node(int d) {', '      data = d;', '      next = null;', '    new_node.next = head;', '    head = new_node;', '    if (prev_node == null) {', '      return;', '    prev_node.next = new_node;', '    if (head == null) {', '      return;', '    new_node.next = null;', '    Node last = head;', '    while (last.next != null)', '      last = last.next;', '    last.next = new_node;', '    return;', '    if (head == null)', '      return;', '    Node temp = head;', '    if (position == 0) {', '      head = temp.next;', '      return;', '      temp = temp.next;', '      return;', '    temp.next = next;', '    Node current = head;', '    while (current != null) {', '      if (current.data == key)', '        return true;', '      current = current.next;', '    return false;', '    Node current = head;', '    Node index = null;', '    int temp;', '    if (head == null) {', '      return;', '    } else {', '        index = current.next;', '            index.data = temp;', '          }', '          index = index.next;', '        }', '  public void printList() {', '    Node tnode = head;', '    while (tnode != null) {', '      tnode = tnode.next;', '    llist.insertAtEnd(1);', '    llist.insertAtEnd(4);', '    llist.printList();', '    llist.deleteNode(3);', '    llist.printList();', '    System.out.println();', '    int item_to_find = 3;', '    else', '    llist.printList();', '#include <stdio.h>', '#include <stdlib.h>', 'struct Node {', '  int data;', '  struct Node* next;', '  new_node->data = new_data;', '  (*head_ref) = new_node;', '  if (prev_node == NULL) {', '  return;', '  new_node->data = new_data;', '  prev_node->next = new_node;', '  new_node->data = new_data;', '  new_node->next = NULL;', '  if (*head_ref == NULL) {', '  *head_ref = new_node;', '  return;', '  last->next = new_node;', '  return;', '  *head_ref = temp->next;', '  free(temp);', '  return;', '  prev = temp;', '  temp = temp->next;', '  if (temp == NULL) return;', '  prev->next = temp->next;', '  free(temp);', '  while (current != NULL) {', '  current = current->next;', '  return 0;', '  int temp;', '  if (head_ref == NULL) {', '  return;', '  } else {', '  while (current != NULL) {', '    index = current->next;', '    while (index != NULL) {', '      temp = current->data;', '      index->data = temp;', '    index = index->next;', '    current = current->next;', '  while (node != NULL) {', '  printf("" %d "", node->data);', '  node = node->next;', 'int main() {', '  struct Node* head = NULL;', '  insertAtEnd(&head, 1);', '  insertAtBeginning(&head, 2);', '  insertAtBeginning(&head, 3);', '  insertAtEnd(&head, 4);', '  insertAfter(head->next, 5);', '  printf(""Linked list: "");', '  printList(head);', '  deleteNode(&head, 3);', '  printList(head);', '  int item_to_find = 3;', '  } else {', '  sortLinkedList(&head);', '  printf(""\\nSorted List: "");', '  printList(head);', '#include <stdlib.h>', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  struct Node* next;', '  new_node->data = new_data;', '  (*head_ref) = new_node;', '  if (prev_node == NULL) {', '  return;', '  new_node->data = new_data;', '  prev_node->next = new_node;', '  new_node->data = new_data;', '  new_node->next = NULL;', '  if (*head_ref == NULL) {', '  *head_ref = new_node;', '  return;', '  last->next = new_node;', '  return;', '  *head_ref = temp->next;', '  free(temp);', '  return;', '  prev = temp;', '  temp = temp->next;', '  if (temp == NULL) return;', '  prev->next = temp->next;', '  free(temp);', '  while (current != NULL) {', '  current = current->next;', '  return false;', '  int temp;', '  if (head_ref == NULL) {', '  return;', '  } else {', '  while (current != NULL) {', '    index = current->next;', '    while (index != NULL) {', '      temp = current->data;', '      index->data = temp;', '    index = index->next;', '    current = current->next;', '  while (node != NULL) {', '  cout << node->data << "" "";', '  node = node->next;', 'int main() {', '  struct Node* head = NULL;', '  insertAtEnd(&head, 1);', '  insertAtBeginning(&head, 2);', '  insertAtBeginning(&head, 3);', '  insertAtEnd(&head, 4);', '  insertAfter(head->next, 5);', '  cout << ""Linked list: "";', '  printList(head);', '  deleteNode(&head, 3);', '  printList(head);', '  int item_to_find = 3;', '  } else {', '  sortLinkedList(&head);', '  cout << ""\\nSorted List: "";', '  printList(head);']","['printf(""\\n\\nList elements are - \\n"");', 'newNode = malloc(sizeof(struct node));', 'newNode = malloc(sizeof(struct node));', 'newNode = malloc(sizeof(struct node));', 'for(int i=2; i < position; i++) {', 'for(int i=2; i< position; i++) {', 'bool searchNode(struct Node** head_ref, int key) {', '  struct Node* current = *head_ref;', '    if (current->data == key) return true;', 'void sortLinkedList(struct Node** head_ref) {', '  struct Node *current = *head_ref, *index = NULL;', '        if (current->data > index->data) {', '          current->data = index->data;', '# Linked list operations in Python', '    def insertAtBeginning(self, new_data):', '        new_node = Node(new_data)', '        new_node.next = self.head', '    def insertAfter(self, prev_node, new_data):', '            print(""The given previous node must inLinkedList."")', '        new_node = Node(new_data)', '        new_node.next = prev_node.next', '        prev_node.next = new_node', '    def insertAtEnd(self, new_data):', '        new_node = Node(new_data)', '            self.head = new_node', '    def deleteNode(self, position):', '            self.head = temp.next', '        # Find the key to be deleted', '        for i in range(position - 1):', '        # If the key is not present', '        while current is not None:', '            if current.data == key:', '            current = current.next', '    def sortLinkedList(self, head):', '            while current is not None:', '                # index points to the node next to current', '                index = current.next', '                while index is not None:', '                    if current.data > index.data:', '                        current.data, index.data = index.data, current.data', '                    index = index.next', '                current = current.next', '            print(str(temp.data) + "" "", end="""")', '    llist.insertAfter(llist.head.next, 5)', '    print(""\\nAfter deleting an element:"")', '    if llist.search(item_to_find):', '        print(str(item_to_find) + "" is found"")', '        print(str(item_to_find) + "" is not found"")', '    llist.sortLinkedList(llist.head)', '  public void insertAtBeginning(int new_data) {', '    Node new_node = new Node(new_data);', '  public void insertAfter(Node prev_node, int new_data) {', '      System.out.println(""The given previous node cannot be null"");', '    Node new_node = new Node(new_data);', '    new_node.next = prev_node.next;', '  public void insertAtEnd(int new_data) {', '    Node new_node = new Node(new_data);', '      head = new Node(new_data);', '  void deleteNode(int position) {', '    for (int i = 0; temp != null && i < position - 1; i++)', '    if (temp == null || temp.next == null)', '  boolean search(Node head, int key) {', '  void sortLinkedList(Node head) {', '          if (current.data > index.data) {', '            temp = current.data;', '            current.data = index.data;', '      System.out.print(tnode.data + "" "");', '  public static void main(String[] args) {', '    LinkedList llist = new LinkedList();', '    llist.insertAfter(llist.head.next, 5);', '    System.out.println(""Linked list: "");', '    System.out.println(""\\nAfter deleting an element: "");', '    if (llist.search(llist.head, item_to_find))', '      System.out.println(item_to_find + "" is found"");', '      System.out.println(item_to_find + "" is not found"");', '    llist.sortLinkedList(llist.head);', '    System.out.println(""\\nSorted List: "");', 'void insertAtBeginning(struct Node** head_ref, int new_data) {', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', 'void insertAfter(struct Node* prev_node, int new_data) {', '  printf(""the given previous node cannot be NULL"");', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', '  new_node->next = prev_node->next;', 'void insertAtEnd(struct Node** head_ref, int new_data) {', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', '  struct Node* last = *head_ref; /* used in step 5*/', '  while (last->next != NULL) last = last->next;', 'void deleteNode(struct Node** head_ref, int key) {', '  struct Node *temp = *head_ref, *prev;', '  if (temp != NULL && temp->data == key) {', '  while (temp != NULL && temp->data != key) {', 'int searchNode(struct Node** head_ref, int key) {', '  struct Node* current = *head_ref;', '  if (current->data == key) return 1;', 'void sortLinkedList(struct Node** head_ref) {', '  struct Node *current = *head_ref, *index = NULL;', '    if (current->data > index->data) {', '      current->data = index->data;', 'void printList(struct Node* node) {', '  printf(""\\nAfter deleting an element: "");', '  if (searchNode(&head, item_to_find)) {', '  printf(""\\n%d is found"", item_to_find);', '  printf(""\\n%d is not found"", item_to_find);', 'void insertAtBeginning(struct Node** head_ref, int new_data) {', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', 'void insertAfter(struct Node* prev_node, int new_data) {', '  cout << ""the given previous node cannot be NULL"";', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', '  new_node->next = prev_node->next;', 'void insertAtEnd(struct Node** head_ref, int new_data) {', '  struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));', '  struct Node* last = *head_ref; /* used in step 5*/', '  while (last->next != NULL) last = last->next;', 'void deleteNode(struct Node** head_ref, int key) {', '  struct Node *temp = *head_ref, *prev;', '  if (temp != NULL && temp->data == key) {', '  while (temp != NULL && temp->data != key) {', 'bool searchNode(struct Node** head_ref, int key) {', '  struct Node* current = *head_ref;', '  if (current->data == key) return true;', 'void sortLinkedList(struct Node** head_ref) {', '  struct Node *current = *head_ref, *index = NULL;', '    if (current->data > index->data) {', '      current->data = index->data;', 'void printList(struct Node* node) {', '  cout << ""\\nAfter deleting an element: "";', '  if (searchNode(&head, item_to_find)) {', '  cout << endl << item_to_find << "" is found"";', '  cout << endl << item_to_find << "" is not found"";']","['List elements are - ', '1 --->2 --->3 --->']",[],"['Traversal - access each element of the linked list|||Insertion - adds a new element to the linked list|||Deletion - removes the existing elements|||Search - find a node in the linked list|||Sort - sort the nodes of the linked list|||head points to the first node of the linked list|||next pointer of the last node is NULL, so if the next current node is NULL, we have reached the end of the linked list.|||Allocate memory for new node|||Store data|||Change next of new node to point to head|||Change head to point to recently created node|||Allocate memory for new node|||Store data|||Traverse to last node|||Change next of last node to recently created node|||Allocate memory and store data for new node|||Traverse to node just before the required position of new node|||Change next pointers to include new node in between|||Point head to the second node|||Traverse to second last element|||Change its next pointer to null|||Traverse to element before the element to be deleted|||Change next pointers to exclude the node from the chain|||Make head as the current node.|||Run a loop until the current node is NULL because the last element points to NULL.|||In each iteration, check if the key of the node is equal to item. If it the key matches the item, return true otherwise return false.|||&&&Make the head as the current node and create another node index for later use.|||If head is null, return.|||Else, run a loop till the last node (i.e. NULL).|||In each iteration, follow the following step 5-6.|||Store the next node of current in index.|||Check if the data of the current node is greater than the next node. If it is greater, swap current and index.|||']"
14,"['Types of Linked List - Singly linked, doubly linked and circular']","['In this tutorial, you will learn different types of linked list. Also, you will find implementation of linked list in C.']",[],[],"['Singly Linked List', 'Doubly Linked List', 'Circular Linked List']",[],"['//cdn.programiz.com/sites/tutorial2program/files/linked-list-concept_0.png', '//cdn.programiz.com/sites/tutorial2program/files/doubly-linked-list-concept.png', '//cdn.programiz.com/sites/tutorial2program/files/circular-linked-list.png']","['There are three common types of Linked List.', 'Node is represented as:', 'A three-member singly linked list can be created as:', 'A node is represented as', 'A three-member doubly linked list can be created as', 'A three-member circular singly linked list can be created as:']","['Before you learn about the type of the linked list, make sure you know about the LinkedList Data Structure.', 'It is the most common. Each node has data and a pointer to the next node.', 'We add a pointer to the previous node in a doubly-linked list. Thus, we can go in either direction: forward or backward.', 'If you want to learn more about it, please visit doubly linked list and operations on it.', 'A circular linked list can be either singly linked or doubly linked.', 'If you want to learn more about it, please visit circular linked list and operations on it.']",['A circular linked list is a variation of a linked list in which the last element is linked to the first element. This forms a circular loop.'],"['struct node {', '    int data;', '    struct node *next;', '/* Initialize nodes */', 'struct node *head;', 'struct node *one = NULL;', 'struct node *two = NULL;', 'struct node *three = NULL;', '/* Allocate memory */', '/* Assign data values */', 'one->data = 1;', 'two->data = 2;', 'three->data = 3;', '/* Connect nodes */', 'one->next = two;', 'two->next = three;', 'three->next = NULL;', 'head = one;', 'struct node {', '    int data;', '    struct node *next;', '    struct node *prev;', '/* Initialize nodes */', 'struct node *head;', 'struct node *one = NULL;', 'struct node *two = NULL;', 'struct node *three = NULL;', '/* Allocate memory */', '/* Assign data values */', 'one->data = 1;', 'two->data = 2;', 'three->data = 3;', '/* Connect nodes */', 'one->next = two;', 'one->prev = NULL;', 'two->next = three;', 'two->prev = one;', 'three->next = NULL;', 'three->prev = two;', 'head = one;', '/* Initialize nodes */', 'struct node *head;', 'struct node *one = NULL;', 'struct node *two = NULL;', 'struct node *three = NULL;', '/* Allocate memory */', '/* Assign data values */', 'one->data = 1;', 'two->data = 2;', 'three->data = 3;', '/* Connect nodes */', 'one->next = two;', 'two->next = three;', 'three->next = one;', 'head = one;']","['one = malloc(sizeof(struct node));', 'two = malloc(sizeof(struct node));', 'three = malloc(sizeof(struct node));', '/* Save address of first node in head */', 'one = malloc(sizeof(struct node));', 'two = malloc(sizeof(struct node));', 'three = malloc(sizeof(struct node));', '/* Save address of first node in head */', 'one = malloc(sizeof(struct node));', 'two = malloc(sizeof(struct node));', 'three = malloc(sizeof(struct node));', '/* Save address of first node in head */']",[],[],"['for singly linked list, next pointer of last item points to the first item|||In the doubly linked list, prev pointer of the first item points to the last item as well.|||&&&Singly Linked List|||Doubly Linked List|||Circular Linked List|||']"
15,['Hash Table'],"['In this tutorial, you will learn what hash table is. Also, you will find working examples of hash table operations in C, C++, Java and Python.']",[],[],"['Hashing (Hash Function)', 'Hash Collision', '1. Collision resolution by chaining', '2. Open Addressing', 'Good Hash Functions', 'Python, Java and\xa0C/C++ Examples', 'Applications of Hash Table']","['i. Linear Probing', 'ii. Quadratic Probing', 'iii. Double hashing', '1. Division Method', '2. Multiplication Method', '3. Universal Hashing']","['//cdn.programiz.com/sites/tutorial2program/files/Hash-0.png', '//cdn.programiz.com/sites/tutorial2program/files/Hash-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/Hash-3_1.png']","['Let k be a key and h(x) be a hash function.', 'To learn more, visit Hashing.', 'Pseudocode for operations', 'Different techniques used in open addressing are:', 'h(k, i) = (h′(k) + i) mod m', 'where', 'h(k, i) = (h′(k) + c1i + c2i2) mod m', 'where,', 'h(k, i) = (h1(k) + ih2(k)) mod m', 'h(k) = k mod m', 'h(k) = ⌊m(kA mod 1)⌋', 'where,', 'Hash tables are implemented where']","['The Hash table data structure stores elements in key-value pairs where', 'Here, h(k) will give us a new index to store the element linked with k.', 'We can resolve the hash collision using one of the following techniques.', 'In linear probing, collision is resolved by checking the next slot.', 'If a collision occurs at h(k, 0), then h(k, 1) is checked. In this way, the value of i is incremented linearly.', 'If a collision occurs after applying a hash function h(k), then another hash function is calculated for finding the next slot.', 'A good hash function may not prevent the collisions completely however it can reduce the number of collisions.', 'Here, we will look into different methods to find a good hash function', 'If k is a key and m is the size of the hash table, the hash function h() is calculated as:', 'In Universal hashing, the hash function is chosen at random independent of keys.']","['In a hash table, a new index is processed using the keys. And, the element corresponding to that key is stored in the index. This process is called hashing.', 'When the hash function generates the same index for multiple keys, there will be a conflict (what value to be stored in that index). This is called a\xa0hash collision.', 'In chaining, if a hash function produces the same index for multiple elements, these elements are stored in the same index by using a doubly-linked list.', 'If j is the slot for multiple elements, it contains a pointer to the head of the list of elements. If no element is present, j contains NIL.', ""Unlike chaining, open addressing doesn't store multiple elements into the same slot. Here, each slot is either filled with a single key or left NIL."", 'The problem with linear probing is that a cluster of adjacent slots is filled. When inserting a new element, the entire cluster must be traversed. This adds to the time required to perform operations on the hash table.', 'It works similar to linear probing but the spacing between the slots is increased (greater than one) by using the following relation.', 'For example, If the size of a hash table is 10 and k = 112 then h(k) = 112 mod 10 = 2. The value of m must not be the powers of 2. This is because the powers of 2 in binary format are 10, 100, 1000, …. When we find k mod m, we will always get the lower order p-bits.']","['chainedHashSearch(T, k)', '  return T[h(k)]', 'chainedHashInsert(T, x)', 'chainedHashDelete(T, x)', '  T[h(x.key)] = NIL', 'hashTable = [[],] * 10', 'def checkPrime(n):', '    if n == 1 or n == 0:', '        return 0', '    for i in range(2, n//2):', '        if n % i == 0:', '            return 0', '    return 1', 'def getPrime(n):', '    if n % 2 == 0:', '        n = n + 1', '    while not checkPrime(n):', '        n += 2', '    return n', 'def hashFunction(key):', '    capacity = getPrime(10)', '    return key % capacity', 'def insertData(key, data):', '    index = hashFunction(key)', 'def removeData(key):', '    index = hashFunction(key)', '    hashTable[index] = 0', 'insertData(123, ""apple"")', 'insertData(432, ""mango"")', 'insertData(213, ""banana"")', 'insertData(654, ""guava"")', 'print(hashTable)', 'removeData(123)', 'print(hashTable)', 'import java.util.*; ', 'class HashTable { ', '  Hashtable<Integer, Integer> ', '  ht.put(123, 432); ', '  ht.put(12, 2345);', '  ht.put(15, 5643); ', '  ht.put(3, 321);', '  ht.remove(12);', '  System.out.println(ht); ', '#include <stdio.h>', '#include <stdlib.h>', 'struct set', '  int key;', '  int data;', 'struct set *array;', 'int capacity = 10;', 'int size = 0;', 'int hashFunction(int key)', '  return (key % capacity);', 'int checkPrime(int n)', '  int i;', '  if (n == 1 || n == 0)', '  return 0;', '  for (i = 2; i < n / 2; i++)', '  if (n % i == 0)', '    return 0;', '  return 1;', 'int getPrime(int n)', '  if (n % 2 == 0)', '  while (!checkPrime(n))', '  n += 2;', '  return n;', 'void init_array()', '  array[i].key = 0;', '  array[i].data = 0;', 'void insert(int key, int data)', '  if (array[index].data == 0)', '  array[index].key = key;', '  array[index].data = data;', '  size++;', '  array[index].data = data;', 'void remove_element(int key)', '  if (array[index].data == 0)', '  array[index].key = 0;', '  array[index].data = 0;', '  size--;', 'void display()', '  int i;', '  if (array[i].data == 0)', 'int size_of_hashtable()', '  return size;', 'int main()', '  int choice, key, data, n;', '  int c = 0;', '  init_array();', '  scanf(""%d"", &choice);', '  switch (choice)', '  case 1:', '    printf(""Enter key -:\\t"");', '    scanf(""%d"", &key);', '    printf(""Enter data -:\\t"");', '    scanf(""%d"", &data);', '    insert(key, data);', '    break;', '  case 2:', '    scanf(""%d"", &key);', '    remove_element(key);', '    break;', '  case 3:', '    n = size_of_hashtable();', '    break;', '  case 4:', '    display();', '    break;', '  default:', '    printf(""Invalid Input\\n"");', '  scanf(""%d"", &c);', '  } while (c == 1);', '#include <iostream>', '#include <list>', 'using namespace std;', 'class HashTable', '  int capacity;', '  list<int> *table;', '  HashTable(int V);', '  void deleteItem(int key);', '  int checkPrime(int n)', '  int i;', '  if (n == 1 || n == 0)', '    return 0;', '  for (i = 2; i < n / 2; i++)', '    if (n % i == 0)', '    return 0;', '  return 1;', '  int getPrime(int n)', '  if (n % 2 == 0)', '    n++;', '  while (!checkPrime(n))', '    n += 2;', '  return n;', '  int hashFunction(int key)', '  return (key % capacity);', '  void displayHash();', 'HashTable::HashTable(int c)', '  int size = getPrime(c);', '  this->capacity = size;', '  list<int>::iterator i;', '  if (*i == key)', '    break;', '  if (i != table[index].end())', '  table[index].erase(i);', 'void HashTable::displayHash()', '  for (auto x : table[i])', '    cout << "" --> "" << x;', '  cout << endl;', 'int main()', '  HashTable h(size);', '  h.deleteItem(12);', '  h.displayHash();']","['  T[h(x.key)] = x //insert at the head', '# Python program to demonstrate working of HashTable ', '    hashTable[index] = [key, data]', '  public static void main(String args[]) ', '    ht = new Hashtable<Integer, Integer>(); ', '  capacity = getPrime(capacity);', '  array = (struct set *)malloc(capacity * sizeof(struct set));', '  for (int i = 0; i < capacity; i++)', '  int index = hashFunction(key);', '  printf(""\\n Key (%d) has been inserted \\n"", key);', '  else if (array[index].key == key)', '  printf(""\\n Collision occured  \\n"");', '  int index = hashFunction(key);', '  printf(""\\n This key does not exist \\n"");', '  printf(""\\n Key (%d) has been removed \\n"", key);', '  for (i = 0; i < capacity; i++)', '    printf(""\\n array[%d]: / "", i);', '    printf(""\\n key: %d array[%d]: %d \\t"", array[i].key, i, array[i].data);', '  printf(""1.Insert item in the Hash Table""', '     ""\\n2.Remove item from the Hash Table""', '     ""\\n3.Check the size of Hash Table""', '     ""\\n\\n Please enter your choice: "");', '    printf(""Enter the key to delete-:"");', '    printf(""Size of Hash Table is-:%d\\n"", n);', '  printf(""\\nDo you want to continue (press 1 for yes): "");', '  void insertItem(int key, int data);', '  table = new list<int>[capacity];', 'void HashTable::insertItem(int key, int data)', '  int index = hashFunction(key);', 'void HashTable::deleteItem(int key)', '  int index = hashFunction(key);', '  for (i = table[index].begin();', '   i != table[index].end(); i++)', '  for (int i = 0; i < capacity; i++)', '  int key[] = {231, 321, 212, 321, 433, 262};', '  int data[] = {123, 432, 523, 43, 423, 111};', '  int size = sizeof(key) / sizeof(key[0]);', '  for (int i = 0; i < size; i++)', '  h.insertItem(key[i], data[i]);']","['if m = 22, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 01', 'if m = 23, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 001', 'if m = 24, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 0001', 'if m = 2p, then h(k) = p lower bits of m']",[],"[""Key- unique integer that is used for indexing the values|||Value - data that are associated with keys.|||Collision resolution by chaining|||Open Addressing: Linear/Quadratic Probing and Double Hashing|||i = {0, 1, ….}|||h'(k) is a new hash function|||c1 and c2 are positive auxiliary constants,|||i = {0, 1, ….}|||kA mod 1 gives the fractional part kA,|||⌊ ⌋ gives the floor value|||A is any constant. The value of A lies between 0 and 1. But, an optimal choice will be ≈ (√5-1)/2 suggested by Knuth.|||constant time lookup and insertion is required|||cryptographic applications|||indexing data is required|||""]"
16,['Heap Data Structure'],"['In this tutorial, you will learn what heap data structure is. Also, you will find working examples of heap operations in C, C++, Java and Python.']",[],[],"['Heap Operations', 'Python, Java, C/C++ Examples', 'Heap Data Structure Applications']","['Heapify', 'Insert Element into Heap', 'Delete Element from Heap', 'Peek (Find max/min)', 'Extract-Max/Min']","['//cdn.programiz.com/cdn/farfuture/OTLuUbQZmYPjHkXgmCfzHr8nNCkoi2Je9y9ZzIl1vuI/mtime:1582112622/sites/tutorial2program/files/maxheap_1.png', '//cdn.programiz.com/cdn/farfuture/tVzREVaraXbOKPPJtMbcQ10N2QkxiAJcNOIfxPYlVR0/mtime:1582112622/sites/tutorial2program/files/minheap_0.png', '//cdn.programiz.com/cdn/farfuture/u7XieTY7hkqyS4EPPVoQdv_dz8yie8Kt23yrk2T0tI4/mtime:1582112622/sites/tutorial2program/files/array_1.png', '//cdn.programiz.com/cdn/farfuture/lnR3gOMRgb2thamLGxVMsWt91B0Wl7ffnwmoznqFr-U/mtime:1582112622/sites/tutorial2program/files/completebt-1_0.png', '//cdn.programiz.com/cdn/farfuture/Yu605X8Aw6w-sPRAT8jcauJYO14Tz5_INL8804qwrMc/mtime:1582112622/sites/tutorial2program/files/start_1.png', '//cdn.programiz.com/cdn/farfuture/rne2vKIuPdxESHiHCx9QkOJptBH4erly6Rz16BESGcs/mtime:1582112622/sites/tutorial2program/files/swap_1.png', '//cdn.programiz.com/cdn/farfuture/Vh5M3W_PuMk0BtajkiY6aAbAbIq9QXwuIbtKlatIGN8/mtime:1588229923/sites/tutorial2program/files/insert-heap-1.png', '//cdn.programiz.com/cdn/farfuture/J6CSUS2XozRVvpUomcF8wANPpVViFh6X-ARbCdqzB_0/mtime:1588229931/sites/tutorial2program/files/insert-heap-2.png', '//cdn.programiz.com/cdn/farfuture/jWHmWXLJa2YGlGWeEHNukIScbz5rjuzBgEqAq0YrVeg/mtime:1582112622/sites/tutorial2program/files/delete-1_1.png', '//cdn.programiz.com/cdn/farfuture/BvW8pJo3K9yK7dzRmSoA8YVkeDPRCIdBJIEskW2KTL0/mtime:1582112622/sites/tutorial2program/files/delete-2_1.png', '//cdn.programiz.com/cdn/farfuture/SwbN81J6KRUxyFrWIrAHFTe3kd7fUIvcYmH9Sg9SQzo/mtime:1582112622/sites/tutorial2program/files/delete-3_0.png', '//cdn.programiz.com/cdn/farfuture/9o8W0NbKEGKcaxuNb7hqWB16e_Iyw-7Hp8uh08GrHAc/mtime:1582112622/sites/tutorial2program/files/delete-4_0.png']","['This type of data structure is also called a binary heap.', 'Algorithm', 'To create a Max-Heap:', 'Algorithm for insertion in Max Heap', 'Algorithm for deletion in Max Heap', 'For both Max heap and Min Heap']","['Heap data structure is a complete binary tree that satisfies the heap property, where any given node is', 'Some of the important operations performed on a heap are described below along with their algorithms.', 'Heapify is the process of creating a heap data structure from a binary tree. It is used to create a Min-Heap or a Max-Heap.', 'For Min-Heap, both leftChild and rightChild must be larger than the parent for all nodes.', 'For Min Heap, the above algorithm is modified so that parentNode is always smaller than newNode.', 'For Min Heap, above algorithm is modified so that both childNodes are greater smaller than currentNode.', 'Peek operation returns the maximum element from Max Heap or minimum element from Min Heap without deleting the node.']",['Extract-Max returns the node with maximum value after removing it from a Max Heap whereas Extract-Min returns the node with minimum after removing it from Min Heap.'],"['Heapify(array, size, i)', '  set i as largest', '  leftChild = 2i + 1', '  rightChild = 2i + 2', 'MaxHeap(array, size)', '    call heapify', 'If there is no node, ', '  create a newNode.', 'heapify the array', '  remove the node', '  remove noteToBeDeleted', 'heapify the array', 'def heapify(arr, n, i):', '    largest = i', '    l = 2 * i + 1', '    r = 2 * i + 2 ', '        largest = l', '        largest = r', '    if largest != i:', 'def insert(array, newNum):', '    size = len(array)', '    if size == 0:', '        array.append(newNum)', '    else:', '        array.append(newNum);', 'def deleteNode(array, num):', '    size = len(array)', '    i = 0', '    for i in range(0, size):', '        if num == array[i]:', '            break', '        ', '    array.remove(num)', 'arr = []', 'insert(arr, 3)', 'insert(arr, 4)', 'insert(arr, 9)', 'insert(arr, 5)', 'insert(arr, 2)', 'deleteNode(arr, 4)', 'import java.util.ArrayList;', 'class Heap {', '    int size = hT.size();', '    int largest = i;', '    int l = 2 * i + 1;', '    int r = 2 * i + 2;', '      largest = l;', '      largest = r;', '    if (largest != i) {', '      hT.set(i, temp);', '      heapify(hT, largest);', '    int size = hT.size();', '    if (size == 0) {', '      hT.add(newNum);', '    } else {', '      hT.add(newNum);', '        heapify(hT, i);', '    int size = hT.size();', '    int i;', '    for (i = 0; i < size; i++)', '      if (num == hT.get(i))', '        break;', '    int temp = hT.get(i);', '    hT.set(i, hT.get(size-1));', '    hT.set(size-1, temp);', '    hT.remove(size-1);', '      heapify(hT, j);', '    for (Integer i : array) {', '    System.out.println();', '    int size = array.size();', '    Heap h = new Heap();', '    h.insert(array, 3);', '    h.insert(array, 4);', '    h.insert(array, 9);', '    h.insert(array, 5);', '    h.insert(array, 2);', '    h.printArray(array, size);', '    h.deleteNode(array, 4);', '    h.printArray(array, size);', '#include <stdio.h>', 'int size = 0;', 'void swap(int *a, int *b)', '  int temp = *b;', '  *b = *a;', '  *a = temp;', '  if (size == 1)', '    int largest = i;', '    int l = 2 * i + 1;', '    int r = 2 * i + 2;', '      largest = l;', '      largest = r;', '    if (largest != i)', '  if (size == 0)', '    array[0] = newNum;', '    size += 1;', '    array[size] = newNum;', '    size += 1;', '      heapify(array, size, i);', '  int i;', '  for (i = 0; i < size; i++)', '    if (num == array[i])', '      break;', '  size -= 1;', '    heapify(array, size, i);', '    printf(""%d "", array[i]);', '  printf(""\\n"");', 'int main()', '  int array[10];', '  insert(array, 3);', '  insert(array, 4);', '  insert(array, 9);', '  insert(array, 5);', '  insert(array, 2);', '  printf(""Max-Heap array: "");', '  printArray(array, size);', '  deleteRoot(array, 4);', '  printArray(array, size);', '#include <iostream>', '#include <vector>', 'using namespace std;', 'void swap(int *a, int *b)', '  int temp = *b;', '  *b = *a;', '  *a = temp;', '  int size = hT.size();', '  int largest = i;', '  int l = 2 * i + 1;', '  int r = 2 * i + 2;', '    largest = l;', '    largest = r;', '  if (largest != i)', '    heapify(hT, largest);', '  int size = hT.size();', '  if (size == 0)', '    hT.push_back(newNum);', '    hT.push_back(newNum);', '      heapify(hT, i);', '  int size = hT.size();', '  int i;', '  for (i = 0; i < size; i++)', '    if (num == hT[i])', '      break;', '  swap(&hT[i], &hT[size - 1]);', '  hT.pop_back();', '    heapify(hT, i);', '    cout << hT[i] << "" "";', '  cout << ""\\n"";', 'int main()', '  vector<int> heapTree;', '  insert(heapTree, 3);', '  insert(heapTree, 4);', '  insert(heapTree, 9);', '  insert(heapTree, 5);', '  insert(heapTree, 2);', '  cout << ""Max-Heap array: "";', '  printArray(heapTree);', '  deleteNode(heapTree, 4);', '  printArray(heapTree);']","['    set leftChildIndex as largest', '  if rightChild > array[largest]', '    set rightChildIndex as largest', '  swap array[i] and array[largest]', '  loop from the first index of non-leaf node down to zero', 'else (a node is already present)', '  insert the newNode at the end (last node from left to right.)', 'If nodeToBeDeleted is the leafNode', 'Else swap nodeToBeDeleted with the lastLeafNode', '# Max-Heap data structure in Python', '    if l < n and arr[i] < arr[l]:', '    if r < n and arr[largest] < arr[r]:', '        arr[i],arr[largest] = arr[largest],arr[i]', '        heapify(arr, n, largest)', '        for i in range((size//2)-1, -1, -1):', '            heapify(array, size, i)', '    array[i], array[size-1] = array[size-1], array[i]', '    for i in range((len(array)//2)-1, -1, -1):', '        heapify(array, len(array), i)', 'print (""Max-Heap array: "" + str(arr))', 'print(""After deleting an element: "" + str(arr))', '  void heapify(ArrayList<Integer> hT, int i) {', '    if (l < size && hT.get(l) > hT.get(largest))', '    if (r < size && hT.get(r) > hT.get(largest))', '      int temp = hT.get(largest);', '      hT.set(largest, hT.get(i));', '  void insert(ArrayList<Integer> hT, int newNum) {', '      for (int i = size / 2 - 1; i >= 0; i--) {', '  void deleteNode(ArrayList<Integer> hT, int num)', '    for (int j = size / 2 - 1; j >= 0; j--)', '  void printArray(ArrayList<Integer> array, int size) {', '      System.out.print(i + "" "");', '  public static void main(String args[]) {', '    ArrayList<Integer> array = new ArrayList<Integer>();', '    System.out.println(""Max-Heap array: "");', '    System.out.println(""After deleting an element: "");', 'void heapify(int array[], int size, int i)', '    printf(""Single element in the heap"");', '    if (l < size && array[l] > array[largest])', '    if (r < size && array[r] > array[largest])', '      swap(&array[i], &array[largest]);', '      heapify(array, size, largest);', 'void insert(int array[], int newNum)', '    for (int i = size / 2 - 1; i >= 0; i--)', 'void deleteRoot(int array[], int num)', '  swap(&array[i], &array[size - 1]);', '  for (int i = size / 2 - 1; i >= 0; i--)', 'void printArray(int array[], int size)', '  for (int i = 0; i < size; ++i)', '  printf(""After deleting an element: "");', 'void heapify(vector<int> &hT, int i)', '  if (l < size && hT[l] > hT[largest])', '  if (r < size && hT[r] > hT[largest])', 'void insert(vector<int> &hT, int newNum)', '    for (int i = size / 2 - 1; i >= 0; i--)', 'void deleteNode(vector<int> &hT, int num)', '  for (int i = size / 2 - 1; i >= 0; i--)', 'void printArray(vector<int> &hT)', '  for (int i = 0; i < hT.size(); ++i)', '  cout << ""After deleting an element: "";']",['return rootNode'],[],"[""always greater than its child node/s and the key of the root node is the largest among all other nodes. This property is also called max heap property.|||always smaller than the child node/s and the key of the root node is the smallest among all other nodes. This property is also called min heap property.|||Heap is used while implementing a priority queue.|||Dijkstra's Algorithm|||Heap Sort|||&&&Let the input array be|||Initial Array|||Create a complete binary tree from the array|||Complete binary tree|||Start from the first index of non-leaf node whose index is given by n/2 - 1.|||Start from the first on leaf node|||Set current element i as largest.|||The index of left child is given by 2i + 1 and the right child is given by 2i + 2.|||If leftChild is greater than currentElement (i.e. element at ith index), set leftChildIndex as largest.|||If rightChild is greater than element in largest, set rightChildIndex as largest.|||Swap largest with currentElement|||Swap if necessary|||Repeat steps 3-7 until the subtrees are also heapified.|||Insert the new element at the end of the tree.|||Insert at the end|||Heapify the tree.|||Select the element to be deleted.|||Select the element to be deleted|||Swap it with the last element.|||Swap with the last element|||Remove the last element.|||Remove the last element|||Heapify the tree.|||""]"
17,['Fibonacci Heap'],"['In this tutorial, you will learn what a Fibonacci Heap is. Also, you will find working examples of different operations on a fibonacci heap in C, C++, Java and Python.']",[],[],"['Properties of a Fibonacci Heap', 'Memory Representation of the Nodes in a Fibonacci Heap', 'Operations on a Fibonacci Heap', 'Python, Java and C/C++ Examples', 'Complexities', 'Fibonacci Heap Applications']","['Insertion', 'Find Min', 'Union', 'Extract Min', 'Decreasing a Key and Deleting a Node']","['//cdn.programiz.com/cdn/farfuture/WgeXgB_o4_0qX5Iv2msbC1zcYn1s3Ay7ypgfac4CmMo/mtime:1585306008/sites/tutorial2program/files/fibonacci-heap.png', '//cdn.programiz.com/cdn/farfuture/VsG7KIKpPe37TYtVHP2XoeYpbBwXlOEvSK7QYGNSyAo/mtime:1585306002/sites/tutorial2program/files/fibonacci-heap-structure.png', '//cdn.programiz.com/cdn/farfuture/aYijB7xrcsgmIVH0qBUdbn-oy0XXtJ5yPK1J-O7rf6Q/mtime:1585306019/sites/tutorial2program/files/insert-f-heap.png', '//cdn.programiz.com/cdn/farfuture/worMUdR6_B3fEdOmZ8ckbA4IZNeZg7fKleKS5PB-XBU/mtime:1585306028/sites/tutorial2program/files/union-f-heap.png', '//cdn.programiz.com/cdn/farfuture/r9mLx5gD02zRbz3OUq1SOm9estBgaMWXHwRIlvjnqhI/mtime:1585305500/sites/tutorial2program/files/extract-min-1.png', '//cdn.programiz.com/cdn/farfuture/A5sQ9UEBNtTVYG1_KgNYG1sSDNB44XjZe-0yvv_ZOpo/mtime:1585305504/sites/tutorial2program/files/extract-min-2.png', '//cdn.programiz.com/cdn/farfuture/kU5sT7zkX-nbPWwEJUoUu8x2oD2xKo2XNtR99c7TC9M/mtime:1585305944/sites/tutorial2program/files/extract-min-5.png', '//cdn.programiz.com/cdn/farfuture/uH0Y64erp8vLNZdJkuosIjVpw-KkEhZnqxKWJYn1bew/mtime:1585305950/sites/tutorial2program/files/extract-min-6.png', '//cdn.programiz.com/cdn/farfuture/nXesnCYZ1W8B2dq0GHi_zsXSX1iw0u6TbK4oDGhWVOU/mtime:1585305955/sites/tutorial2program/files/extract-min-7.png', '//cdn.programiz.com/cdn/farfuture/Z7RBL8FgyZyliYjnvScKfF6OdZ7QKbbRQU4Kvqx1h44/mtime:1585305961/sites/tutorial2program/files/extract-min-8.png', '//cdn.programiz.com/cdn/farfuture/FboNK7RijooSfgCLR6d3TAPvYGpEnItiiYkh9WkJoGs/mtime:1585305973/sites/tutorial2program/files/extract-min-10.png', '//cdn.programiz.com/cdn/farfuture/p6t_aiRpMDRdjTBFPN0tdCBakXos-j5fGROW9iBlxJU/mtime:1585305978/sites/tutorial2program/files/extract-min-11.png', '//cdn.programiz.com/cdn/farfuture/pCvMghKvClGn1wcB0E3jw7otHGuQHfoVx7R4RuCH90Q/mtime:1585305984/sites/tutorial2program/files/extract-min-12.png', '//cdn.programiz.com/cdn/farfuture/rWXaWMYqW6L5cHezsNLL5zoX37rDgoP_ZseDVpyv3Q8/mtime:1585305996/sites/tutorial2program/files/extract-min-13.png', '//cdn.programiz.com/cdn/farfuture/hOC9kc_wxJtv7PKX0L_qMjVU06Z9AlCI4-5dCcaUClE/mtime:1585305990/sites/tutorial2program/files/extract-min-13-1.png']","['Important properties of a Fibonacci heap are:', 'Algorithm', 'The minimum element is always given by the min pointer.', 'Union of two fibonacci heaps consists of following steps.', 'The following steps are followed:']","['There are two main advantages of using a circular doubly linked list.', 'Inserting a node into an already existing heap follows the steps below.', 'An implementation of the above steps can be understood in the example below.', 'These are the most important operations which are discussed in Decrease Key and Delete Node Operations.']","['A fibonacci heap is a data structure that consists of a collection of trees which follow min heap or max heap property. We have already discussed min heap and max heap property in the Heap Data Structure article. These two properties are the characteristics of the trees present on a fibonacci heap.', 'In a fibonacci heap, a node can have more than two children or no children at all. Also, it has more efficient heap operations than that supported by the binomial and binary heaps.', 'The fibonacci heap is called a fibonacci heap because the trees are constructed in a way such that a tree of order n has at least Fn+2 nodes in it, where Fn+2 is the (n + 2)th Fibonacci number.', 'The roots of all the trees are linked together for faster access. The child nodes of a parent node are connected to each other through a circular doubly linked list as shown below.', 'It is the most important operation on a fibonacci heap. In this operation, the node with minimum value is removed from the heap and the tree is re-adjusted.']","['# Fibonacci Heap in python', 'import math', '# Creating fibonacci tree', 'class FibonacciTree:', '    def __init__(self, value):', '        self.value = value', '        self.child = []', '        self.order = 0', '    def add_at_end(self, t):', '        self.child.append(t)', '# Creating Fibonacci heap', 'class FibonacciHeap:', '    def __init__(self):', '        self.trees = []', '        self.least = None', '        self.count = 0', '    # Insert a node', '    # Get minimum value', '    def get_min(self):', '        if self.least is None:', '            return None', '    def extract_min(self):', '        smallest = self.least', '            else:', '    # Consolidate the tree', '    def consolidate(self):', '            x = self.trees[0]', '            order = x.order', '                y = aux[order]', '            aux[order] = x', '        self.least = None', '        for k in aux:', '            if k is not None:', 'def floor_log(x):', 'fibonacci_heap.insert_node(7)', 'fibonacci_heap.insert_node(3)', 'fibonacci_heap.insert_node(17)', 'fibonacci_heap.insert_node(24)', 'class node {', '  node parent;', '  node left;', '  node right;', '  node child;', '  int degree;', '  boolean mark;', '  int key;', '  public node() {', '    this.degree = 0;', '    this.mark = false;', '    this.parent = null;', '    this.left = this;', '    this.right = this;', '    this.child = null;', '  node(int x) {', '    this();', '    this.key = x;', '  void set_parent(node x) {', '    this.parent = x;', '  node get_parent() {', '    return this.parent;', '  void set_left(node x) {', '    this.left = x;', '  node get_left() {', '    return this.left;', '  void set_right(node x) {', '    this.right = x;', '  node get_right() {', '    return this.right;', '  void set_child(node x) {', '    this.child = x;', '  node get_child() {', '    return this.child;', '  void set_degree(int x) {', '    this.degree = x;', '  int get_degree() {', '    return this.degree;', '  void set_mark(boolean m) {', '    this.mark = m;', '  boolean get_mark() {', '    return this.mark;', '  void set_key(int x) {', '    this.key = x;', '  int get_key() {', '    return this.key;', 'public class fibHeap {', '  node min;', '  int n;', '  boolean trace;', '  node found;', '  public boolean get_trace() {', '    return trace;', '    this.trace = t;', '    return new fibHeap();', '  fibHeap() {', '    min = null;', '    n = 0;', '    trace = false;', '    if (min == null) {', '      min = x;', '      x.set_left(min);', '      x.set_right(min);', '    } else {', '      x.set_right(min);', '      min.set_left(x);', '        min = x;', '    n += 1;', '    insert(new node(key));', '  public void display() {', '    display(min);', '    System.out.println();', '    System.out.print(""("");', '    if (c == null) {', '      System.out.print("")"");', '      return;', '    } else {', '      node temp = c;', '      do {', '        display(k);', '      } while (temp != c);', '      System.out.print("")"");', '    H3.min = H1.min;', '      H1.min.set_left(t2);', '      t1.set_right(H2.min);', '      H2.min.set_left(t1);', '      t2.set_right(H1.min);', '      H3.min = H2.min;', '    H3.n = H1.n + H2.n;', '  public int find_min() {', '    return this.min.get_key();', '  public int extract_min() {', '    node z = this.min;', '    if (z != null) {', '      node c = z.get_child();', '      node k = c, p;', '      if (c != null) {', '        do {', '          p = c.get_right();', '          insert(c);', '          c.set_parent(null);', '          c = p;', '      z.set_child(null);', '      if (z == z.get_right())', '        this.min = null;', '      else {', '        this.consolidate();', '      this.n -= 1;', '      return z.get_key();', '    return Integer.MAX_VALUE;', '  public void consolidate() {', '      A[i] = null;', '    node w = min;', '    if (w != null) {', '      node check = min;', '      do {', '        node x = w;', '        while (A[d] != null) {', '          node y = A[d];', '            node temp = x;', '            x = y;', '            y = temp;', '            w = x;', '          }', '          fib_heap_link(y, x);', '          check = x;', '          A[d] = null;', '          d += 1;', '        }', '        A[d] = x;', '        w = w.get_right();', '      this.min = null;', '        if (A[i] != null) {', '          insert(A[i]);', '        }', '    node p = x.get_child();', '    if (p == null) {', '      y.set_right(y);', '      y.set_left(y);', '    } else {', '      y.set_right(p);', '      p.set_left(y);', '    y.set_parent(x);', '    x.set_child(y);', '    y.set_mark(false);', '      return;', '    else {', '      node temp = c;', '      do {', '          found = temp;', '        else {', '          find(key, k);', '        }', '  public node find(int k) {', '    found = null;', '    find(k, this.min);', '    return found;', '    node x = find(key);', '    decrease_key(x, nval);', '    if (k > x.get_key())', '      return;', '    x.set_key(k);', '    node y = x.get_parent();', '      cut(x, y);', '      cascading_cut(y);', '      min = x;', '    x.set_right(null);', '    x.set_left(null);', '    insert(x);', '    x.set_parent(null);', '    x.set_mark(false);', '    node z = y.get_parent();', '    if (z != null) {', '        y.set_mark(true);', '      else {', '        cut(y, z);', '        cascading_cut(z);', '  public void delete(node x) {', '    int p = extract_min();', '    obj.insert(7);', '    obj.insert(26);', '    obj.insert(30);', '    obj.insert(39);', '    obj.insert(10);', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '#include <math.h>', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', 'typedef struct _NODE {', '  int key;', '  int degree;', '  struct _NODE *left_sibling;', '  struct _NODE *right_sibling;', '  struct _NODE *parent;', '  struct _NODE *child;', '  bool mark;', '  bool visited;', '  int n;', '  NODE *min;', '  int phi;', '  int degree;', '} FIB_HEAP;', 'FIB_HEAP *make_fib_heap();', 'void consolidate(FIB_HEAP *H);', 'FIB_HEAP *make_fib_heap() {', '  FIB_HEAP *H;', '  H->n = 0;', '  H->min = NULL;', '  H->phi = 0;', '  H->degree = 0;', '  return H;', 'void print_heap(NODE *n) {', '  NODE *x;', '    if (x->child == NULL) {', '    } else {', '      print_heap(x->child);', '      break;', '  new->key = val;', '  new->degree = 0;', '  new->mark = false;', '  new->parent = NULL;', '  new->child = NULL;', '  new->visited = false;', '  new->left_sibling = new;', '  new->right_sibling = new;', '  if (H->min == NULL) {', '    H->min = new;', '  } else {', '      H->min = new;', '  (H->n)++;', '  if (H == NULL) {', '    return NULL;', '  } else', '    return H->min;', '  FIB_HEAP *Hnew;', '  Hnew = make_fib_heap();', '  Hnew->min = H1->min;', '  NODE *temp1, *temp2;', '    Hnew->min = H2->min;', '  Hnew->n = H1->n + H2->n;', '  return Hnew;', 'int cal_degree(int n) {', '  int count = 0;', '  while (n > 0) {', '    n = n / 2;', '    count++;', '  return count;', '  int degree, i, d;', '  degree = cal_degree(H->n);', '  NODE *A[degree], *x, *y, *z;', '    A[i] = NULL;', '  x = H->min;', '    d = x->degree;', '    while (A[d] != NULL) {', '      y = A[d];', '      if (x->key > y->key) {', '        NODE *exchange_help;', '        exchange_help = x;', '        x = y;', '        y = exchange_help;', '      if (y == H->min)', '        H->min = x;', '      fib_heap_link(H, y, x);', '        H->min = x;', '      A[d] = NULL;', '      d++;', '    A[d] = x;', '    x = x->right_sibling;', '  } while (x != H->min);', '  H->min = NULL;', '    if (A[i] != NULL) {', '      if (H->min == NULL) {', '        H->min = A[i];', '      } else {', '          H->min = A[i];', '        }', '      if (H->min == NULL) {', '        H->min = A[i];', '        H->min = A[i];', '  if (x->right_sibling == x)', '    H->min = x;', '  y->left_sibling = y;', '  y->right_sibling = y;', '  y->parent = x;', '  if (x->child == NULL) {', '    x->child = y;', '  y->right_sibling = x->child;', '  x->child->left_sibling = y;', '    x->child = y;', '  (x->degree)++;', '  if (H->min == NULL)', '  else {', '    NODE *temp = H->min;', '    NODE *pntr;', '    pntr = temp;', '    NODE *x = NULL;', '    if (temp->child != NULL) {', '      x = temp->child;', '      do {', '          H->min = x;', '        x->parent = NULL;', '        x = pntr;', '      H->min = NULL;', '    else {', '      consolidate(H);', '    H->n = H->n - 1;', '    return temp;', '  return H->min;', '  NODE *temp_parent_check;', '    parent_node->child = NULL;', '  (parent_node->degree)--;', '  NODE *aux;', '  aux = parent_node->parent;', '  if (aux != NULL) {', '    } else {', '      cascading_cut(H, aux);', '  NODE *parent_node;', '  if (H == NULL) {', '    return;', '  else {', '    } else {', '  NODE *find_use = n;', '  NODE *f = NULL;', '  find_use->visited = true;', '  if (find_use->key == key) {', '    find_use->visited = false;', '    f = find_use;', '  find_use->visited = false;', '  FIB_HEAP *temp;', '  int no_of_nodes, ele, i;', '  NODE *new_node;', '  temp = NULL;', '  if (temp == NULL) {', '    temp = make_fib_heap();', '  scanf(""%d"", &no_of_nodes);', '    scanf(""%d"", &ele);', '  return temp;', '  NODE *p = NULL;', '  p = extract_min(H);', '  if (p != NULL)', '    printf(""\\n Node deleted"");', '  FIB_HEAP *heap, *h1, *h2;', '  heap = NULL;', '  while (1) {', '    switch (operation_no) {', '      case 1:', '        break;', '      case 2:', '        if (heap == NULL) {', '        }', '          scanf(""%d"", &ele);', '        }', '        break;', '      case 3:', '        if (min_node == NULL)', '        else', '        break;', '      case 4:', '        if (heap == NULL) {', '          break;', '        }', '        print_heap(heap->min);', '        break;', '      case 5:', '        if (heap == NULL)', '        else {', '        }', '        break;', '      case 6:', '        if (heap == NULL)', '        else {', '        }', '        break;', '      case 7:', '        if (heap == NULL)', '        else {', '          break;', '        }', '      case 8:', '        print_heap(heap->min);', '        break;', '      case 9:', '        free(new_node);', '        free(heap);', '        exit(0);', '      default:', '#include <cmath>', '#include <cstdlib>', '#include <iostream>', 'using namespace std;', 'struct node {', '  int n;', '  int degree;', '  node *parent;', '  node *child;', '  node *left;', '  node *right;', '  char mark;', '  char C;', 'class FibonacciHeap {', '   private:', '  int nH;', '  node *H;', '   public:', '  node *InitializeHeap();', '  node *Create_node(int);', '  node *Union(node *, node *);', '  node *Extract_Min(node *);', '  int Consolidate(node *);', '  int Display(node *);', '  node *Find(node *, int);', '  int Delete_key(node *, int);', '  node *np;', '  np = NULL;', '  return np;', '  node *x = new node;', '  x->n = value;', '  return x;', '  x->degree = 0;', '  x->parent = NULL;', '  x->child = NULL;', '  x->left = x;', '  x->right = x;', ""  x->mark = 'F';"", ""  x->C = 'N';"", '  if (H != NULL) {', '    (H->left)->right = x;', '    x->right = H;', '    x->left = H->left;', '    H->left = x;', '    if (x->n < H->n)', '      H = x;', '  } else {', '    H = x;', '  nH = nH + 1;', '  return H;', '  (y->left)->right = y->right;', '  (y->right)->left = y->left;', '  if (z->right == z)', '    H1 = z;', '  y->left = y;', '  y->right = y;', '  y->parent = z;', '  if (z->child == NULL)', '    z->child = y;', '  y->right = z->child;', '  y->left = (z->child)->left;', '  (z->child)->left = y;', '  if (y->n < (z->child)->n)', '    z->child = y;', '  z->degree++;', '  node *np;', '  node *H = InitializeHeap();', '  H = H1;', '  (H->left)->right = H2;', '  (H2->left)->right = H;', '  np = H->left;', '  H->left = H2->left;', '  H2->left = np;', '  return H;', '  node *p = H;', '  if (p == NULL) {', '    return 0;', '    cout << p->n;', '    p = p->right;', '    if (p != H) {', '      cout << ""-->"";', '  cout << endl;', '  node *p;', '  node *ptr;', '  node *z = H1;', '  p = z;', '  ptr = z;', '  if (z == NULL)', '    return z;', '  node *x;', '  node *np;', '  x = NULL;', '  if (z->child != NULL)', '    x = z->child;', '  if (x != NULL) {', '    ptr = x;', '    do {', '      np = x->right;', '      (H1->left)->right = x;', '      x->right = H1;', '      x->left = H1->left;', '      H1->left = x;', '      if (x->n < H1->n)', '        H1 = x;', '      x->parent = NULL;', '      x = np;', '    } while (np != ptr);', '  (z->left)->right = z->right;', '  (z->right)->left = z->left;', '  H1 = z->right;', '    H = NULL;', '  else {', '    H1 = z->right;', '    Consolidate(H1);', '  nH = nH - 1;', '  return p;', '  int d, i;', '  int D = f;', '  node *A[D];', '  for (i = 0; i <= D; i++)', '    A[i] = NULL;', '  node *x = H1;', '  node *y;', '  node *np;', '  node *pt = x;', '    pt = pt->right;', '    d = x->degree;', '    while (A[d] != NULL)', '      y = A[d];', '      if (x->n > y->n)', '        np = x;', '        x = y;', '        y = np;', '      if (y == H1)', '        H1 = x;', '      if (x->right == x)', '        H1 = x;', '      A[d] = NULL;', '      d = d + 1;', '    A[d] = x;', '    x = x->right;', '  while (x != H1);', '  H = NULL;', '    if (A[j] != NULL) {', '      A[j]->left = A[j];', '      A[j]->right = A[j];', '      if (H != NULL) {', '        A[j]->right = H;', '        A[j]->left = H->left;', '        H->left = A[j];', '        if (A[j]->n < H->n)', '          H = A[j];', '      } else {', '        H = A[j];', '      if (H == NULL)', '        H = A[j];', '      else if (A[j]->n < H->n)', '        H = A[j];', '  node *y;', '  if (H1 == NULL) {', '    return 0;', '  node *ptr = Find(H1, x);', '  if (ptr == NULL) {', '    return 1;', '  if (ptr->n < k) {', '    return 0;', '  ptr->n = k;', '  y = ptr->parent;', '    Cut(H1, ptr, y);', '    Cascase_cut(H1, y);', '  if (ptr->n < H->n)', '    H = ptr;', '  return 0;', '  if (x == x->right)', '    y->child = NULL;', '  (x->left)->right = x->right;', '  (x->right)->left = x->left;', '  if (x == y->child)', '    y->child = x->right;', '  y->degree = y->degree - 1;', '  x->right = x;', '  x->left = x;', '  (H1->left)->right = x;', '  x->right = H1;', '  x->left = H1->left;', '  H1->left = x;', '  x->parent = NULL;', ""  x->mark = 'F';"", '  node *z = y->parent;', '  if (z != NULL) {', ""    if (y->mark == 'F') {"", ""      y->mark = 'T';"", '    } else', '      Cut(H1, y, z);', '      Cascase_cut(H1, z);', '  node *x = H;', ""  x->C = 'Y';"", '  node *p = NULL;', '  if (x->n == k) {', '    p = x;', ""    x->C = 'N';"", '    return p;', '  if (p == NULL) {', '    if (x->child != NULL)', '      p = Find(x->child, k);', ""    if ((x->right)->C != 'Y')"", '      p = Find(x->right, k);', ""  x->C = 'N';"", '  return p;', '  node *np = NULL;', '  int t;', '  if (!t)', '    np = Extract_Min(H);', '  if (np != NULL)', '  return 0;', 'int main() {', '  int n, m, l;', '  FibonacciHeap fh;', '  node *p;', '  node *H;', '  H = fh.InitializeHeap();', '  p = fh.Create_node(7);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(3);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(17);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(24);', '  H = fh.Insert(H, p);', '  fh.Display(H);', '  p = fh.Extract_Min(H);', '  if (p != NULL)', '  m = 26;', '  l = 16;', '  fh.Decrease_key(H, m, l);', '  m = 16;', '  fh.Delete_key(H, m);']","['    # Adding tree at the end of the tree', '        self.order = self.order + 1', '    def insert_node(self, value):', '        new_tree = FibonacciTree(value)', '        self.trees.append(new_tree)', '        if (self.least is None or value < self.least.value):', '            self.least = new_tree', '        self.count = self.count + 1', '        if smallest is not None:', '            for child in smallest.child:', '                self.trees.append(child)', '            self.trees.remove(smallest)', '            if self.trees == []:', '                self.least = None', '                self.least = self.trees[0]', '                self.consolidate()', '            self.count = self.count - 1', '            return smallest.value', '        aux = (floor_log(self.count) + 1) * [None]', '            self.trees.remove(x)', '            while aux[order] is not None:', '                if x.value > y.value:', '                aux[order] = None', '                order = order + 1', '                self.trees.append(k)', '                if (self.least is None', '                        or k.value < self.least.value):', '                    self.least = k', 'fibonacci_heap = FibonacciHeap()', ""print('the minimum value of the fibonacci heap: {}'.format(fibonacci_heap.get_min()))"", ""print('the minimum value removed: {}'.format(fibonacci_heap.extract_min()))"", '    this.key = Integer.MAX_VALUE;', '  public void set_trace(boolean t) {', '  public static fibHeap create_heap() {', '      x.set_left(min.get_left());', '      min.get_left().set_right(x);', '      if (x.get_key() < min.get_key())', '  private void display(node c) {', '        System.out.print(temp.get_key());', '        node k = temp.get_child();', '        temp = temp.get_right();', '  public static void merge_heap(fibHeap H1, fibHeap H2, fibHeap H3) {', '    if (H1.min != null && H2.min != null) {', '      node t1 = H1.min.get_left();', '      node t2 = H2.min.get_left();', '    if (H1.min == null || (H2.min != null && H2.min.get_key() < H1.min.get_key()))', '  private void display_node(node z) {', '    System.out.println(""right: "" + ((z.get_right() == null) ? ""-1"" : z.get_right().get_key()));', '    System.out.println(""left: "" + ((z.get_left() == null) ? ""-1"" : z.get_left().get_key()));', '    System.out.println(""child: "" + ((z.get_child() == null) ? ""-1"" : z.get_child().get_key()));', '    System.out.println(""degree "" + z.get_degree());', '        } while (c != null && c != k);', '      z.get_left().set_right(z.get_right());', '      z.get_right().set_left(z.get_left());', '        this.min = z.get_right();', '    double phi = (1 + Math.sqrt(5)) / 2;', '    int Dofn = (int) (Math.log(this.n) / Math.log(phi));', '    node[] A = new node[Dofn + 1];', '    for (int i = 0; i <= Dofn; ++i)', '          if (x.get_key() > y.get_key()) {', '      } while (w != null && w != check);', '      for (int i = 0; i <= Dofn; ++i) {', '  private void fib_heap_link(node y, node x) {', '    y.get_left().set_right(y.get_right());', '    y.get_right().set_left(y.get_left());', '      p.get_left().set_right(y);', '    x.set_degree(x.get_degree() + 1);', '  private void find(int key, node c) {', '    if (found != null || c == null)', '        if (key == temp.get_key())', '          node k = temp.get_child();', '          temp = temp.get_right();', '      } while (temp != c && found == null);', '  public void decrease_key(int key, int nval) {', '  private void decrease_key(node x, int k) {', '    if (y != null && x.get_key() < y.get_key()) {', '    if (x.get_key() < min.get_key())', '  private void cut(node x, node y) {', '    x.get_right().set_left(x.get_left());', '    x.get_left().set_right(x.get_right());', '    y.set_degree(y.get_degree() - 1);', '  private void cascading_cut(node y) {', '      if (y.get_mark() == false)', '    decrease_key(x, Integer.MIN_VALUE);', '  public static void main(String[] args) {', '    fibHeap obj = create_heap();', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', 'void insertion(FIB_HEAP *H, NODE *new, int val);', 'void fib_heap_link(FIB_HEAP *H, NODE *y, NODE *x);', 'NODE *find_min_node(FIB_HEAP *H);', 'void decrease_key(FIB_HEAP *H, NODE *node, int key);', 'void cut(FIB_HEAP *H, NODE *node_to_be_decrease, NODE *parent_node);', 'void cascading_cut(FIB_HEAP *H, NODE *parent_node);', 'void Delete_Node(FIB_HEAP *H, int dec_key);', '  H = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '  for (x = n;; x = x->right_sibling) {', '      printf(""node with no child (%d) \\n"", x->key);', '      printf(""NODE(%d) with child (%d)\\n"", x->key, x->child->key);', '    if (x->right_sibling == n) {', 'void insertion(FIB_HEAP *H, NODE *new, int val) {', '  new = (NODE *)malloc(sizeof(NODE));', '    H->min->left_sibling->right_sibling = new;', '    new->right_sibling = H->min;', '    new->left_sibling = H->min->left_sibling;', '    if (new->key < H->min->key) {', 'NODE *find_min_node(FIB_HEAP *H) {', '    printf("" \\n Fibonacci heap not yet created \\n"");', 'FIB_HEAP *unionHeap(FIB_HEAP *H1, FIB_HEAP *H2) {', '  temp1 = Hnew->min->right_sibling;', '  temp2 = H2->min->left_sibling;', '  Hnew->min->right_sibling->left_sibling = H2->min->left_sibling;', '  Hnew->min->right_sibling = H2->min;', '  H2->min->left_sibling = Hnew->min;', '  if ((H1->min == NULL) || (H2->min != NULL && H2->min->key < H1->min->key))', '  for (i = 0; i <= degree; i++) {', '      if (y->right_sibling == x)', '  for (i = 0; i < degree; i++) {', '      A[i]->left_sibling = A[i];', '      A[i]->right_sibling = A[i];', '        H->min->left_sibling->right_sibling = A[i];', '        A[i]->right_sibling = H->min;', '        A[i]->left_sibling = H->min->left_sibling;', '        H->min->left_sibling = A[i];', '        if (A[i]->key < H->min->key) {', '      } else if (A[i]->key < H->min->key) {', 'void fib_heap_link(FIB_HEAP *H, NODE *y, NODE *x) {', '  y->right_sibling->left_sibling = y->left_sibling;', '  y->left_sibling->right_sibling = y->right_sibling;', '  y->left_sibling = x->child->left_sibling;', '  x->child->left_sibling->right_sibling = y;', '  if ((y->key) < (x->child->key))', 'NODE *extract_min(FIB_HEAP *H) {', '    printf(""\\n The heap is empty"");', '        pntr = x->right_sibling;', '        (H->min->left_sibling)->right_sibling = x;', '        x->right_sibling = H->min;', '        x->left_sibling = H->min->left_sibling;', '        H->min->left_sibling = x;', '        if (x->key < H->min->key)', '      } while (pntr != temp->child);', '    (temp->left_sibling)->right_sibling = temp->right_sibling;', '    (temp->right_sibling)->left_sibling = temp->left_sibling;', '    H->min = temp->right_sibling;', '    if (temp == temp->right_sibling && temp->child == NULL)', '      H->min = temp->right_sibling;', 'void cut(FIB_HEAP *H, NODE *node_to_be_decrease, NODE *parent_node) {', '  if (node_to_be_decrease == node_to_be_decrease->right_sibling)', '  node_to_be_decrease->left_sibling->right_sibling = node_to_be_decrease->right_sibling;', '  node_to_be_decrease->right_sibling->left_sibling = node_to_be_decrease->left_sibling;', '  if (node_to_be_decrease == parent_node->child)', '    parent_node->child = node_to_be_decrease->right_sibling;', '  node_to_be_decrease->left_sibling = node_to_be_decrease;', '  node_to_be_decrease->right_sibling = node_to_be_decrease;', '  H->min->left_sibling->right_sibling = node_to_be_decrease;', '  node_to_be_decrease->right_sibling = H->min;', '  node_to_be_decrease->left_sibling = H->min->left_sibling;', '  H->min->left_sibling = node_to_be_decrease;', '  node_to_be_decrease->parent = NULL;', '  node_to_be_decrease->mark = false;', 'void cascading_cut(FIB_HEAP *H, NODE *parent_node) {', '    if (parent_node->mark == false) {', 'void decrease_key(FIB_HEAP *H, NODE *node_to_be_decrease, int new_key) {', '    printf(""\\n FIbonacci heap not created "");', '  if (node_to_be_decrease == NULL) {', '    printf(""Node is not in the heap"");', '    if (node_to_be_decrease->key < new_key) {', '      printf(""\\n Invalid new key for decrease key operation \\n "");', '      node_to_be_decrease->key = new_key;', '      parent_node = node_to_be_decrease->parent;', '      if ((parent_node != NULL) && (node_to_be_decrease->key < parent_node->key)) {', '        printf(""\\n cut called"");', '        cut(H, node_to_be_decrease, parent_node);', '        printf(""\\n cascading cut called"");', '        cascading_cut(H, parent_node);', '      if (node_to_be_decrease->key < H->min->key) {', '        H->min = node_to_be_decrease;', 'void *find_node(FIB_HEAP *H, NODE *n, int key, int new_key) {', '    decrease_key(H, f, new_key);', '  if (find_use->child != NULL) {', '    find_node(H, find_use->child, key, new_key);', '  if ((find_use->right_sibling->visited != true)) {', '    find_node(H, find_use->right_sibling, key, new_key);', 'FIB_HEAP *insertion_procedure() {', '  temp = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '  printf("" \\n enter number of nodes to be insert = "");', '  for (i = 1; i <= no_of_nodes; i++) {', '    printf(""\\n node %d and its key value = "", i);', '    insertion(temp, new_node, ele);', 'void Delete_Node(FIB_HEAP *H, int dec_key) {', '  find_node(H, H->min, dec_key, -5000);', '    printf(""\\n Node not deleted:some error"");', 'int main(int argc, char **argv) {', '  NODE *new_node, *min_node, *extracted_min, *node_to_be_decrease, *find_use;', '  int operation_no, new_key, dec_key, ele, i, no_of_nodes;', '  heap = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '    printf("" \\n Operations \\n 1. Create Fibonacci heap \\n 2. Insert nodes into fibonacci heap \\n 3. Find min \\n 4. Union \\n 5. Extract min \\n 6. Decrease key \\n 7.Delete node \\n 8. print heap \\n 9. exit \\n enter operation_no = "");', '          heap = make_fib_heap();', '        printf("" enter number of nodes to be insert = "");', '        scanf(""%d"", &no_of_nodes);', '        for (i = 1; i <= no_of_nodes; i++) {', '          printf(""\\n node %d and its key value = "", i);', '          insertion(heap, new_node, ele);', '        min_node = find_min_node(heap);', '          printf(""No minimum value"");', '          printf(""\\n min value = %d"", min_node->key);', '          printf(""\\n no FIbonacci heap created \\n "");', '        h1 = insertion_procedure();', '        heap = unionHeap(heap, h1);', '        printf(""Unified Heap:\\n"");', '          printf(""Empty Fibonacci heap"");', '          extracted_min = extract_min(heap);', '          printf(""\\n min value = %d"", extracted_min->key);', '          printf(""\\n Updated heap: \\n"");', '          print_heap(heap->min);', '          printf(""Fibonacci heap is empty"");', '          printf("" \\n node to be decreased = "");', '          scanf(""%d"", &dec_key);', '          printf("" \\n enter the new key = "");', '          scanf(""%d"", &new_key);', '          find_node(heap, find_use, dec_key, new_key);', '          printf(""\\n Key decreased- Corresponding heap:\\n"");', '          print_heap(heap->min);', '          printf(""Fibonacci heap is empty"");', '          printf("" \\n Enter node key to be deleted = "");', '          scanf(""%d"", &dec_key);', '          Delete_Node(heap, dec_key);', '          printf(""\\n Node Deleted- Corresponding heap:\\n"");', '          print_heap(heap->min);', '        printf(""Invalid choice "");', '  int Fibonnaci_link(node *, node *, node *);', '  int Decrease_key(node *, int, int);', '  int Cut(node *, node *, node *);', '  int Cascase_cut(node *, node *);', '  FibonacciHeap() { H = InitializeHeap(); }', 'node *FibonacciHeap::InitializeHeap() {', 'node *FibonacciHeap::Create_node(int value) {', 'node *FibonacciHeap::Insert(node *H, node *x) {', 'int FibonacciHeap::Fibonnaci_link(node *H1, node *y, node *z) {', '  ((z->child)->left)->right = y;', 'node *FibonacciHeap::Union(node *H1, node *H2) {', 'int FibonacciHeap::Display(node *H) {', '    cout << ""Empty Heap"" << endl;', '  cout << ""Root Nodes: "" << endl;', '  } while (p != H && p->right != NULL);', 'node *FibonacciHeap::Extract_Min(node *H1) {', '  if (z == z->right && z->child == NULL)', 'int FibonacciHeap::Consolidate(node *H1) {', '  float f = (log(nH)) / (log(2));', '  for (int j = 0; j <= D; j++) {', '        (H->left)->right = A[j];', 'int FibonacciHeap::Decrease_key(node *H1, int x, int k) {', '    cout << ""The Heap is Empty"" << endl;', '    cout << ""Node not found in the Heap"" << endl;', '    cout << ""Entered key greater than current key"" << endl;', '  if (y != NULL && ptr->n < y->n) {', 'int FibonacciHeap::Cut(node *H1, node *x, node *y)', 'int FibonacciHeap::Cascase_cut(node *H1, node *y) {', 'node *FibonacciHeap::Find(node *H, int k) {', 'int FibonacciHeap::Delete_key(node *H1, int k) {', '  t = Decrease_key(H1, k, -5000);', '    cout << ""Key Deleted"" << endl;', '    cout << ""Key not Deleted"" << endl;', '    cout << ""The node with minimum key: "" << p->n << endl;', '    cout << ""Heap is empty"" << endl;']","['insert(H, x)', '    degree[x] = 0', '    p[x] = NIL', '    child[x] = NIL', '    left[x] = x', '    right[x] = x', '    mark[x] = FALSE', '    concatenate the root list containing x with root list H ', '    if min[H] == NIL or key[x] < key[min[H]]', '        then min[H] = x', '    n[H] = n[H] + 1']",['nsertion|||O(1)&&&ind Min|||O(1)&&&nion|||O(1)&&&xtract Min|||O(log n)&&&ecrease Key|||O(1)&&&elete Node|||O(log n)'],"[""It is a set of min heap-ordered trees. (i.e. The parent is always smaller than the children.)|||A pointer is maintained at the minimum element node.|||It consists of a set of marked nodes. (Decrease key operation)|||The trees within a Fibonacci heap are unordered but rooted.|||Deleting a node from the tree takes O(1) time.|||The concatenation of two such lists takes O(1) time.|||Create a new node for the element.|||Check if the heap is empty.|||If the heap is empty, set the new node as a root node and mark it min.|||Else, insert the node into the root list and update min.|||Concatenate the roots of both the heaps.|||Update min by selecting a minimum key from the new root lists.|||Delete the min node.|||Set the min-pointer to the next root in the root list.|||Create an array of size equal to the maximum degree of the trees in the heap before deletion.|||Do the following (steps 5-7) until there are no multiple roots with the same degree.|||Map the degree of current root (min-pointer) to the degree in the array.|||Map the degree of next root to the degree in array.|||If there are more than two mappings for the same degree, then apply union operation to those roots such that the min-heap property is maintained (i.e. the minimum is at the root).|||We will perform an extract-min operation on the heap below.|||Fibonacci Heap|||Delete the min node, add all its child nodes to the root list and set the min-pointer to the next root in the root list.|||Delete the min node|||The maximum degree in the tree is 3. Create an array of size 4 and map degree of the next roots with the array.|||Create an array|||Here, 23 and 7 have the same degrees, so unite them.|||Unite those having the same degrees|||Again, 7 and 17 have the same degrees, so unite them as well.|||Unite those having the same degrees|||Again 7 and 24 have the same degree, so unite them.|||Unite those having the same degrees|||Map the next nodes.|||Map the remaining nodes|||Again, 52 and 21 have the same degree, so unite them|||Unite those having the same degrees|||Similarly, unite 21 and 18.|||Unite those having the same degrees|||Map the remaining root.|||Map the remaining nodes|||The final heap is.|||Final fibonacci heap|||To improve the asymptotic running time of Dijkstra's algorithm.|||""]"
18,['Decrease Key and Delete Node Operations on a Fibonacci Heap'],"['In this tutorial, you will learn how decrease key and delete node operations work. Also, you will find working examples of these operations on a fibonacci heap in C, C++, Java and Python.']",[],[],"['Decreasing a Key', 'Decrease Key Example', 'Deleting a Node', 'Decrease key and Delete node operations in Python, Java and C/C++', 'Complexities']","['Decrease-Key', 'Cut', 'Cascading-Cut', 'Example: Decreasing 46 to 15.', 'Example: Decreasing 35 to 5']","['//cdn.programiz.com/cdn/farfuture/a2saPWSS5mUnqQki8eJZqDyFribjHD7eAVC6w0np2-Q/mtime:1585305411/sites/tutorial2program/files/decrease-key-1.png', '//cdn.programiz.com/cdn/farfuture/p4Im_yshM4v1y2hXoLWCKlJvT3vONp88DRnpNIAdeoI/mtime:1585305417/sites/tutorial2program/files/decrease-key-2.png', '//cdn.programiz.com/cdn/farfuture/7O4bB8313JQPxwNcddNI18inDW9qaT9T20ybxlWE8p4/mtime:1585305423/sites/tutorial2program/files/decrease-key-3.png', '//cdn.programiz.com/cdn/farfuture/k5C8M19FG526aBooH3RFNq22gsyW9S-cnFxFFrDBdR4/mtime:1585305429/sites/tutorial2program/files/decrease-key-4.png', '//cdn.programiz.com/cdn/farfuture/qEf-soIk3GaXPk3mDPmecigWICv2EaaYLKrnx3tSRJs/mtime:1585305435/sites/tutorial2program/files/decrease-key-5.png', '//cdn.programiz.com/cdn/farfuture/oYkzdVHWPpaUAzH5iZu3XPvYEbnYI48rL-qgwLw6m_U/mtime:1585305445/sites/tutorial2program/files/decrease-key-6.png', '//cdn.programiz.com/cdn/farfuture/8Fp6ajMBU_o-lumoRgQ2Zg7F57hzNg0V6EvBsSrTQmU/mtime:1585305441/sites/tutorial2program/files/decrease-key-6-1.png']","['Now, we will discuss two of its important operations.', 'Following functions are used for decreasing the key.', 'The above operations can be understood in the examples below.']","['In decreasing a key operation, the value of a key is decreased to a lower value.', 'This process makes use of decrease-key and extract-min operations. The following steps are followed for deleting a node.']",['A fibonacci heap is a tree based data structure which consists of a collection of trees with min heap or max heap property. Its operations are more efficient in terms of time complexity than those of its similar data structures like binomial heap and binary heap.'],"['# Fibonacci Heap in python', 'import math', 'class FibonacciTree:', '    def __init__(self, key):', '        self.key = key', '        self.children = []', '        self.order = 0', '    def add_at_end(self, t):', 'class FibonacciHeap:', '    def __init__(self):', '        self.trees = []', '        self.least = None', '        self.count = 0', '    def insert(self, key):', '    def get_min(self):', '        if self.least is None:', '            return None', '        return self.least.key', '    def extract_min(self):', '        smallest = self.least', '            else:', '    def consolidate(self):', '            x = self.trees[0]', '            order = x.order', '                y = aux[order]', '            aux[order] = x', '        self.least = None', '        for k in aux:', '            if k is not None:', 'def floor_log2(x):', 'fheap = FibonacciHeap()', 'fheap.insert(11)', 'fheap.insert(10)', 'fheap.insert(39)', 'fheap.insert(26)', 'fheap.insert(24)', 'class node {', '  node parent;', '  node left;', '  node right;', '  node child;', '  int degree;', '  boolean mark;', '  int key;', '  public node() {', '    this.degree = 0;', '    this.mark = false;', '    this.parent = null;', '    this.left = this;', '    this.right = this;', '    this.child = null;', '  node(int x) {', '    this();', '    this.key = x;', '  void set_parent(node x) {', '    this.parent = x;', '  node get_parent() {', '    return this.parent;', '  void set_left(node x) {', '    this.left = x;', '  node get_left() {', '    return this.left;', '  void set_right(node x) {', '    this.right = x;', '  node get_right() {', '    return this.right;', '  void set_child(node x) {', '    this.child = x;', '  node get_child() {', '    return this.child;', '  void set_degree(int x) {', '    this.degree = x;', '  int get_degree() {', '    return this.degree;', '  void set_mark(boolean m) {', '    this.mark = m;', '  boolean get_mark() {', '    return this.mark;', '  void set_key(int x) {', '    this.key = x;', '  int get_key() {', '    return this.key;', 'public class fibHeap {', '  node min;', '  int n;', '  boolean trace;', '  node found;', '  public boolean get_trace() {', '    return trace;', '    this.trace = t;', '    return new fibHeap();', '  fibHeap() {', '    min = null;', '    n = 0;', '    trace = false;', '    if (min == null) {', '      min = x;', '      x.set_left(min);', '      x.set_right(min);', '    } else {', '      x.set_right(min);', '      min.set_left(x);', '        min = x;', '    n += 1;', '    insert(new node(key));', '  public void display() {', '    display(min);', '    System.out.println();', '    System.out.print(""("");', '    if (c == null) {', '      System.out.print("")"");', '      return;', '    } else {', '      node temp = c;', '      do {', '        display(k);', '      } while (temp != c);', '      System.out.print("")"");', '    H3.min = H1.min;', '      H1.min.set_left(t2);', '      t1.set_right(H2.min);', '      H2.min.set_left(t1);', '      t2.set_right(H1.min);', '      H3.min = H2.min;', '    H3.n = H1.n + H2.n;', '  public int find_min() {', '    return this.min.get_key();', '  public int extract_min() {', '    node z = this.min;', '    if (z != null) {', '      node c = z.get_child();', '      node k = c, p;', '      if (c != null) {', '        do {', '          p = c.get_right();', '          insert(c);', '          c.set_parent(null);', '          c = p;', '      z.set_child(null);', '      if (z == z.get_right())', '        this.min = null;', '      else {', '        this.consolidate();', '      this.n -= 1;', '      return z.get_key();', '    return Integer.MAX_VALUE;', '  public void consolidate() {', '      A[i] = null;', '    node w = min;', '    if (w != null) {', '      node check = min;', '      do {', '        node x = w;', '        while (A[d] != null) {', '          node y = A[d];', '            node temp = x;', '            x = y;', '            y = temp;', '            w = x;', '          }', '          fib_heap_link(y, x);', '          check = x;', '          A[d] = null;', '          d += 1;', '        }', '        A[d] = x;', '        w = w.get_right();', '      this.min = null;', '        if (A[i] != null) {', '          insert(A[i]);', '        }', '    node p = x.get_child();', '    if (p == null) {', '      y.set_right(y);', '      y.set_left(y);', '    } else {', '      y.set_right(p);', '      p.set_left(y);', '    y.set_parent(x);', '    x.set_child(y);', '    y.set_mark(false);', '      return;', '    else {', '      node temp = c;', '      do {', '          found = temp;', '        else {', '          find(key, k);', '        }', '  public node find(int k) {', '    found = null;', '    find(k, this.min);', '    return found;', '    node x = find(key);', '    decrease_key(x, nval);', '    if (k > x.get_key())', '      return;', '    x.set_key(k);', '    node y = x.get_parent();', '      cut(x, y);', '      cascading_cut(y);', '      min = x;', '    x.set_right(null);', '    x.set_left(null);', '    insert(x);', '    x.set_parent(null);', '    x.set_mark(false);', '    node z = y.get_parent();', '    if (z != null) {', '        y.set_mark(true);', '      else {', '        cut(y, z);', '        cascading_cut(z);', '  public void delete(node x) {', '    int p = extract_min();', '    obj.insert(7);', '    obj.insert(26);', '    obj.insert(30);', '    obj.insert(39);', '    obj.insert(10);', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '    obj.display();', '#include <stdio.h>', '#include <stdlib.h>', '#include <stdbool.h>', '#include <math.h>', 'typedef struct _NODE', '  int key;', '  int degree;', '  struct _NODE *left_sibling;', '  struct _NODE *right_sibling;', '  struct _NODE *parent;', '  struct _NODE *child;', '  bool mark;', '  bool visited;', 'typedef struct fibanocci_heap', '  int n;', '  NODE *min;', '  int phi;', '  int degree;', '} FIB_HEAP;', 'FIB_HEAP *make_fib_heap();', 'void consolidate(FIB_HEAP *H);', 'FIB_HEAP *make_fib_heap()', '  FIB_HEAP *H;', '  H->n = 0;', '  H->min = NULL;', '  H->phi = 0;', '  H->degree = 0;', '  return H;', 'void new_print_heap(NODE *n)', '  NODE *x;', '    if (x->child == NULL)', '    else', '    if (x->right_sibling == n)', '      break;', '  new->key = val;', '  new->degree = 0;', '  new->mark = false;', '  new->parent = NULL;', '  new->child = NULL;', '  new->visited = false;', '  new->left_sibling = new;', '  new->right_sibling = new;', '  if (H->min == NULL)', '    H->min = new;', '      H->min = new;', '  (H->n)++;', '  if (H == NULL)', '    return NULL;', '    return H->min;', '  FIB_HEAP *Hnew;', '  Hnew = make_fib_heap();', '  Hnew->min = H1->min;', '  NODE *temp1, *temp2;', '    Hnew->min = H2->min;', '  Hnew->n = H1->n + H2->n;', '  return Hnew;', 'int cal_degree(int n)', '  int count = 0;', '  while (n > 0)', '    n = n / 2;', '    count++;', '  return count;', 'void consolidate(FIB_HEAP *H)', '  int degree, i, d;', '  degree = cal_degree(H->n);', '  NODE *A[degree], *x, *y, *z;', '    A[i] = NULL;', '  x = H->min;', '    d = x->degree;', '    while (A[d] != NULL)', '      y = A[d];', '      if (x->key > y->key)', '        NODE *exchange_help;', '        exchange_help = x;', '        x = y;', '        y = exchange_help;', '      if (y == H->min)', '        H->min = x;', '      fib_heap_link(H, y, x);', '        H->min = x;', '      A[d] = NULL;', '      d++;', '    A[d] = x;', '    x = x->right_sibling;', '  } while (x != H->min);', '  H->min = NULL;', '  for (i = 0; i < degree; i++)', '    if (A[i] != NULL)', '      if (H->min == NULL)', '        H->min = A[i];', '      else', '        {', '          H->min = A[i];', '        }', '      if (H->min == NULL)', '        H->min = A[i];', '        H->min = A[i];', '  if (x->right_sibling == x)', '    H->min = x;', '  y->left_sibling = y;', '  y->right_sibling = y;', '  y->parent = x;', '  if (x->child == NULL)', '    x->child = y;', '  y->right_sibling = x->child;', '  x->child->left_sibling = y;', '    x->child = y;', '  (x->degree)++;', 'NODE *extract_min(FIB_HEAP *H)', '  if (H->min == NULL)', '    NODE *temp = H->min;', '    NODE *pntr;', '    pntr = temp;', '    NODE *x = NULL;', '    if (temp->child != NULL)', '      x = temp->child;', '      do', '          H->min = x;', '        x->parent = NULL;', '        x = pntr;', '      H->min = NULL;', '    else', '      consolidate(H);', '    H->n = H->n - 1;', '    return temp;', '  return H->min;', '  NODE *temp_parent_check;', '    parent_node->child = NULL;', '  (parent_node->degree)--;', '  NODE *aux;', '  aux = parent_node->parent;', '  if (aux != NULL)', '    else', '      cascading_cut(H, aux);', '  NODE *parent_node;', '  if (H == NULL)', '    return;', '    else', '  NODE *find_use = n;', '  NODE *f = NULL;', '  find_use->visited = true;', '  if (find_use->key == key)', '    find_use->visited = false;', '    f = find_use;', '  if (find_use->child != NULL)', '  find_use->visited = false;', '  FIB_HEAP *temp;', '  int no_of_nodes, ele, i;', '  NODE *new_node;', '  temp = NULL;', '  if (temp == NULL)', '    temp = make_fib_heap();', '  scanf(""%d"", &no_of_nodes);', '    scanf(""%d"", &ele);', '  return temp;', '  NODE *p = NULL;', '  p = extract_min(H);', '  if (p != NULL)', '    printf(""\\n Node deleted"");', '  FIB_HEAP *heap, *h1, *h2;', '  heap = NULL;', '  while (1)', '    switch (operation_no)', '    case 1:', '      heap = make_fib_heap();', '      break;', '    case 2:', '      if (heap == NULL)', '        scanf(""%d"", &ele);', '      break;', '    case 3:', '      if (min_node == NULL)', '      else', '      break;', '    case 4:', '      if (heap == NULL)', '        break;', '      break;', '    case 5:', '      if (heap == NULL)', '      else', '      break;', '    case 6:', '      if (heap == NULL)', '      else', '        scanf(""%d"", &dec_key);', '        scanf(""%d"", &new_key);', '        find_use = heap->min;', '      break;', '    case 7:', '      if (heap == NULL)', '      else', '        scanf(""%d"", &dec_key);', '        break;', '    case 8:', '      break;', '    case 9:', '      free(new_node);', '      free(heap);', '      exit(0);', '    default:', '#include <iostream>', '#include <cmath>', '#include <cstdlib>', 'using namespace std;', 'struct node', '  int n;', '  int degree;', '  node *parent;', '  node *child;', '  node *left;', '  node *right;', '  char mark;', '  char C;', 'class FibonacciHeap', 'private:', '  int nH;', '  node *H;', '  node *InitializeHeap();', '  node *Create_node(int);', '  node *Union(node *, node *);', '  node *Extract_Min(node *);', '  int Consolidate(node *);', '  int Display(node *);', '  node *Find(node *, int);', '  int Delete_key(node *, int);', '  node *np;', '  np = NULL;', '  return np;', '  node *x = new node;', '  x->n = value;', '  return x;', '  x->degree = 0;', '  x->parent = NULL;', '  x->child = NULL;', '  x->left = x;', '  x->right = x;', ""  x->mark = 'F';"", ""  x->C = 'N';"", '  if (H != NULL)', '    (H->left)->right = x;', '    x->right = H;', '    x->left = H->left;', '    H->left = x;', '    if (x->n < H->n)', '      H = x;', '    H = x;', '  nH = nH + 1;', '  return H;', '  (y->left)->right = y->right;', '  (y->right)->left = y->left;', '  if (z->right == z)', '    H1 = z;', '  y->left = y;', '  y->right = y;', '  y->parent = z;', '  if (z->child == NULL)', '    z->child = y;', '  y->right = z->child;', '  y->left = (z->child)->left;', '  (z->child)->left = y;', '  if (y->n < (z->child)->n)', '    z->child = y;', '  z->degree++;', '  node *np;', '  node *H = InitializeHeap();', '  H = H1;', '  (H->left)->right = H2;', '  (H2->left)->right = H;', '  np = H->left;', '  H->left = H2->left;', '  H2->left = np;', '  return H;', '  node *p = H;', '  if (p == NULL)', '    return 0;', '    cout << p->n;', '    p = p->right;', '    if (p != H)', '      cout << ""-->"";', '  cout << endl;', '  node *p;', '  node *ptr;', '  node *z = H1;', '  p = z;', '  ptr = z;', '  if (z == NULL)', '    return z;', '  node *x;', '  node *np;', '  x = NULL;', '  if (z->child != NULL)', '    x = z->child;', '  if (x != NULL)', '    ptr = x;', '      np = x->right;', '      (H1->left)->right = x;', '      x->right = H1;', '      x->left = H1->left;', '      H1->left = x;', '      if (x->n < H1->n)', '        H1 = x;', '      x->parent = NULL;', '      x = np;', '    } while (np != ptr);', '  (z->left)->right = z->right;', '  (z->right)->left = z->left;', '  H1 = z->right;', '    H = NULL;', '    H1 = z->right;', '    Consolidate(H1);', '  nH = nH - 1;', '  return p;', '  int d, i;', '  int D = f;', '  node *A[D];', '  for (i = 0; i <= D; i++)', '    A[i] = NULL;', '  node *x = H1;', '  node *y;', '  node *np;', '  node *pt = x;', '    pt = pt->right;', '    d = x->degree;', '    while (A[d] != NULL)', '      y = A[d];', '      if (x->n > y->n)', '        np = x;', '        x = y;', '        y = np;', '      if (y == H1)', '        H1 = x;', '      if (x->right == x)', '        H1 = x;', '      A[d] = NULL;', '      d = d + 1;', '    A[d] = x;', '    x = x->right;', '  while (x != H1);', '  H = NULL;', '  for (int j = 0; j <= D; j++)', '    if (A[j] != NULL)', '      A[j]->left = A[j];', '      A[j]->right = A[j];', '      if (H != NULL)', '        A[j]->right = H;', '        A[j]->left = H->left;', '        H->left = A[j];', '        if (A[j]->n < H->n)', '          H = A[j];', '      else', '        H = A[j];', '      if (H == NULL)', '        H = A[j];', '      else if (A[j]->n < H->n)', '        H = A[j];', '  node *y;', '  if (H1 == NULL)', '    return 0;', '  node *ptr = Find(H1, x);', '  if (ptr == NULL)', '    return 1;', '  if (ptr->n < k)', '    return 0;', '  ptr->n = k;', '  y = ptr->parent;', '    Cut(H1, ptr, y);', '    Cascase_cut(H1, y);', '  if (ptr->n < H->n)', '    H = ptr;', '  return 0;', '  if (x == x->right)', '    y->child = NULL;', '  (x->left)->right = x->right;', '  (x->right)->left = x->left;', '  if (x == y->child)', '    y->child = x->right;', '  y->degree = y->degree - 1;', '  x->right = x;', '  x->left = x;', '  (H1->left)->right = x;', '  x->right = H1;', '  x->left = H1->left;', '  H1->left = x;', '  x->parent = NULL;', ""  x->mark = 'F';"", '  node *z = y->parent;', '  if (z != NULL)', ""    if (y->mark == 'F')"", ""      y->mark = 'T';"", '    else', '      Cut(H1, y, z);', '      Cascase_cut(H1, z);', '  node *x = H;', ""  x->C = 'Y';"", '  node *p = NULL;', '  if (x->n == k)', '    p = x;', ""    x->C = 'N';"", '    return p;', '  if (p == NULL)', '    if (x->child != NULL)', '      p = Find(x->child, k);', ""    if ((x->right)->C != 'Y')"", '      p = Find(x->right, k);', ""  x->C = 'N';"", '  return p;', '  node *np = NULL;', '  int t;', '  if (!t)', '    np = Extract_Min(H);', '  if (np != NULL)', '  return 0;', 'int main()', '  int n, m, l;', '  FibonacciHeap fh;', '  node *p;', '  node *H;', '  H = fh.InitializeHeap();', '  p = fh.Create_node(7);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(17);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(26);', '  H = fh.Insert(H, p);', '  p = fh.Create_node(1);', '  H = fh.Insert(H, p);', '  fh.Display(H);', '  p = fh.Extract_Min(H);', '  if (p != NULL)', '  m = 26;', '  l = 16;', '  fh.Decrease_key(H, m, l);', '  m = 16;', '  fh.Delete_key(H, m);']","['        self.order = self.order + 1', '        new_tree = FibonacciTree(key)', '        self.trees.append(new_tree)', '        if (self.least is None or key < self.least.key):', '            self.least = new_tree', '        self.count = self.count + 1', '        if smallest is not None:', '            for child in smallest.children:', '                self.trees.append(child)', '            self.trees.remove(smallest)', '            if self.trees == []:', '                self.least = None', '                self.least = self.trees[0]', '                self.consolidate()', '            self.count = self.count - 1', '        aux = (floor_log2(self.count) + 1) * [None]', '            self.trees.remove(x)', '            while aux[order] is not None:', '                if x.key > y.key:', '                aux[order] = None', '                order = order + 1', '                self.trees.append(k)', '                if (self.least is None', '                        or k.key < self.least.key):', '                    self.least = k', ""print('Minimum value: {}'.format(fheap.get_min()))"", ""print('Minimum value removed: {}'.format(fheap.extract_min()))"", '    this.key = Integer.MAX_VALUE;', '  public void set_trace(boolean t) {', '  public static fibHeap create_heap() {', '      x.set_left(min.get_left());', '      min.get_left().set_right(x);', '      if (x.get_key() < min.get_key())', '  private void display(node c) {', '        System.out.print(temp.get_key());', '        node k = temp.get_child();', '        temp = temp.get_right();', '  public static void merge_heap(fibHeap H1, fibHeap H2, fibHeap H3) {', '    if (H1.min != null && H2.min != null) {', '      node t1 = H1.min.get_left();', '      node t2 = H2.min.get_left();', '    if (H1.min == null || (H2.min != null && H2.min.get_key() < H1.min.get_key()))', '  private void display_node(node z) {', '    System.out.println(""right: "" + ((z.get_right() == null) ? ""-1"" : z.get_right().get_key()));', '    System.out.println(""left: "" + ((z.get_left() == null) ? ""-1"" : z.get_left().get_key()));', '    System.out.println(""child: "" + ((z.get_child() == null) ? ""-1"" : z.get_child().get_key()));', '    System.out.println(""degree "" + z.get_degree());', '        } while (c != null && c != k);', '      z.get_left().set_right(z.get_right());', '      z.get_right().set_left(z.get_left());', '        this.min = z.get_right();', '    double phi = (1 + Math.sqrt(5)) / 2;', '    int Dofn = (int) (Math.log(this.n) / Math.log(phi));', '    node[] A = new node[Dofn + 1];', '    for (int i = 0; i <= Dofn; ++i)', '          if (x.get_key() > y.get_key()) {', '      } while (w != null && w != check);', '      for (int i = 0; i <= Dofn; ++i) {', '  private void fib_heap_link(node y, node x) {', '    y.get_left().set_right(y.get_right());', '    y.get_right().set_left(y.get_left());', '      p.get_left().set_right(y);', '    x.set_degree(x.get_degree() + 1);', '  private void find(int key, node c) {', '    if (found != null || c == null)', '        if (key == temp.get_key())', '          node k = temp.get_child();', '          temp = temp.get_right();', '      } while (temp != c && found == null);', '  public void decrease_key(int key, int nval) {', '  private void decrease_key(node x, int k) {', '    if (y != null && x.get_key() < y.get_key()) {', '    if (x.get_key() < min.get_key())', '  private void cut(node x, node y) {', '    x.get_right().set_left(x.get_left());', '    x.get_left().set_right(x.get_right());', '    y.set_degree(y.get_degree() - 1);', '  private void cascading_cut(node y) {', '      if (y.get_mark() == false)', '    decrease_key(x, Integer.MIN_VALUE);', '  public static void main(String[] args) {', '    fibHeap obj = create_heap();', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', '    System.out.println(obj.extract_min());', 'void insertion(FIB_HEAP *H, NODE *new, int val);', 'void fib_heap_link(FIB_HEAP *H, NODE *y, NODE *x);', 'NODE *find_min_node(FIB_HEAP *H);', 'void decrease_key(FIB_HEAP *H, NODE *node, int key);', 'void cut(FIB_HEAP *H, NODE *node_to_be_decrease, NODE *parent_node);', 'void cascading_cut(FIB_HEAP *H, NODE *parent_node);', 'void Delete_Node(FIB_HEAP *H, int dec_key);', '  H = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '  for (x = n;; x = x->right_sibling)', '      printf(""node with no child (%d) \\n"", x->key);', '      printf(""NODE(%d) with child (%d)\\n"", x->key, x->child->key);', 'void insertion(FIB_HEAP *H, NODE *new, int val)', '  new = (NODE *)malloc(sizeof(NODE));', '    H->min->left_sibling->right_sibling = new;', '    new->right_sibling = H->min;', '    new->left_sibling = H->min->left_sibling;', 'NODE *find_min_node(FIB_HEAP *H)', '    printf("" \\n Fibonacci heap not yet created \\n"");', 'FIB_HEAP *unionHeap(FIB_HEAP *H1, FIB_HEAP *H2)', '  temp1 = Hnew->min->right_sibling;', '  temp2 = H2->min->left_sibling;', '  Hnew->min->right_sibling->left_sibling = H2->min->left_sibling;', '  Hnew->min->right_sibling = H2->min;', '  H2->min->left_sibling = Hnew->min;', '  if ((H1->min == NULL) || (H2->min != NULL && H2->min->key < H1->min->key))', '      if (y->right_sibling == x)', '      A[i]->left_sibling = A[i];', '      A[i]->right_sibling = A[i];', '        H->min->left_sibling->right_sibling = A[i];', '        A[i]->right_sibling = H->min;', '        A[i]->left_sibling = H->min->left_sibling;', '        H->min->left_sibling = A[i];', '        if (A[i]->key < H->min->key)', '      else if (A[i]->key < H->min->key)', 'void fib_heap_link(FIB_HEAP *H, NODE *y, NODE *x)', '  y->right_sibling->left_sibling = y->left_sibling;', '  y->left_sibling->right_sibling = y->right_sibling;', '  y->left_sibling = x->child->left_sibling;', '  x->child->left_sibling->right_sibling = y;', '  if ((y->key) < (x->child->key))', '    printf(""\\n The heap is empty"");', '        pntr = x->right_sibling;', '        (H->min->left_sibling)->right_sibling = x;', '        x->right_sibling = H->min;', '        x->left_sibling = H->min->left_sibling;', '        H->min->left_sibling = x;', '        if (x->key < H->min->key)', '      } while (pntr != temp->child);', '    (temp->left_sibling)->right_sibling = temp->right_sibling;', '    (temp->right_sibling)->left_sibling = temp->left_sibling;', '    H->min = temp->right_sibling;', '    if (temp == temp->right_sibling && temp->child == NULL)', '      H->min = temp->right_sibling;', 'void cut(FIB_HEAP *H, NODE *node_to_be_decrease, NODE *parent_node)', '  if (node_to_be_decrease == node_to_be_decrease->right_sibling)', '  node_to_be_decrease->left_sibling->right_sibling = node_to_be_decrease->right_sibling;', '  node_to_be_decrease->right_sibling->left_sibling = node_to_be_decrease->left_sibling;', '  if (node_to_be_decrease == parent_node->child)', '    parent_node->child = node_to_be_decrease->right_sibling;', '  node_to_be_decrease->left_sibling = node_to_be_decrease;', '  node_to_be_decrease->right_sibling = node_to_be_decrease;', '  H->min->left_sibling->right_sibling = node_to_be_decrease;', '  node_to_be_decrease->right_sibling = H->min;', '  node_to_be_decrease->left_sibling = H->min->left_sibling;', '  H->min->left_sibling = node_to_be_decrease;', '  node_to_be_decrease->parent = NULL;', '  node_to_be_decrease->mark = false;', 'void cascading_cut(FIB_HEAP *H, NODE *parent_node)', '    if (parent_node->mark == false)', 'void decrease_key(FIB_HEAP *H, NODE *node_to_be_decrease, int new_key)', '    printf(""\\n FIbonacci heap not created "");', '  if (node_to_be_decrease == NULL)', '    printf(""Node is not in the heap"");', '    if (node_to_be_decrease->key < new_key)', '      printf(""\\n Invalid new key for decrease key operation \\n "");', '      node_to_be_decrease->key = new_key;', '      parent_node = node_to_be_decrease->parent;', '      if ((parent_node != NULL) && (node_to_be_decrease->key < parent_node->key))', '        printf(""\\n cut called"");', '        cut(H, node_to_be_decrease, parent_node);', '        printf(""\\n cascading cut called"");', '        cascading_cut(H, parent_node);', '      if (node_to_be_decrease->key < H->min->key)', '        H->min = node_to_be_decrease;', 'void *find_node(FIB_HEAP *H, NODE *n, int key, int new_key)', '    decrease_key(H, f, new_key);', '    find_node(H, find_use->child, key, new_key);', '  if ((find_use->right_sibling->visited != true))', '    find_node(H, find_use->right_sibling, key, new_key);', '  temp = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '  printf("" \\n enter number of nodes to be insert = "");', '  for (i = 1; i <= no_of_nodes; i++)', '    printf(""\\n node %d and its key value = "", i);', '    insertion(temp, new_node, ele);', 'void Delete_Node(FIB_HEAP *H, int dec_key)', '  find_node(H, H->min, dec_key, -5000);', '    printf(""\\n Node not deleted:some error"");', '  NODE *new_node, *min_node, *extracted_min, *node_to_be_decrease, *find_use;', '  int operation_no, new_key, dec_key, ele, i, no_of_nodes;', '  heap = (FIB_HEAP *)malloc(sizeof(FIB_HEAP));', '    printf("" \\n choose below operations \\n 1. Create Fibonacci heap \\n 2. Insert nodes into fibonacci heap \\n 3. Find min \\n 4. Union \\n 5. Extract min \\n 6. Decrease key \\n 7.Delete node \\n 8. print heap \\n 9. exit \\n enter operation_no = "");', '      printf("" enter number of nodes to be insert = "");', '      scanf(""%d"", &no_of_nodes);', '      for (i = 1; i <= no_of_nodes; i++)', '        printf(""\\n node %d and its key value = "", i);', '        insertion(heap, new_node, ele);', '      min_node = find_min_node(heap);', '        printf(""No minimum value"");', '        printf(""\\n min value = %d"", min_node->key);', '        printf(""\\n no FIbonacci heap is created please create fibonacci heap \\n "");', '      h1 = insertion_procedure();', '      heap = unionHeap(heap, h1);', '      printf(""Unified Heap:\\n"");', '      new_print_heap(heap->min);', '        printf(""Fibonacci heap is empty"");', '        extracted_min = extract_min(heap);', '        printf(""\\n min value = %d"", extracted_min->key);', '        printf(""\\n Updated heap: \\n"");', '        new_print_heap(heap->min);', '        printf(""Fibonacci heap is empty"");', '        printf("" \\n node to be decreased = "");', '        printf("" \\n enter the new key = "");', '        find_node(heap, find_use, dec_key, new_key);', '        printf(""\\n Key decreased- Corresponding heap:\\n"");', '        new_print_heap(heap->min);', '        printf(""Fibonacci heap is empty"");', '        printf("" \\n Enter node key to be deleted = "");', '        Delete_Node(heap, dec_key);', '        printf(""\\n Node Deleted- Corresponding heap:\\n"");', '        new_print_heap(heap->min);', '      new_print_heap(heap->min);', '      printf(""Invalid choice "");', '  int Fibonnaci_link(node *, node *, node *);', '  int Decrease_key(node *, int, int);', '  int Cut(node *, node *, node *);', '  int Cascase_cut(node *, node *);', '  FibonacciHeap() { H = InitializeHeap(); }', 'node *FibonacciHeap::InitializeHeap()', 'node *FibonacciHeap::Create_node(int value)', 'node *FibonacciHeap::Insert(node *H, node *x)', 'int FibonacciHeap::Fibonnaci_link(node *H1, node *y, node *z)', '  ((z->child)->left)->right = y;', 'node *FibonacciHeap::Union(node *H1, node *H2)', 'int FibonacciHeap::Display(node *H)', '    cout << ""The Heap is Empty"" << endl;', '  cout << ""The root nodes of Heap are: "" << endl;', '  } while (p != H && p->right != NULL);', 'node *FibonacciHeap::Extract_Min(node *H1)', '  if (z == z->right && z->child == NULL)', 'int FibonacciHeap::Consolidate(node *H1)', '  float f = (log(nH)) / (log(2));', '        (H->left)->right = A[j];', 'int FibonacciHeap::Decrease_key(node *H1, int x, int k)', '    cout << ""The Heap is Empty"" << endl;', '    cout << ""Node not found in the Heap"" << endl;', '    cout << ""Entered key greater than current key"" << endl;', '  if (y != NULL && ptr->n < y->n)', 'int FibonacciHeap::Cut(node *H1, node *x, node *y)', 'int FibonacciHeap::Cascase_cut(node *H1, node *y)', 'node *FibonacciHeap::Find(node *H, int k)', 'int FibonacciHeap::Delete_key(node *H1, int k)', '  t = Decrease_key(H1, k, -5000);', '    cout << ""Key Deleted"" << endl;', '    cout << ""Key not Deleted"" << endl;', '    cout << ""The node with minimum key: "" << p->n << endl;', '    cout << ""Heap is empty"" << endl;']",[],['ecrease Key|||O(1)&&&elete Node|||O(log n)'],"['Decrease a key: decreases the value of a the key to any lower value|||Delete a node: deletes the given node|||Select the node to be decreased, x, and change its value to the new value k.|||If the parent of x, y, is not null and the key of parent is greater than that of the k then call Cut(x) and Cascading-Cut(y) subsequently.|||If the key of x is smaller than the key of min, then mark x as min.|||Remove x from the current position and add it to the root list.|||If x is marked, then mark it as false.|||If the parent of y is not null then follow the following steps.|||If y is unmarked, then mark y.|||Else, call Cut(y) and Cascading-Cut(parent of y).|||Decrease the value 46 to 15.|||Decrease 46 to 15|||Cut part: Since 24 ≠ nill and 15 < its parent, cut it and add it to the root list. Cascading-Cut part: mark 24.|||Add 15 to root list and mark 24|||Decrease the value 35 to 5.|||Decrease 35 to 5|||Cut part: Since 26 ≠ nill and 5<its parent, cut it and add it to the root list.|||Cut 5 and add it to root list|||Cascading-Cut part: Since 26 is marked, the flow goes to Cut and Cascading-Cut.Cut(26): Cut 26 and add it to the root list and mark it as false.|||Cut 26 and add it to root listCascading-Cut(24):|||Since the 24 is also marked, again call Cut(24) and Cascading-Cut(7). These operations result in the tree below.||||||Cut 24 and add it to root list|||Since 5 < 7, mark 5 as min.|||Mark 5 as min|||Let k be the node to be deleted.|||Apply decrease-key operation to decrease the value of k to the lowest possible value (i.e. -∞).|||Apply extract-min operation to remove this node.|||']"
19,['Tree Data Structure'],"['In this tutorial, you will learn about tree data structure. Also, you will learn about different types of trees and the terminologies used in tree.']",[],[],"['Why Tree Data Structure?', 'Tree Terminologies', 'Types of Tree', 'Tree Traversal', 'Tree Applications']","['Node', 'Edge', 'Root', 'Height of a Node', 'Depth of a Node', 'Height of a Tree', 'Degree of a Node', 'Forest']","['//cdn.programiz.com/sites/tutorial2program/files/tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/nodes-edges_0.png', '//cdn.programiz.com/sites/tutorial2program/files/height-depth_1.png', '//cdn.programiz.com/sites/tutorial2program/files/forest_0.png']","['The node having at least a child node is called an internal node.', 'It is the link between any two nodes.', 'It is the topmost node of a tree.', 'A collection of disjoint trees is called a forest.', 'You can create a forest by cutting the root of a tree.', 'To learn more, please visit tree traversal.']","['A tree is a nonlinear hierarchical data structure that consists of nodes connected by edges.', 'Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.', 'A node is an entity that contains a key or value and pointers to its child nodes.', 'The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.', 'The depth of a node is the number of edges from the root to the node.', 'The height of a Tree is the height of the root node or the depth of the deepest node.', 'The degree of a node is the total number of branches of that node.']","[""Other data structures such as arrays, linked list, stack, and queue are linear data structures that store data sequentially. In order to perform any operation in a linear data structure, the time complexity increases with the increase in the data size. But, it is not acceptable in today's computational world."", 'The height of a node is the number of edges from the node to the deepest leaf (ie. the longest path from the node to a leaf node).', 'In order to perform any operation on a tree, you need to reach to the specific node. The tree traversal algorithm helps in visiting a required node in the tree.']",[],[],[],[],"['Binary Search Trees(BSTs) are used to quickly check whether an element is present in a set or not.|||Heap is a kind of tree that is used for heap sort.|||A modified version of a tree called Tries is used in modern routers to store routing information.|||Most popular databases use B-Trees and T-Trees, which are variants of the tree structure we learned above to store their data|||Compilers use a syntax tree to validate the syntax of every program you write.|||&&&Binary Tree|||Binary Search Tree|||AVL Tree|||B-Tree|||']"
20,"['Tree Traversal - inorder, preorder and postorder']","['In this tutorial, you will learn about different tree traversal techniques. Also, you will find working examples of different tree traversal methods in C, C++, Java and Python.']",[],[],"['Inorder traversal', 'Preorder traversal', 'Postorder traversal', 'Python, Java and C/C++ Examples']",[],"['//cdn.programiz.com/sites/tutorial2program/files/tree_traversal_tree-traversal.png', '//cdn.programiz.com/sites/tutorial2program/files/tree_traversal_sub-tree-concept.png', '//cdn.programiz.com/sites/tutorial2program/files/tree_traversal_inorder-traversal.png', '//cdn.programiz.com/sites/tutorial2program/files/tree_traversal_inorder-stack_0.png', '//cdn.programiz.com/sites/tutorial2program/files/tree_traversal_inorder-stack_1.png']","['Starting from top, Left to right', 'Starting from bottom, Left to right', 'According to this structure, every tree is a combination of', ""Let's visualize in-order traversal. We start from the root node."", ""Let's put all this in a stack so that we remember."", 'Now we traverse to the subtree pointed on the TOP of the stack.', 'Again, we follow the same rule of inorder', 'After traversing the left subtree, we are left with']","[""Let's think about how we can read the elements of the tree in the image shown above."", ""Although this process is somewhat easy, it doesn't respect the hierarchy of the tree, only the depth of the nodes."", 'Instead, we use traversal methods that take into account the basic structure of a tree i.e.', 'Depending on the order in which we do this, there can be three types of traversal.', 'After going through all the elements, we get the inorder traversal as', ""We don't have to create the stack ourselves because recursion maintains the correct order for us.""]","['Traversing a tree means visiting every node in the tree. You might, for instance, want to add all the values in the tree or find the largest one. For all these operations, you will need to visit each node of the tree.', 'Linear data structures like arrays, stacks, queues, and linked list have only one way to read the data. But a hierarchical data structure like a tree can be traversed in different ways.', 'The struct node pointed to by left and right might have other left and right children so we should think of them as sub-trees instead of sub-nodes.', 'Remember that our goal is to visit each node, so we need to visit all the nodes in the subtree, visit the root node and visit all the nodes in the right subtree as well.', 'We traverse the left subtree first. We also need to remember to visit the root node and the right subtree when this tree is done.', 'Since the node ""5"" doesn\'t have any subtrees, we print it directly. After that we print its parent ""12"" and then the right child ""6"".', 'Putting everything on a stack was helpful because now that the left-subtree of the root node has been traversed, we can print it and go to the right subtree.']","['1 -> 12 -> 5 -> 6 -> 9', '5 -> 6 -> 12 -> 9 -> 1', 'struct node {', '    int data;', '    struct node* left;', '    struct node* right;', 'inorder(root->left)', 'display(root->data)', 'inorder(root->right)', 'display(root->data)', 'preorder(root->left)', 'preorder(root->right)', 'postorder(root->left)', 'postorder(root->right)', 'display(root->data)', '# Tree traversal in Python', 'class Node:', '    def __init__(self, item):', '        self.left = None', '        self.right = None', '        self.val = item', 'def inorder(root):', '    if root:', '        # Traverse left', '        inorder(root.left)', '        # Traverse root', '        # Traverse right', '        inorder(root.right)', 'def postorder(root):', '    if root:', '        # Traverse left', '        postorder(root.left)', '        # Traverse right', '        postorder(root.right)', '        # Traverse root', 'def preorder(root):', '    if root:', '        # Traverse root', '        # Traverse left', '        preorder(root.left)', '        # Traverse right', '        preorder(root.right)', 'root = Node(1)', 'root.left = Node(2)', 'root.right = Node(3)', 'root.left.left = Node(4)', 'root.left.right = Node(5)', 'print(""Inorder traversal "")', 'inorder(root)', 'print(""\\nPreorder traversal "")', 'preorder(root)', 'postorder(root)', 'class Node {', '  int item;', '  Node left, right;', '  public Node(int key) {', '  item = key;', '  left = right = null;', 'class BinaryTree {', '  Node root;', '  BinaryTree() {', '  root = null;', '  void postorder(Node node) {', '  if (node == null)', '    return;', '  postorder(node.left);', '  postorder(node.right);', '  void inorder(Node node) {', '  if (node == null)', '    return;', '  inorder(node.left);', '  inorder(node.right);', '  void preorder(Node node) {', '  if (node == null)', '    return;', '  preorder(node.left);', '  preorder(node.right);', '  tree.root = new Node(1);', '  tree.inorder(tree.root);', '  tree.preorder(tree.root);', '  tree.postorder(tree.root);', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int item;', '  struct node* left;', '  struct node* right;', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  newNode->item = value;', '  newNode->left = NULL;', '  newNode->right = NULL;', '  return newNode;', '  return root->left;', '  return root->right;', 'int main() {', '  insertLeft(root, 12);', '  insertRight(root, 9);', '  insertLeft(root->left, 5);', '  insertRight(root->left, 6);', '  inorderTraversal(root);', '  preorderTraversal(root);', '  postorderTraversal(root);', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  struct Node *left, *right;', '  Node(int data) {', '    this->data = data;', '    left = right = NULL;', '  if (node == NULL)', '    return;', '  cout << node->data << ""->"";', '  if (node == NULL)', '    return;', '  cout << node->data << ""->"";', '  if (node == NULL)', '    return;', '  cout << node->data << ""->"";', 'int main() {', '  root->left = new Node(12);', '  root->right = new Node(9);', '  inorderTraversal(root);', '  preorderTraversal(root);', '  postorderTraversal(root);']","['        print(str(root.val) + ""->"", end=\'\')', '        print(str(root.val) + ""->"", end=\'\')', '        print(str(root.val) + ""->"", end=\'\')', '  System.out.print(node.item + ""->"");', '  System.out.print(node.item + ""->"");', '  System.out.print(node.item + ""->"");', '  public static void main(String[] args) {', '  BinaryTree tree = new BinaryTree();', '  tree.root.left = new Node(12);', '  tree.root.right = new Node(9);', '  tree.root.left.left = new Node(5);', '  tree.root.left.right = new Node(6);', '  System.out.println(""Inorder traversal"");', '  System.out.println(""\\nPreorder traversal "");', '  System.out.println(""\\nPostorder traversal"");', 'void inorderTraversal(struct node* root) {', '  inorderTraversal(root->right);', 'void preorderTraversal(struct node* root) {', '  preorderTraversal(root->left);', '  preorderTraversal(root->right);', 'void postorderTraversal(struct node* root) {', '  postorderTraversal(root->left);', '  postorderTraversal(root->right);', 'struct node* createNode(value) {', '  struct node* newNode = malloc(sizeof(struct node));', 'struct node* insertLeft(struct node* root, int value) {', '  root->left = createNode(value);', 'struct node* insertRight(struct node* root, int value) {', '  root->right = createNode(value);', '  struct node* root = createNode(1);', '  printf(""Inorder traversal \\n"");', '  printf(""\\nPreorder traversal \\n"");', '  printf(""\\nPostorder traversal \\n"");', 'void preorderTraversal(struct Node* node) {', '  preorderTraversal(node->left);', '  preorderTraversal(node->right);', 'void postorderTraversal(struct Node* node) {', '  postorderTraversal(node->left);', '  postorderTraversal(node->right);', 'void inorderTraversal(struct Node* node) {', '  inorderTraversal(node->right);', '  struct Node* root = new Node(1);', '  root->left->left = new Node(5);', '  root->left->right = new Node(6);', '  cout << ""\\nPreorder traversal "";', '  cout << ""\\nPostorder traversal "";']","['Left subtree -> root -> right subtree', '5 -> 12 -> 6 -> 1 -> 9']",[],"['A node carrying data|||Two subtrees|||&&&First, visit all the nodes in the left subtree|||Then the root node|||Visit all the nodes in the right subtree|||Visit root node|||Visit all the nodes in the left subtree|||Visit all the nodes in the right subtree|||Visit all the nodes in the left subtree|||Visit all the nodes in the right subtree|||Visit the root node|||']"
21,['Binary Tree'],"['In this tutorial, you will learn about binary tree and its different types. Also, you will find working examples of binary tree in C, C++, Java and Python.']",[],[],"['Types of Binary Tree', 'Binary Tree Representation', 'Python, Java and C/C++ Examples', 'Binary Tree Applications']","['1. Full Binary Tree', '2. Perfect Binary Tree', '3. Complete Binary Tree', '4. Degenerate or Pathological Tree', '5. Skewed Binary Tree', '6. Balanced Binary Tree']","['//cdn.programiz.com/sites/tutorial2program/files/binary_tree_1.png', '//cdn.programiz.com/sites/tutorial2program/files/full-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/degenerate-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/skewed-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/height-balanced_1.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-tree-representation_0.png']","['data item', 'address of left child', 'address of right child', 'To learn more, please visit full binary tree.', 'To learn more, please visit perfect binary tree.', 'To learn more, please visit complete binary tree.', 'To learn more, please visit balanced binary tree.']","['A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.', 'A complete binary tree is just like a full binary tree, but with two major differences', 'A degenerate or pathological tree is the tree having a single child either left or right.']","['A binary tree is a tree data structure in which each parent node can have at most two children. Each node of a binary tree consists of three items:', 'A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.', 'A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree.', 'It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.', 'A node of a binary tree is represented by a structure containing a data part and two pointers to other structures of the same type.']","['struct node', ' int data;', ' struct node *left;', ' struct node *right;', '# Binary Tree in Python', 'class Node:', '    def __init__(self, key):', '        self.left = None', '        self.right = None', '        self.val = key', '    # Traverse preorder', '        if self.left:', '        if self.right:', '    # Traverse inorder', '    def traverseInOrder(self):', '        if self.left:', '        if self.right:', '    # Traverse postorder', '        if self.left:', '        if self.right:', 'root = Node(1)', 'root.left = Node(2)', 'root.right = Node(3)', 'root.left.left = Node(4)', 'root.traversePreOrder()', 'root.traverseInOrder()', 'root.traversePostOrder()', 'class Node {', '  int key;', '  Node left, right;', '  public Node(int item) {', '  key = item;', '  left = right = null;', 'class BinaryTree {', '  Node root;', '  BinaryTree(int key) {', '  root = new Node(key);', '  BinaryTree() {', '  root = null;', '  if (node != null) {', '  if (node != null) {', '  if (node != null) {', '  tree.root = new Node(1);', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int item;', '  struct node* left;', '  struct node* right;', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  if (root == NULL) return;', '  printf(""%d ->"", root->item);', '  newNode->item = value;', '  newNode->left = NULL;', '  newNode->right = NULL;', '  return newNode;', '  return root->left;', '  return root->right;', 'int main() {', '  insertLeft(root, 2);', '  insertRight(root, 3);', '  insertLeft(root->left, 4);', '  inorderTraversal(root);', '  preorderTraversal(root);', '  postorderTraversal(root);', '#include <stdlib.h>', '#include <iostream>', 'using namespace std;', 'struct node {', '  int data;', '  struct node *left;', '  struct node *right;', '  node->data = data;', '  node->left = NULL;', '  node->right = NULL;', '  return (node);', '  if (temp != NULL) {', '    cout << "" "" << temp->data;', '  if (temp != NULL) {', '    cout << "" "" << temp->data;', '  if (temp != NULL) {', '    cout << "" "" << temp->data;', 'int main() {', '  root->left = newNode(2);', '  root->right = newNode(3);', '  traversePreOrder(root);', '  traverseInOrder(root);', '  traversePostOrder(root);']","[""        print(self.val, end=' ')"", '            self.left.traversePreOrder()', '            self.right.traversePreOrder()', '            self.left.traverseInOrder()', ""        print(self.val, end=' ')"", '            self.right.traverseInOrder()', '    def traversePostOrder(self):', '            self.left.traversePostOrder()', '            self.right.traversePostOrder()', ""        print(self.val, end=' ')"", 'print(""Pre order Traversal: "", end="""")', 'print(""\\nIn order Traversal: "", end="""")', 'print(""\\nPost order Traversal: "", end="""")', '  public void traverseInOrder(Node node) {', '    System.out.print("" "" + node.key);', '    traverseInOrder(node.right);', '  public void traversePostOrder(Node node) {', '    traversePostOrder(node.left);', '    traversePostOrder(node.right);', '    System.out.print("" "" + node.key);', '  public void traversePreOrder(Node node) {', '    System.out.print("" "" + node.key);', '    traversePreOrder(node.left);', '    traversePreOrder(node.right);', '  public static void main(String[] args) {', '  BinaryTree tree = new BinaryTree();', '  tree.root.right = new Node(3);', '  tree.root.left.left = new Node(4);', '  System.out.print(""Pre order Traversal: "");', '  tree.traversePreOrder(tree.root);', '  System.out.print(""\\nIn order Traversal: "");', '  tree.traverseInOrder(tree.root);', '  System.out.print(""\\nPost order Traversal: "");', '  tree.traversePostOrder(tree.root);', 'void inorderTraversal(struct node* root) {', '  inorderTraversal(root->right);', 'void preorderTraversal(struct node* root) {', '  preorderTraversal(root->left);', '  preorderTraversal(root->right);', 'void postorderTraversal(struct node* root) {', '  postorderTraversal(root->left);', '  postorderTraversal(root->right);', 'struct node* createNode(value) {', '  struct node* newNode = malloc(sizeof(struct node));', 'struct node* insertLeft(struct node* root, int value) {', '  root->left = createNode(value);', 'struct node* insertRight(struct node* root, int value) {', '  root->right = createNode(value);', '  struct node* root = createNode(1);', '  printf(""Inorder traversal \\n"");', '  printf(""\\nPreorder traversal \\n"");', '  printf(""\\nPostorder traversal \\n"");', 'struct node *newNode(int data) {', '  struct node *node = (struct node *)malloc(sizeof(struct node));', 'void traversePreOrder(struct node *temp) {', '    traversePreOrder(temp->left);', '    traversePreOrder(temp->right);', 'void traverseInOrder(struct node *temp) {', '    traverseInOrder(temp->left);', '    traverseInOrder(temp->right);', 'void traversePostOrder(struct node *temp) {', '    traversePostOrder(temp->left);', '    traversePostOrder(temp->right);', '  struct node *root = newNode(1);', '  root->left->left = newNode(4);', '  cout << ""preorder traversal: "";', '  cout << ""\\nInorder traversal: "";', '  cout << ""\\nPostorder traversal: "";']",[],[],"[""|||data item|||||||||address of left child|||||||||address of right child||||||For easy and quick access to data|||In router algorithms|||To implement heap data structure|||Syntax tree|||&&&Every level must be completely filled|||All the leaf elements must lean towards the left.|||The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.|||""]"
22,['Full Binary Tree'],"['In this tutorial, you will learn about full binary tree and its different theorems. Also, you will find working examples to check full binary tree in C, C++, Java and Python.']",[],[],"['Full Binary Tree Theorems', 'Python, Java and C/C++ Examples']",[],['//cdn.programiz.com/sites/tutorial2program/files/full-binary-tree_0.png'],['It is also known as a proper binary tree.'],"['A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children.', 'The following code is for checking if a tree is a full binary tree.']",[],"['       l = number of leaves', '      λ = number of levels', '# Creating a node', 'class Node:', '    def __init__(self, item):', '        self.item = item', '        self.leftChild = None', '        self.rightChild = None', '# Checking full binary tree', 'def isFullTree(root):', '    # Tree empty case', '    if root is None:', '        return True', '        return True', '    return False', 'root = Node(1)', 'root.rightChild = Node(3)', 'root.leftChild = Node(2)', 'if isFullTree(root):', 'class Node {', '  int data;', '  Node leftChild, rightChild;', '  Node(int item) {', '  data = item;', 'class BinaryTree {', '  Node root;', '  if (node == null)', '    return true;', '    return true;', '  return false;', '    tree.root = new Node(1);', '    else', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', 'struct Node {', '  int item;', '  struct Node *left, *right;', '  node->item = k;', '  return node;', '  if (root == NULL)', '    return true;', '    return true;', '  return false;', 'int main() {', '  struct Node *root = NULL;', '  root = createNewNode(1);', '  if (isFullBinaryTree(root))', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int key;', '  struct Node *left, *right;', 'struct Node *newNode(char k) {', '  node->key = k;', '  return node;', '  if (root == NULL)', '    return true;', '    return true;', '  return false;', 'int main() {', '  struct Node *root = NULL;', '  root = newNode(1);', '  root->left = newNode(2);', '  root->right = newNode(3);', '  if (isFullBinaryTree(root))']","['Let, i = the number of internal nodes', '       n = be the total number of nodes', '# Checking if a binary tree is a full binary tree in Python', '    # Checking whether child is present', '    if root.leftChild is None and root.rightChild is None:', '    if root.leftChild is not None and root.rightChild is not None:', '        return (isFullTree(root.leftChild) and isFullTree(root.rightChild))', 'root.leftChild.leftChild = Node(4)', 'root.leftChild.rightChild = Node(5)', 'root.leftChild.rightChild.leftChild = Node(6)', 'root.leftChild.rightChild.rightChild = Node(7)', '    print(""The tree is a full binary tree"")', '    print(""The tree is not a full binary tree"")', '  leftChild = rightChild = null;', '  boolean isFullBinaryTree(Node node) {', '  if (node.leftChild == null && node.rightChild == null)', '  if ((node.leftChild != null) && (node.rightChild != null))', '    return (isFullBinaryTree(node.leftChild) && isFullBinaryTree(node.rightChild));', '  public static void main(String args[]) {', '    BinaryTree tree = new BinaryTree();', '    tree.root.leftChild = new Node(2);', '    tree.root.rightChild = new Node(3);', '    tree.root.leftChild.leftChild = new Node(4);', '    tree.root.leftChild.rightChild = new Node(5);', '    tree.root.rightChild.leftChild = new Node(6);', '    tree.root.rightChild.rightChild = new Node(7);', '    if (tree.isFullBinaryTree(tree.root))', '      System.out.print(""The tree is a full binary tree"");', '      System.out.print(""The tree is not a full binary tree"");', 'struct Node *createNewNode(char k) {', '  struct Node *node = (struct Node *)malloc(sizeof(struct Node));', '  node->right = node->left = NULL;', 'bool isFullBinaryTree(struct Node *root) {', '  if (root->left == NULL && root->right == NULL)', '  if ((root->left) && (root->right))', '    return (isFullBinaryTree(root->left) && isFullBinaryTree(root->right));', '  root->left = createNewNode(2);', '  root->right = createNewNode(3);', '  root->left->left = createNewNode(4);', '  root->left->right = createNewNode(5);', '  root->left->right->left = createNewNode(6);', '  root->left->right->right = createNewNode(7);', '    printf(""The tree is a full binary tree\\n"");', '    printf(""The tree is not a full binary tree\\n"");', '  struct Node *node = (struct Node *)malloc(sizeof(struct Node));', '  node->right = node->left = NULL;', 'bool isFullBinaryTree(struct Node *root) {', '  if (root->left == NULL && root->right == NULL)', '  if ((root->left) && (root->right))', '    return (isFullBinaryTree(root->left) && isFullBinaryTree(root->right));', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  root->left->right->left = newNode(6);', '  root->left->right->right = newNode(7);', '    cout << ""The tree is a full binary tree\\n"";', '    cout << ""The tree is not a full binary tree\\n"";']",[],[],['The number of leaves is i + 1.|||The total number of nodes is 2i + 1.|||The number of internal nodes is (n – 1) / 2.|||The number of leaves is (n + 1) / 2.|||The total number of nodes is 2l – 1.|||The number of internal nodes is l – 1.|||The number of leaves is at most 2λ - 1.|||']
23,['Perfect Binary Tree'],"['In this tutorial, you will learn about the perfect binary tree. Also, you will find working examples for checking a perfect binary tree in C, C++, Java and Python.']",[],[],"['Python, Java and C/C++ Examples', 'Perfect Binary Tree Theorems']",[],"['//cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree-rec.png']","['All the internal nodes have a degree of 2.', 'Recursively, a perfect binary tree can be defined as:']",['The following code is for checking whether a tree is a perfect binary tree.'],['A perfect binary tree is a type of binary tree in which every internal node has exactly two child nodes and all the leaf nodes are at the same level.'],"['class newNode:', '    def __init__(self, k):', '        self.key = k', '# Calculate the depth', 'def calculateDepth(node):', '    d = 0', '    while (node is not None):', '        d += 1', '        node = node.left', '    return d', '    if (root is None):', '        return True', '        return False', 'root = None', 'root = newNode(1)', 'root.left = newNode(2)', 'root.right = newNode(3)', 'root.left.left = newNode(4)', 'root.left.right = newNode(5)', 'class PerfectBinaryTree {', '  static class Node {', '    int key;', '    Node left, right;', '    int d = 0;', '    while (node != null) {', '      d++;', '      node = node.left;', '    return d;', '    if (root == null)', '      return true;', '      return (d == level + 1);', '      return false;', '    int d = depth(root);', '  static Node newNode(int k) {', '    Node node = new Node();', '    node.key = k;', '    node.right = null;', '    node.left = null;', '    return node;', '    Node root = null;', '    root = newNode(1);', '    root.left = newNode(2);', '    root.right = newNode(3);', '    else', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int data;', '  struct node *left;', '  struct node *right;', '  node->data = data;', '  node->left = NULL;', '  node->right = NULL;', '  return (node);', 'int depth(struct node *node) {', '  int d = 0;', '  while (node != NULL) {', '    d++;', '    node = node->left;', '  return d;', '  if (root == NULL)', '    return true;', '    return (d == level + 1);', '    return false;', '  int d = depth(root);', 'int main() {', '  struct node *root = NULL;', '  root = newnode(1);', '  root->left = newnode(2);', '  root->right = newnode(3);', '  if (is_Perfect(root))', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int key;', '  struct Node *left, *right;', 'int depth(Node *node) {', '  int d = 0;', '  while (node != NULL) {', '    d++;', '    node = node->left;', '  return d;', '  if (root == NULL)', '    return true;', '    return (d == level + 1);', '    return false;', 'bool isPerfect(Node *root) {', '  int d = depth(root);', '  return isPerfectR(root, d);', 'struct Node *newNode(int k) {', '  node->key = k;', '  return node;', 'int main() {', '  struct Node *root = NULL;', '  root = newNode(1);', '  root->left = newNode(2);', '  root->right = newNode(3);', '  if (isPerfect(root))']","['# Checking if a binary tree is a perfect binary tree in Python', '        self.right = self.left = None', '# Check if the tree is perfect binary tree', 'def is_perfect(root, d, level=0):', '    # Check if the tree is empty', '    # Check the presence of trees', '    if (root.left is None and root.right is None):', '    if (root.left is None or root.right is None):', '    return (is_perfect(root.left, d, level + 1) and', '            is_perfect(root.right, d, level + 1))', 'if (is_perfect(root, calculateDepth(root))):', '    print(""The tree is a perfect binary tree"")', '    print(""The tree is not a perfect binary tree"")', '  static boolean is_perfect(Node root, int d, int level) {', '    if (root.left == null && root.right == null)', '    if (root.left == null || root.right == null)', '    return is_perfect(root.left, d, level + 1) && is_perfect(root.right, d, level + 1);', '  static boolean is_Perfect(Node root) {', '    return is_perfect(root, d, 0);', '  public static void main(String args[]) {', '    root.left.left = newNode(4);', '    root.left.right = newNode(5);', '    if (is_Perfect(root) == true)', '      System.out.println(""The tree is a perfect binary tree"");', '      System.out.println(""The tree is not a perfect binary tree"");', 'struct node *newnode(int data) {', '  struct node *node = (struct node *)malloc(sizeof(struct node));', 'bool is_perfect(struct node *root, int d, int level) {', '  if (root->left == NULL && root->right == NULL)', '  if (root->left == NULL || root->right == NULL)', '  return is_perfect(root->left, d, level + 1) &&', '       is_perfect(root->right, d, level + 1);', 'bool is_Perfect(struct node *root) {', '  return is_perfect(root, d, 0);', '  root->left->left = newnode(4);', '  root->left->right = newnode(5);', '  root->right->left = newnode(6);', '    printf(""The tree is a perfect binary tree\\n"");', '    printf(""The tree is not a perfect binary tree\\n"");', 'bool isPerfectR(struct Node *root, int d, int level = 0) {', '  if (root->left == NULL && root->right == NULL)', '  if (root->left == NULL || root->right == NULL)', '  return isPerfectR(root->left, d, level + 1) &&', '       isPerfectR(root->right, d, level + 1);', '  node->right = node->left = NULL;', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  root->right->left = newNode(6);', '    cout << ""The tree is a perfect binary tree\\n"";', '    cout << ""The tree is not a perfect binary tree\\n"";']",[],[],"['If a single node has no children, it is a perfect binary tree of height h = 0,|||If a node has h > 0, it is a perfect binary tree if both of its subtrees are of height h - 1 and are non-overlapping.|||A perfect binary tree of height h has 2h + 1 – 1 node.|||A perfect binary tree with n nodes has height log(n + 1) – 1 = Θ(ln(n)).|||A perfect binary tree of height h has 2h leaf nodes.|||The average depth of a node in a perfect binary tree is Θ(ln(n)).|||']"
24,['Complete Binary Tree'],"['In this tutorial, you will learn about a complete binary tree and its different types. Also, you will find working examples of a complete binary tree in C, C++, Java and Python.']",[],[],"['Full Binary Tree vs Complete Binary Tree', 'How a Complete Binary Tree is Created?', 'Python, Java and C/C++ Examples', 'Relationship between array indexes and tree element', 'Complete Binary Tree Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/comparison-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/comparison-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/comparison-3_0.png', '//cdn.programiz.com/sites/tutorial2program/files/comparison-4.png', '//cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree-creation-1.png', '//cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree-creation-2.png', '//cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree-creation-3.png']","[""Let's test it out,""]","['A complete binary tree is just like a full binary tree, but with two major differences', 'A complete binary tree has an interesting property that we can use to find the children and parents of any node.', 'Let us also confirm that the rules hold for finding parent of any node']","['A complete binary tree is a binary tree in which all the levels are completely filled except possibly the lowest one, which is filled from the left.', 'If the index of any element in the array is i, the element in the index 2i+1 will become the left child and element in 2i+2 index will become the right child. Also, the parent of any element at index i is given by the lower bound of (i-1)/2.', 'Understanding this mapping of array indexes to tree positions is critical to understanding how the Heap Data Structure works and how it is used to implement Heap Sort.']","['class Node:', '    def __init__(self, item):', '        self.item = item', '        self.left = None', '        self.right = None', '# Count the number of nodes', 'def count_nodes(root):', '    if root is None:', '        return 0', '    if root is None:', '        return True', '    if index >= numberNodes:', '        return False', 'root = Node(1)', 'root.left = Node(2)', 'root.right = Node(3)', 'root.left.left = Node(4)', 'root.left.right = Node(5)', 'root.right.left = Node(6)', 'node_count = count_nodes(root)', 'index = 0', 'class Node {', '  int data;', '  Node left, right;', '  Node(int item) {', '    data = item;', '    left = right = null;', 'class BinaryTree {', '  Node root;', '    if (root == null)', '      return (0);', '    if (root == null)', '      return true;', '    if (index >= numberNodes)', '      return false;', '    tree.root = new Node(1);', '    int index = 0;', '    else', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', 'struct Node {', '  int key;', '  struct Node *left, *right;', 'struct Node *newNode(char k) {', '  node->key = k;', '  return node;', '  if (root == NULL)', '    return (0);', '  if (root == NULL)', '    return true;', '  if (index >= numberNodes)', '    return false;', 'int main() {', '  struct Node *root = NULL;', '  root = newNode(1);', '  root->left = newNode(2);', '  root->right = newNode(3);', '  int index = 0;', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int key;', '  struct Node *left, *right;', 'struct Node *newNode(char k) {', '  node->key = k;', '  return node;', '  if (root == NULL)', '    return (0);', '  if (root == NULL)', '    return true;', '  if (index >= numberNodes)', '    return false;', 'int main() {', '  struct Node *root = NULL;', '  root = newNode(1);', '  root->left = newNode(2);', '  root->right = newNode(3);', '  int index = 0;']","['# Checking if a binary tree is a complete binary tree in C', '    return (1 + count_nodes(root.left) + count_nodes(root.right))', '# Check if the tree is complete binary tree', 'def is_complete(root, index, numberNodes):', '    # Check if the tree is empty', '    return (is_complete(root.left, 2 * index + 1, numberNodes)', '            and is_complete(root.right, 2 * index + 2, numberNodes))', 'if is_complete(root, index, node_count):', '    print(""The tree is a complete binary tree"")', '    print(""The tree is not a complete binary tree"")', '  int countNumNodes(Node root) {', '    return (1 + countNumNodes(root.left) + countNumNodes(root.right));', '  boolean checkComplete(Node root, int index, int numberNodes) {', '    return (checkComplete(root.left, 2 * index + 1, numberNodes)', '        && checkComplete(root.right, 2 * index + 2, numberNodes));', '  public static void main(String args[]) {', '    BinaryTree tree = new BinaryTree();', '    tree.root.left = new Node(2);', '    tree.root.right = new Node(3);', '    tree.root.left.right = new Node(5);', '    tree.root.left.left = new Node(4);', '    tree.root.right.left = new Node(6);', '    int node_count = tree.countNumNodes(tree.root);', '    if (tree.checkComplete(tree.root, index, node_count))', '      System.out.println(""The tree is a complete binary tree"");', '      System.out.println(""The tree is not a complete binary tree"");', '  struct Node *node = (struct Node *)malloc(sizeof(struct Node));', '  node->right = node->left = NULL;', 'int countNumNodes(struct Node *root) {', '  return (1 + countNumNodes(root->left) + countNumNodes(root->right));', 'bool checkComplete(struct Node *root, int index, int numberNodes) {', '  return (checkComplete(root->left, 2 * index + 1, numberNodes) && checkComplete(root->right, 2 * index + 2, numberNodes));', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  root->right->left = newNode(6);', '  int node_count = countNumNodes(root);', '  if (checkComplete(root, index, node_count))', '    printf(""The tree is a complete binary tree\\n"");', '    printf(""The tree is not a complete binary tree\\n"");', '  struct Node *node = (struct Node *)malloc(sizeof(struct Node));', '  node->right = node->left = NULL;', 'int countNumNodes(struct Node *root) {', '  return (1 + countNumNodes(root->left) + countNumNodes(root->right));', 'bool checkComplete(struct Node *root, int index, int numberNodes) {', '  return (checkComplete(root->left, 2 * index + 1, numberNodes) && checkComplete(root->right, 2 * index + 2, numberNodes));', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  root->right->left = newNode(6);', '  int node_count = countNumNodes(root);', '  if (checkComplete(root, index, node_count))', '    cout << ""The tree is a complete binary tree\\n"";', '    cout << ""The tree is not a complete binary tree\\n"";']","['Left child of 1 (index 0)', '= element in (2*0+1) index ', '= element in 1 index ', '= 12', 'Right child of 1', '= element in (2*0+2) index', '= element in 2 index ', '= 9', 'Similarly,', 'Left child of 12 (index 1)', '= element in (2*1+1) index', '= element in 3 index', '= 5', 'Right child of 12', '= element in (2*1+2) index', '= element in 4 index', '= 6', 'Parent of 9 (position 2) ', '= (2-1)/2 ', '= ½ ', '= 0.5', '~ 0 index ', '= 1', 'Parent of 12 (position 1) ', '= (1-1)/2 ', '= 0 index ', '= 1']",[],"[""Heap-based data structures|||Heap sort|||&&&All the leaf elements must lean towards the left.|||The last leaf element might not have a right sibling i.e. a complete binary tree doesn't have to be a full binary tree.|||Select the first element of the list to be the root node. (no. of elements on level-I: 1)|||Select the first element as root|||Put the second element as a left child of the root node and the third element as the right child. (no. of elements on level-II: 2)|||12 as a left child and 9 as a right child|||Put the next two elements as children of the left node of the second level. Again, put the next two elements as children of the right node of the second level (no. of elements on level-III: 4) elements).|||Keep repeating until you reach the last element.|||5 as a left child and 6 as a right child|||""]"
25,['Balanced Binary Tree'],"['In this tutorial, you will learn about a balanced binary tree and its different types. Also, you will find working examples of a balanced binary tree in C, C++, Java and Python.']",[],[],"['Python, Java and C/C++ Examples', 'Balanced Binary Tree Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/balanced-binary-tree.png', '//cdn.programiz.com/sites/tutorial2program/files/unbalanced-binary-tree.png']",[],['The following code is for checking whether a tree is height-balanced.'],"['A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.', 'To learn more about the height of a tree/node, visit Tree Data Structure.Following are the conditions for a height-balanced binary tree:']","['class Node:', '    def __init__(self, data):', '        self.data = data', 'class Height:', '    def __init__(self):', '        self.height = 0', '    left_height = Height()', '    right_height = Height()', '    if root is None:', '        return True', '        return l and r', '    return False', 'height = Height()', 'root = Node(1)', 'root.left = Node(2)', 'root.right = Node(3)', 'root.left.left = Node(4)', 'root.left.right = Node(5)', 'class Node {', '  int data;', '  Node left, right;', '  Node(int d) {', '    data = d;', '    left = right = null;', 'class Height {', '  int height = 0;', 'class BinaryTree {', '  Node root;', '    if (root == null) {', '      height.height = 0;', '      return true;', '      return false;', '    else', '      return l && r;', '    tree.root = new Node(1);', '    else', '#include <stdio.h>', '#include <stdlib.h>', '#define bool int', 'struct node {', '  int item;', '  struct node *left;', '  struct node *right;', '  node->item = item;', '  node->left = NULL;', '  node->right = NULL;', '  return (node);', '  int l = 0, r = 0;', '  if (root == NULL) {', '    *height = 0;', '    return 1;', '    return 0;', '    return l && r;', 'int main() {', '  int height = 0;', '  root->left = newNode(2);', '  root->right = newNode(3);', '#include ', 'using namespace std;', '#define bool int', 'class node {', '   public:', '  int item;', '  node *left;', '  node *right;', 'node *newNode(int item) {', '  node *Node = new node();', '  Node->item = item;', '  Node->left = NULL;', '  Node->right = NULL;', '  return (Node);', '  int l = 0, r = 0;', '  if (root == NULL) {', '    *height = 0;', '    return 1;', '    return 0;', '    return l && r;', 'int main() {', '  int height = 0;', '  node *root = newNode(1);', '  root->left = newNode(2);', '  root->right = newNode(3);']","['# Checking if a binary tree is height balanced in Python', '        self.left = self.right = None', 'def isHeightBalanced(root, height):', '    l = isHeightBalanced(root.left, left_height)', '    r = isHeightBalanced(root.right, right_height)', '    height.height = max(left_height.height, right_height.height) + 1', '    if abs(left_height.height - right_height.height) <= 1:', 'if isHeightBalanced(root, height):', ""    print('The tree is balanced')"", ""    print('The tree is not balanced')"", '  boolean checkHeightBalance(Node root, Height height) {', '    Height leftHeighteight = new Height(), rightHeighteight = new Height();', '    boolean l = checkHeightBalance(root.left, leftHeighteight);', '    boolean r = checkHeightBalance(root.right, rightHeighteight);', '    int leftHeight = leftHeighteight.height, rightHeight = rightHeighteight.height;', '    height.height = (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;', '    if ((leftHeight - rightHeight >= 2) || (rightHeight - leftHeight >= 2))', '  public static void main(String args[]) {', '    Height height = new Height();', '    BinaryTree tree = new BinaryTree();', '    tree.root.left = new Node(2);', '    tree.root.right = new Node(3);', '    tree.root.left.left = new Node(4);', '    tree.root.left.right = new Node(5);', '    if (tree.checkHeightBalance(tree.root, height))', '      System.out.println(""The tree is balanced"");', '      System.out.println(""The tree is not balanced"");', 'struct node *newNode(int item) {', '  struct node *node = (struct node *)malloc(sizeof(struct node));', 'bool checkHeightBalance(struct node *root, int *height) {', '  int leftHeight = 0, rightHeight = 0;', '  l = checkHeightBalance(root->left, &leftHeight);', '  r = checkHeightBalance(root->right, &rightHeight);', '  *height = (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;', '  if ((leftHeight - rightHeight >= 2) || (rightHeight - leftHeight >= 2))', '  struct node *root = newNode(1);', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  if (checkHeightBalance(root, &height))', '    printf(""The tree is balanced"");', '    printf(""The tree is not balanced"");', 'bool checkHeightBalance(node *root, int *height) {', '  int leftHeight = 0, rightHeight = 0;', '  l = checkHeightBalance(root->left, &leftHeight);', '  r = checkHeightBalance(root->right, &rightHeight);', '  *height = (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;', '  if (std::abs(leftHeight - rightHeight >= 2))', '  root->left->left = newNode(4);', '  root->left->right = newNode(5);', '  if (checkHeightBalance(root, &height))', '    cout << ""The tree is balanced"";', '    cout << ""The tree is not balanced"";']",[],[],['AVL tree|||Balanced Binary Search Tree|||&&&difference between the left and the right subtree for any node is not more than one|||the left subtree is balanced|||the right subtree is balanced|||']
26,['Binary Search Tree(BST)'],"['In this tutorial, you will learn how Binary Search Tree works. Also, you will find working examples of Binary Search Tree in C, C++, Java and Python.']",[],[],"['Search Operation', 'Insert Operation', 'Deletion Operation', 'Python, Java and C/C++ Examples', 'Binary Search Tree Complexities', 'Binary Search Tree Applications']","['Case I', 'Case II', 'Case III', 'Time Complexity', 'Space Complexity']","['//cdn.programiz.com/sites/tutorial2program/files/bst-vs-not-bst.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-search-1.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-search-2.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-search-3.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-search-1.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-search-5.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-insert-1.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-insert-2.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-insert-3.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-insert-4.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-insert-5.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-1.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-2.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-3.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-4.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-5.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-6.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-6.png', '//cdn.programiz.com/sites/tutorial2program/files/bst-delete-8.png']","['Algorithm:', 'Let us try to visualize this with a diagram.', 'Algorithm:', 'Here, n is the number of nodes in the tree.', 'The space complexity for all the operations is O(n).']","['Binary search tree is a data structure that quickly allows us to maintain a sorted list of numbers.', 'The properties that separate a binary search tree from a regular binary tree is', 'There are two basic operations that you can perform on a binary search tree:', 'If the value is found, we return the value so that it gets propagated in each recursion step as shown in the image below.', ""The algorithm isn't as simple as it looks. Let's try to visualize how we add a number to an existing BST."", ""This makes sure that as we move back up the tree, the other node connections aren't changed."", 'There are three cases for deleting a node from a binary search tree.', 'In the first case, the node to be deleted is the leaf node. In such a case, simply delete the node from the tree.', 'In the second case, the node to be deleted lies has a single child node. In such a case follow the steps below:', 'In the third case, the node to be deleted has two children. In such a case follow the steps below:']","['The binary tree on the right isn\'t a binary search tree because the right subtree of the node ""3"" contains a value smaller than it.', 'The algorithm depends on the property of BST that if each left subtree has values below root and each right subtree has values above the root.', 'If the value is below the root, we can say for sure that the value is not in the right subtree; we need to only search in the left subtree and if the value is above the root, we can say for sure that the value is not in the left subtree; we need to only search in the right subtree.', 'If you might have noticed, we have called return search(struct node*) four times. When we return either the new node or NULL, the value gets returned again and again until search(root) returns the final result.', 'If the value is not found, we eventually reach the left or right child of a leaf node which is NULL and it gets propagated and returned.', 'Inserting a value in the correct position is similar to searching because we try to maintain the rule that the left subtree is lesser than root and the right subtree is larger than root.', 'We keep going to either right subtree or left subtree depending on the value and when we reach a point left or right subtree is null, we put the new node there.', 'We have attached the node but we still have to exit from the function without doing any damage to the rest of the tree. This is where the return node; at the end comes in handy. In the case of NULL, the newly created node is returned and attached to the parent node, otherwise the same node is returned without any change as we go up until we return to the root.']","['If root == NULL ', '    return NULL;', 'If number == root->data ', '    return root->data;', 'If number < root->data ', '    return search(root->left)', 'If number > root->data ', '    return search(root->right)', 'If node == NULL ', '    return createNode(data)', 'if (data < node->data)', 'else if (data > node->data)', 'return node;', '# Create a node', 'class Node:', '    def __init__(self, key):', '        self.key = key', '        self.left = None', '        self.right = None', '# Inorder traversal', 'def inorder(root):', '    if root is not None:', '        # Traverse left', '        inorder(root.left)', '        # Traverse root', '        # Traverse right', '        inorder(root.right)', '# Insert a node', 'def insert(node, key):', '    if node is None:', '        return Node(key)', '    if key < node.key:', '    else:', '    return node', '# Find the inorder successor', 'def minValueNode(node):', '    current = node', '    # Find the leftmost leaf', '        current = current.left', '    return current', '# Deleting a node', 'def deleteNode(root, key):', '    if root is None:', '        return root', '    if key < root.key:', '    elif(key > root.key):', '    else:', '        if root.left is None:', '            temp = root.right', '            root = None', '            return temp', '            temp = root.left', '            root = None', '            return temp', '        root.key = temp.key', '    return root', 'root = None', 'root = insert(root, 8)', 'root = insert(root, 3)', 'root = insert(root, 1)', 'root = insert(root, 6)', 'root = insert(root, 7)', 'root = insert(root, 10)', 'root = insert(root, 14)', 'root = insert(root, 4)', 'inorder(root)', 'print(""\\nDelete 10"")', 'root = deleteNode(root, 10)', 'inorder(root)', 'class BinarySearchTree {', '  class Node {', '    int key;', '    Node left, right;', '    public Node(int item) {', '      key = item;', '      left = right = null;', '  Node root;', '  BinarySearchTree() {', '    root = null;', '  void insert(int key) {', '    if (root == null) {', '      root = new Node(key);', '      return root;', '    if (key < root.key)', '    else if (key > root.key)', '    return root;', '  void inorder() {', '    inorderRec(root);', '  void inorderRec(Node root) {', '    if (root != null) {', '      inorderRec(root.left);', '      inorderRec(root.right);', '  void deleteKey(int key) {', '    if (root == null)', '      return root;', '    if (key < root.key)', '    else if (key > root.key)', '    else {', '      if (root.left == null)', '        return root.right;', '        return root.left;', '    return root;', '  int minValue(Node root) {', '    int minv = root.key;', '      minv = root.left.key;', '      root = root.left;', '    return minv;', '    tree.insert(8);', '    tree.insert(3);', '    tree.insert(1);', '    tree.insert(6);', '    tree.insert(7);', '    tree.insert(10);', '    tree.insert(14);', '    tree.insert(4);', '    tree.inorder();', '    tree.deleteKey(10);', '    tree.inorder();', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int key;', '  struct node *left, *right;', '  temp->key = item;', '  return temp;', '  if (root != NULL) {', '    inorder(root->left);', '    inorder(root->right);', '  if (key < node->key)', '  return node;', '  struct node *current = node;', '    current = current->left;', '  return current;', '  if (key < root->key)', '  else if (key > root->key)', '  else {', '    if (root->left == NULL) {', '      free(root);', '      return temp;', '      free(root);', '      return temp;', '    root->key = temp->key;', '  return root;', 'int main() {', '  struct node *root = NULL;', '  root = insert(root, 8);', '  root = insert(root, 3);', '  root = insert(root, 1);', '  root = insert(root, 6);', '  root = insert(root, 7);', '  root = insert(root, 10);', '  root = insert(root, 14);', '  root = insert(root, 4);', '  inorder(root);', '  root = deleteNode(root, 10);', '  inorder(root);', '#include <iostream>', 'using namespace std;', 'struct node {', '  int key;', '  struct node *left, *right;', '  temp->key = item;', '  return temp;', '  if (root != NULL) {', '    inorder(root->left);', '    inorder(root->right);', '  if (key < node->key)', '  return node;', '  struct node *current = node;', '    current = current->left;', '  return current;', '  if (key < root->key)', '  else if (key > root->key)', '  else {', '    if (root->left == NULL) {', '      free(root);', '      return temp;', '      free(root);', '      return temp;', '    root->key = temp->key;', '  return root;', 'int main() {', '  struct node *root = NULL;', '  root = insert(root, 8);', '  root = insert(root, 3);', '  root = insert(root, 1);', '  root = insert(root, 6);', '  root = insert(root, 7);', '  root = insert(root, 10);', '  root = insert(root, 14);', '  root = insert(root, 4);', '  inorder(root);', '  root = deleteNode(root, 10);', '  inorder(root);']","['    node->left  = insert(node->left, data);', '    node->right = insert(node->right, data);  ', '# Binary Search Tree operations in Python', '        print(str(root.key) + ""->"", end=\' \')', '    # Return a new node if the tree is empty', '    # Traverse to the right place and insert the node', '        node.left = insert(node.left, key)', '        node.right = insert(node.right, key)', '    while(current.left is not None):', '    # Return if the tree is empty', '    # Find the node to be deleted', '        root.left = deleteNode(root.left, key)', '        root.right = deleteNode(root.right, key)', '        # If the node is with only one child or no child', '        elif root.right is None:', '        # If the node has two children,', '        # place the inorder successor in position of the node to be deleted', '        temp = minValueNode(root.right)', '        # Delete the inorder successor', '        root.right = deleteNode(root.right, temp.key)', 'print(""Inorder traversal: "", end=\' \')', 'print(""Inorder traversal: "", end=\' \')', '    root = insertKey(root, key);', '  Node insertKey(Node root, int key) {', '      root.left = insertKey(root.left, key);', '      root.right = insertKey(root.right, key);', '      System.out.print(root.key + "" -> "");', '    root = deleteRec(root, key);', '  Node deleteRec(Node root, int key) {', '      root.left = deleteRec(root.left, key);', '      root.right = deleteRec(root.right, key);', '      else if (root.right == null)', '      root.key = minValue(root.right);', '      root.right = deleteRec(root.right, root.key);', '  public static void main(String[] args) {', '    BinarySearchTree tree = new BinarySearchTree();', '    System.out.print(""Inorder traversal: "");', '    System.out.println(""\\n\\nAfter deleting 10"");', '    System.out.print(""Inorder traversal: "");', 'struct node *newNode(int item) {', '  struct node *temp = (struct node *)malloc(sizeof(struct node));', '  temp->left = temp->right = NULL;', 'void inorder(struct node *root) {', '    printf(""%d -> "", root->key);', 'struct node *insert(struct node *node, int key) {', '  if (node == NULL) return newNode(key);', '    node->left = insert(node->left, key);', '    node->right = insert(node->right, key);', 'struct node *minValueNode(struct node *node) {', '  while (current && current->left != NULL)', 'struct node *deleteNode(struct node *root, int key) {', '  if (root == NULL) return root;', '    root->left = deleteNode(root->left, key);', '    root->right = deleteNode(root->right, key);', '      struct node *temp = root->right;', '    } else if (root->right == NULL) {', '      struct node *temp = root->left;', '    struct node *temp = minValueNode(root->right);', '    root->right = deleteNode(root->right, temp->key);', '  printf(""Inorder traversal: "");', '  printf(""\\nAfter deleting 10\\n"");', '  printf(""Inorder traversal: "");', 'struct node *newNode(int item) {', '  struct node *temp = (struct node *)malloc(sizeof(struct node));', '  temp->left = temp->right = NULL;', 'void inorder(struct node *root) {', '    cout << root->key << "" -> "";', 'struct node *insert(struct node *node, int key) {', '  if (node == NULL) return newNode(key);', '    node->left = insert(node->left, key);', '    node->right = insert(node->right, key);', 'struct node *minValueNode(struct node *node) {', '  while (current && current->left != NULL)', 'struct node *deleteNode(struct node *root, int key) {', '  if (root == NULL) return root;', '    root->left = deleteNode(root->left, key);', '    root->right = deleteNode(root->right, key);', '      struct node *temp = root->right;', '    } else if (root->right == NULL) {', '      struct node *temp = root->left;', '    struct node *temp = minValueNode(root->right);', '    root->right = deleteNode(root->right, temp->key);', '  cout << ""Inorder traversal: "";', '  cout << ""\\nAfter deleting 10\\n"";', '  cout << ""Inorder traversal: "";']",[],['peration|||Best Case Complexity|||Average Case Complexity|||Worst Case Complexity&&&earch|||O(log n)|||O(log n)|||O(n)&&&nsertion|||O(log n)|||O(log n)|||O(n)&&&eletion|||O(log n)|||O(log n)|||O(n)'],['It is called a binary tree because each tree node has a maximum of two children.|||It is called a search tree because it can be used to search for the presence of a number in O(log(n)) time.|||&&&All nodes of left subtree are less than the root node|||All nodes of right subtree are more than the root node|||Both subtrees of each node are also BSTs i.e. they have the above two properties|||Replace that node with its child node.|||Remove the child node from its original position.|||Get the inorder successor of that node.|||Replace the node with the inorder successor.|||Remove the inorder successor from its original position.|||In multilevel indexing in the database|||For dynamic sorting|||For managing virtual memory areas in Unix kernel|||']
27,['AVL Tree'],"['In this tutorial, you will learn  what an avl tree is. Also, you will find working examples of various operations performed on an avl tree in C, C++, Java and Python.']",[],[],"['Balance Factor', 'Operations on an AVL tree', 'Rotating the subtrees in an AVL Tree', 'Algorithm to insert a newNode', 'Algorithm to Delete a node', 'Python, Java and C/C++ Examples', 'Complexities of Different Operations on an AVL Tree', 'AVL Tree Applications']","['Left Rotate', 'Right Rotate', 'Left-Right and Right-Left Rotate']","['//cdn.programiz.com/sites/tutorial2program/files/avl-tree-final-tree-1_0_2.png', '//cdn.programiz.com/sites/tutorial2program/files/avl-tree_leftrotate-1.png', '//cdn.programiz.com/cdn/farfuture/rOar-QIMS2mHWi2sn4MmQOdRpGZhpPMQa7lZr_lsZfA/mtime:1590638929/sites/tutorial2program/files/avl-tree_leftrotate-2.png', '//cdn.programiz.com/cdn/farfuture/7aD1qWbw1WyZulO94QcY-hYFfGAaZkLk9RFCvLcLBRM/mtime:1590638934/sites/tutorial2program/files/avl-tree_leftrotate-3.png', '//cdn.programiz.com/cdn/farfuture/O9aADWiuEklv2f5McEZmst1tlFIWiuXUMhAnFgPd1uA/mtime:1590638939/sites/tutorial2program/files/avl-tree_leftrotate-4.png', '//cdn.programiz.com/cdn/farfuture/12-orMUBx_3UtNyltuXsoa_L2XHI35EkedbeZAY3pbc/mtime:1590638944/sites/tutorial2program/files/avl-tree_rightrotate-1.png', '//cdn.programiz.com/cdn/farfuture/tUD9xPE1yKsjUD7GrKeHS5-bvbbpPZRj-QUiVLBiAVo/mtime:1590638951/sites/tutorial2program/files/avl-tree_rightrotate-2.png', '//cdn.programiz.com/cdn/farfuture/AeeJj9zzvQCCkBVeGi0RQ64uHDlGlRTCRJhVRYTJHgc/mtime:1590638957/sites/tutorial2program/files/avl-tree_rightrotate-3.png', '//cdn.programiz.com/cdn/farfuture/yr1WZ-vC3rZklwZ-zs9Ox0gKOrvniclffrU9zd96coE/mtime:1590638963/sites/tutorial2program/files/avl-tree_rightrotate-4.png', '//cdn.programiz.com/cdn/farfuture/-azcNvOPWv7wEnEzT3h227dYtZBlAL8CXtHdwXenr1c/mtime:1590639276/sites/tutorial2program/files/avl-tree-leftright-rotate-1.png', '//cdn.programiz.com/cdn/farfuture/gZrKUeMiHusFL-lb6gAaMCfK_edFDj64Qi3MwlYJ_jw/mtime:1590639281/sites/tutorial2program/files/avl-tree-leftright-rotate-2.png', '//cdn.programiz.com/cdn/farfuture/flq1MTO6SBcWdXIUda_BY4yhf9BLPRf7MT4Ip79vYF4/mtime:1590639294/sites/tutorial2program/files/avl-tree-rightleft-rotate-1.png', '//cdn.programiz.com/cdn/farfuture/MHtUIZ6EqUmgcC3exARGsdRiOFmENzCH-i_solZWi1g/mtime:1590639315/sites/tutorial2program/files/avl-tree-rightleft-rotate-2.png', '//cdn.programiz.com/cdn/farfuture/os7LYnnoAF-L43b72SHX8d5A5wswB3kmrItfdEEZ_l4/mtime:1590641583/sites/tutorial2program/files/avl-tree_initial-tree.png', '//cdn.programiz.com/cdn/farfuture/83QnjS5n5s5lirRaNDaz-j7Z4wuSMyzCy5JqTtnS_DY/mtime:1590641675/sites/tutorial2program/files/avl-tree_newnode.png', '//cdn.programiz.com/cdn/farfuture/FpHam25V20lbxh3NAwAnSAla2NbWOj9rPI6bFDrPUbo/mtime:1590641542/sites/tutorial2program/files/avl-tree_find-position.png', '//cdn.programiz.com/cdn/farfuture/cqWklRHIE-bR-CK0vOfdr5ml6hXURz-5YhLxpQT8bIM/mtime:1590641621/sites/tutorial2program/files/avl-tree_insert.png', '//cdn.programiz.com/cdn/farfuture/6duidjDetnH-DT3WdMw29n1wgG76GIJ_yIevbCSdsrY/mtime:1590641705/sites/tutorial2program/files/avl-tree_update-bf.png', '//cdn.programiz.com/cdn/farfuture/D4lZ8JHjdLg4aJxD6qmgAn7ZL83fPE5B3fIGbuLZB-E/mtime:1590641396/sites/tutorial2program/files/avl-tree_balance1.png', '//cdn.programiz.com/cdn/farfuture/_DTFoJhzbxIBEo6xGqFvLawAyJhzCY2UwRzfH68hcGE/mtime:1590641444/sites/tutorial2program/files/avl-tree_balnce2.png', '//cdn.programiz.com/cdn/farfuture/tcEU8kqtoLVPZaZPsKGMyctiKuRsDRfcJq0NRUHHorE/mtime:1590641505/sites/tutorial2program/files/avl-tree_final-tree.png', '//cdn.programiz.com/cdn/farfuture/fIOlfxQXQuwR8P1eEBkuj1i22A0BuyurJjeB1m6H7So/mtime:1590642405/sites/tutorial2program/files/avl-tree_nodeToBeDeleted_0.png', '//cdn.programiz.com/cdn/farfuture/rGgRi5ikeoIfyMY124mYlCKq0KkpgsgtNRKzyo9-zkk/mtime:1590642295/sites/tutorial2program/files/avl-tree_successor_0.png', '//cdn.programiz.com/cdn/farfuture/ia6iJp_nIYa-HppuHI8Qy9J-b3CIVF375u4j9ZgqTFs/mtime:1590642336/sites/tutorial2program/files/avl-tree_substitute_0.png', '//cdn.programiz.com/cdn/farfuture/z-sGX0OjTnFqVIDMlgIg2NhNEX8WMXdBn3zYgHoGcOc/mtime:1590642368/sites/tutorial2program/files/avl-tree_removal_0.png', '//cdn.programiz.com/cdn/farfuture/DMAk01g-vB7ieYsXfI5mEakGaKqBfjyy1sEAsyf1srs/mtime:1590642260/sites/tutorial2program/files/avl-tree_upatebf_0.png', '//cdn.programiz.com/cdn/farfuture/f_AwZ2V47wJ6s-aG2FTnrpo0PbJs_kAk5Dr94yE-Dbc/mtime:1590642480/sites/tutorial2program/files/avl-tree_balance_0.png', '//cdn.programiz.com/cdn/farfuture/pEgZOHxHEvMlvh7uhdFR0cezl0wvyvZF57ucZppJyuA/mtime:1588678900/sites/tutorial2program/files/avl-tree-final-tree-1_0_2.png']","['An example of a balanced avl tree is:', 'Various operations that can be performed on an AVL tree are:', 'There are two types of rotations:', 'Algorithm']","['AVL tree got its name after its inventor Georgy Adelson-Velsky and Landis.', 'Balance Factor = (Height of Left Subtree - Height of Right Subtree) or (Height of Right Subtree - Height of Left Subtree)', 'In rotation operation, the positions of the nodes of a subtree are interchanged.', 'In left-rotation, the arrangement of the nodes on the right is transformed into the arrangements on the left node.', 'In left-rotation, the arrangement of the nodes on the left is transformed into the arrangements on the right node.', 'In left-right rotation, the arrangements are first shifted to the left and then to the right.', 'In right-left rotation, the arrangements are first shifted to the right and then to the left.', 'A newNode is always inserted as a leaf node with balance factor equal to 0.']","['AVL tree is a self-balancing binary search tree in which each node maintains extra information called a balance factor whose value is either -1, 0 or +1.', 'Balance factor of a node in an AVL tree is the difference between the height of the left subtree and that of the right subtree of that node.', 'The self balancing property of an avl tree is maintained by the balance factor. The value of balance factor should always be -1, 0 or +1.', 'A node is always deleted as a leaf node. After deleting a node, the balance factors of the nodes get changed. In order to rebalance the balance factor, suitable rotations are performed.']","['import sys', '# Create a tree node', 'class TreeNode(object):', '    def __init__(self, key):', '        self.key = key', '        self.left = None', '        self.right = None', '        self.height = 1', 'class AVLTree(object):', '        if not root:', '        elif key < root.key:', '        else:', '        if balanceFactor > 1:', '            else:', '        if balanceFactor < -1:', '            else:', '        return root', '        if not root:', '            return root', '        elif key < root.key:', '        elif key > root.key:', '        else:', '                root = None', '                return temp', '                root = None', '                return temp', '        if root is None:', '            return root', '        # Balance the tree', '        if balanceFactor > 1:', '            else:', '        if balanceFactor < -1:', '            else:', '        return root', '    def leftRotate(self, z):', '        y = z.right', '        T2 = y.left', '        y.left = z', '        z.right = T2', '        return y', '    def rightRotate(self, z):', '        y = z.left', '        T3 = y.right', '        y.right = z', '        z.left = T3', '        return y', '    def getHeight(self, root):', '        if not root:', '            return 0', '        return root.height', '        if not root:', '            return 0', '            return root', '    def preOrder(self, root):', '        if not root:', '            return', '    # Print the tree', '        if currPtr != None:', '            if last:', '            else:', '            print(currPtr.key)', 'myTree = AVLTree()', 'root = None', 'for num in nums:', 'key = 13', 'print(""After Deletion: "")', 'class Node {', '  int item, height;', '  Node left, right;', '  Node(int d) {', '    item = d;', '    height = 1;', 'class AVLTree {', '  Node root;', '  int height(Node N) {', '    if (N == null)', '      return 0;', '    return N.height;', '  int max(int a, int b) {', '    return (a > b) ? a : b;', '  Node rightRotate(Node y) {', '    Node x = y.left;', '    Node T2 = x.right;', '    x.right = y;', '    y.left = T2;', '    return x;', '  Node leftRotate(Node x) {', '    Node y = x.right;', '    Node T2 = y.left;', '    y.left = x;', '    x.right = T2;', '    return y;', '    if (N == null)', '      return 0;', '    if (node == null)', '      return (new Node(item));', '    if (item < node.item)', '    else if (item > node.item)', '    else', '      return node;', '    if (balanceFactor > 1) {', '    if (balanceFactor < -1) {', '    return node;', '    Node current = node;', '      current = current.left;', '    return current;', '    if (root == null)', '      return root;', '    if (item < root.item)', '    else if (item > root.item)', '    else {', '        Node temp = null;', '        if (temp == root.left)', '          temp = root.right;', '        else', '          temp = root.left;', '        if (temp == null) {', '          temp = root;', '          root = null;', '        } else', '          root = temp;', '      } else {', '        root.item = temp.item;', '    if (root == null)', '      return root;', '    if (balanceFactor > 1) {', '      } else {', '    if (balanceFactor < -1) {', '      } else {', '    return root;', '  void preOrder(Node node) {', '    if (node != null) {', '      preOrder(node.left);', '      preOrder(node.right);', '    if (currPtr != null) {', '      if (last) {', '        indent += ""   "";', '      } else {', '        indent += ""|  "";', '#include <stdio.h>', '#include <stdlib.h>', 'struct Node {', '  int key;', '  struct Node *left;', '  struct Node *right;', '  int height;', 'int max(int a, int b);', 'int height(struct Node *N) {', '  if (N == NULL)', '    return 0;', '  return N->height;', 'int max(int a, int b) {', '  return (a > b) ? a : b;', '  node->key = key;', '  node->left = NULL;', '  node->right = NULL;', '  node->height = 1;', '  return (node);', '  struct Node *x = y->left;', '  struct Node *T2 = x->right;', '  x->right = y;', '  y->left = T2;', '  return x;', '  struct Node *y = x->right;', '  struct Node *T2 = y->left;', '  y->left = x;', '  x->right = T2;', '  return y;', '  if (N == NULL)', '    return 0;', '  if (node == NULL)', '    return (newNode(key));', '  if (key < node->key)', '  else if (key > node->key)', '    return node;', '    return rightRotate(node);', '    return leftRotate(node);', '    return rightRotate(node);', '    return leftRotate(node);', '  return node;', '  struct Node *current = node;', '    current = current->left;', '  return current;', '  if (root == NULL)', '    return root;', '  if (key < root->key)', '  else if (key > root->key)', '  else {', '      if (temp == NULL) {', '        temp = root;', '        root = NULL;', '      } else', '        *root = *temp;', '      free(temp);', '    } else {', '      root->key = temp->key;', '  if (root == NULL)', '    return root;', '    return rightRotate(root);', '    return rightRotate(root);', '    return leftRotate(root);', '    return leftRotate(root);', '  return root;', '  if (root != NULL) {', '    printf(""%d "", root->key);', '    printPreOrder(root->left);', 'int main() {', '  struct Node *root = NULL;', '  root = insertNode(root, 2);', '  root = insertNode(root, 1);', '  root = insertNode(root, 7);', '  root = insertNode(root, 4);', '  root = insertNode(root, 5);', '  root = insertNode(root, 3);', '  root = insertNode(root, 8);', '  printPreOrder(root);', '  root = deleteNode(root, 3);', '  printPreOrder(root);', '  return 0;', '#include <iostream>', 'using namespace std;', 'class Node {', '   public:', '  int key;', '  Node *left;', '  Node *right;', '  int height;', 'int max(int a, int b);', 'int height(Node *N) {', '  if (N == NULL)', '    return 0;', '  return N->height;', 'int max(int a, int b) {', '  return (a > b) ? a : b;', 'Node *newNode(int key) {', '  Node *node = new Node();', '  node->key = key;', '  node->left = NULL;', '  node->right = NULL;', '  node->height = 1;', '  return (node);', 'Node *rightRotate(Node *y) {', '  Node *x = y->left;', '  Node *T2 = x->right;', '  x->right = y;', '  y->left = T2;', '          height(y->right)) +', '        1;', '          height(x->right)) +', '        1;', '  return x;', 'Node *leftRotate(Node *x) {', '  Node *y = x->right;', '  Node *T2 = y->left;', '  y->left = x;', '  x->right = T2;', '          height(x->right)) +', '        1;', '          height(y->right)) +', '        1;', '  return y;', '  if (N == NULL)', '    return 0;', '  return height(N->left) -', '       height(N->right);', '  if (node == NULL)', '    return (newNode(key));', '  if (key < node->key)', '  else if (key > node->key)', '    return node;', '  if (balanceFactor > 1) {', '  if (balanceFactor < -1) {', '      return leftRotate(node);', '      return leftRotate(node);', '  return node;', '  Node *current = node;', '    current = current->left;', '  return current;', '  if (root == NULL)', '    return root;', '  if (key < root->key)', '  else if (key > root->key)', '  else {', '      (root->right == NULL)) {', '      if (temp == NULL) {', '        temp = root;', '        root = NULL;', '      } else', '        *root = *temp;', '      free(temp);', '    } else {', '      root->key = temp->key;', '                   temp->key);', '  if (root == NULL)', '    return root;', '  if (balanceFactor > 1) {', '    } else {', '  if (balanceFactor < -1) {', '      return leftRotate(root);', '    } else {', '      return leftRotate(root);', '  return root;', '  if (root != nullptr) {', '    cout << indent;', '    if (last) {', '      cout << ""R----"";', '      indent += ""   "";', '    } else {', '      cout << ""L----"";', '      indent += ""|  "";', '    cout << root->key << endl;', 'int main() {', '  Node *root = NULL;', '  root = insertNode(root, 33);', '  root = insertNode(root, 13);', '  root = insertNode(root, 53);', '  root = insertNode(root, 9);', '  root = insertNode(root, 21);', '  root = insertNode(root, 61);', '  root = insertNode(root, 8);', '  root = insertNode(root, 11);', '  printTree(root, """", true);', '  root = deleteNode(root, 13);', '  printTree(root, """", true);']","['# AVL tree implementation in Python', '    def insert_node(self, root, key):', '        # Find the correct location and insert the node', '            return TreeNode(key)', '            root.left = self.insert_node(root.left, key)', '            root.right = self.insert_node(root.right, key)', '        root.height = 1 + max(self.getHeight(root.left),', '                              self.getHeight(root.right))', '        # Update the balance factor and balance the tree', '        balanceFactor = self.getBalance(root)', '            if key < root.left.key:', '                return self.rightRotate(root)', '                root.left = self.leftRotate(root.left)', '                return self.rightRotate(root)', '            if key > root.right.key:', '                return self.leftRotate(root)', '                root.right = self.rightRotate(root.right)', '                return self.leftRotate(root)', '    def delete_node(self, root, key):', '        # Find the node to be deleted and remove it', '            root.left = self.delete_node(root.left, key)', '            root.right = self.delete_node(root.right, key)', '            if root.left is None:', '                temp = root.right', '            elif root.right is None:', '                temp = root.left', '            temp = self.getMinValueNode(root.right)', '            root.right = self.delete_node(root.right,', '                                          temp.key)', '        # Update the balance factor of nodes', '        root.height = 1 + max(self.getHeight(root.left),', '                              self.getHeight(root.right))', '        balanceFactor = self.getBalance(root)', '            if self.getBalance(root.left) >= 0:', '                return self.rightRotate(root)', '                root.left = self.leftRotate(root.left)', '                return self.rightRotate(root)', '            if self.getBalance(root.right) <= 0:', '                return self.leftRotate(root)', '                root.right = self.rightRotate(root.right)', '                return self.leftRotate(root)', '    # Function to perform left rotation', '        z.height = 1 + max(self.getHeight(z.left),', '                           self.getHeight(z.right))', '        y.height = 1 + max(self.getHeight(y.left),', '                           self.getHeight(y.right))', '    # Function to perform right rotation', '        z.height = 1 + max(self.getHeight(z.left),', '                           self.getHeight(z.right))', '        y.height = 1 + max(self.getHeight(y.left),', '                           self.getHeight(y.right))', '    # Get the height of the node', '    # Get balance factore of the node', '        return self.getHeight(root.left) - self.getHeight(root.right)', '    def getMinValueNode(self, root):', '        if root is None or root.left is None:', '        return self.getMinValueNode(root.left)', '        print(""{0} "".format(root.key), end="""")', '        self.preOrder(root.left)', '        self.preOrder(root.right)', '    def printHelper(self, currPtr, indent, last):', '            sys.stdout.write(indent)', '                sys.stdout.write(""R----"")', '                indent += ""     ""', '                sys.stdout.write(""L----"")', '                indent += ""|    ""', '            self.printHelper(currPtr.left, indent, False)', '            self.printHelper(currPtr.right, indent, True)', 'nums = [33, 13, 52, 9, 21, 61, 8, 11]', '    root = myTree.insert_node(root, num)', 'myTree.printHelper(root, """", True)', 'root = myTree.delete_node(root, key)', 'myTree.printHelper(root, """", True)', '    y.height = max(height(y.left), height(y.right)) + 1;', '    x.height = max(height(x.left), height(x.right)) + 1;', '    x.height = max(height(x.left), height(x.right)) + 1;', '    y.height = max(height(y.left), height(y.right)) + 1;', '  int getBalanceFactor(Node N) {', '    return height(N.left) - height(N.right);', '  Node insertNode(Node node, int item) {', '      node.left = insertNode(node.left, item);', '      node.right = insertNode(node.right, item);', '    node.height = 1 + max(height(node.left), height(node.right));', '    int balanceFactor = getBalanceFactor(node);', '      if (item < node.left.item) {', '        return rightRotate(node);', '      } else if (item > node.left.item) {', '        node.left = leftRotate(node.left);', '        return rightRotate(node);', '      if (item > node.right.item) {', '        return leftRotate(node);', '      } else if (item < node.right.item) {', '        node.right = rightRotate(node.right);', '        return leftRotate(node);', '  Node nodeWithMimumValue(Node node) {', '    while (current.left != null)', '  Node deleteNode(Node root, int item) {', '      root.left = deleteNode(root.left, item);', '      root.right = deleteNode(root.right, item);', '      if ((root.left == null) || (root.right == null)) {', '        Node temp = nodeWithMimumValue(root.right);', '        root.right = deleteNode(root.right, temp.item);', '    root.height = max(height(root.left), height(root.right)) + 1;', '    int balanceFactor = getBalanceFactor(root);', '      if (getBalanceFactor(root.left) >= 0) {', '        return rightRotate(root);', '        root.left = leftRotate(root.left);', '        return rightRotate(root);', '      if (getBalanceFactor(root.right) <= 0) {', '        return leftRotate(root);', '        root.right = rightRotate(root.right);', '        return leftRotate(root);', '      System.out.print(node.item + "" "");', '  private void printTree(Node currPtr, String indent, boolean last) {', '        System.out.print(""R----"");', '        System.out.print(""L----"");', '      System.out.println(currPtr.item);', '      printTree(currPtr.left, indent, false);', '      printTree(currPtr.right, indent, true);', '  public static void main(String[] args) {', '    AVLTree tree = new AVLTree();', '    tree.root = tree.insertNode(tree.root, 33);', '    tree.root = tree.insertNode(tree.root, 13);', '    tree.root = tree.insertNode(tree.root, 53);', '    tree.root = tree.insertNode(tree.root, 9);', '    tree.root = tree.insertNode(tree.root, 21);', '    tree.root = tree.insertNode(tree.root, 61);', '    tree.root = tree.insertNode(tree.root, 8);', '    tree.root = tree.insertNode(tree.root, 11);', '    tree.printTree(tree.root, """", true);', '    tree.root = tree.deleteNode(tree.root, 13);', '    System.out.println(""After Deletion: "");', '    tree.printTree(tree.root, """", true);', '  struct Node *node = (struct Node *)', '    malloc(sizeof(struct Node));', 'struct Node *rightRotate(struct Node *y) {', '  y->height = max(height(y->left), height(y->right)) + 1;', '  x->height = max(height(x->left), height(x->right)) + 1;', 'struct Node *leftRotate(struct Node *x) {', '  x->height = max(height(x->left), height(x->right)) + 1;', '  y->height = max(height(y->left), height(y->right)) + 1;', 'int getBalance(struct Node *N) {', '  return height(N->left) - height(N->right);', 'struct Node *insertNode(struct Node *node, int key) {', '    node->left = insertNode(node->left, key);', '    node->right = insertNode(node->right, key);', '  node->height = 1 + max(height(node->left),', '               height(node->right));', '  int balance = getBalance(node);', '  if (balance > 1 && key < node->left->key)', '  if (balance < -1 && key > node->right->key)', '  if (balance > 1 && key > node->left->key) {', '    node->left = leftRotate(node->left);', '  if (balance < -1 && key < node->right->key) {', '    node->right = rightRotate(node->right);', 'struct Node *minValueNode(struct Node *node) {', 'struct Node *deleteNode(struct Node *root, int key) {', '    root->left = deleteNode(root->left, key);', '    root->right = deleteNode(root->right, key);', '    if ((root->left == NULL) || (root->right == NULL)) {', '      struct Node *temp = root->left ? root->left : root->right;', '      struct Node *temp = minValueNode(root->right);', '      root->right = deleteNode(root->right, temp->key);', '  root->height = 1 + max(height(root->left),', '               height(root->right));', '  int balance = getBalance(root);', '  if (balance > 1 && getBalance(root->left) >= 0)', '  if (balance > 1 && getBalance(root->left) < 0) {', '    root->left = leftRotate(root->left);', '  if (balance < -1 && getBalance(root->right) <= 0)', '  if (balance < -1 && getBalance(root->right) > 0) {', '    root->right = rightRotate(root->right);', 'void printPreOrder(struct Node *root) {', '  y->height = max(height(y->left),', '  x->height = max(height(x->left),', '  x->height = max(height(x->left),', '  y->height = max(height(y->left),', 'Node *insertNode(Node *node, int key) {', '    node->left = insertNode(node->left, key);', '    node->right = insertNode(node->right, key);', '  node->height = 1 + max(height(node->left),', '               height(node->right));', '  int balanceFactor = getBalanceFactor(node);', '    if (key < node->left->key) {', '    } else if (key > node->left->key) {', '      node->left = leftRotate(node->left);', '    if (key > node->right->key) {', '    } else if (key < node->right->key) {', '      node->right = rightRotate(node->right);', 'Node *nodeWithMimumValue(Node *node) {', 'Node *deleteNode(Node *root, int key) {', '    root->left = deleteNode(root->left, key);', '    root->right = deleteNode(root->right, key);', '      Node *temp = root->left ? root->left : root->right;', '      Node *temp = nodeWithMimumValue(root->right);', '      root->right = deleteNode(root->right,', '  root->height = 1 + max(height(root->left),', '               height(root->right));', '  int balanceFactor = getBalanceFactor(root);', '    if (getBalanceFactor(root->left) >= 0) {', '      root->left = leftRotate(root->left);', '    if (getBalanceFactor(root->right) <= 0) {', '      root->right = rightRotate(root->right);', 'void printTree(Node *root, string indent, bool last) {', '    printTree(root->left, indent, false);', '    printTree(root->right, indent, true);', '  cout << ""After deleting "" << endl;']",[],['nsertion|||Deletion|||Search&&&(log n)|||O(log n)|||O(log n)'],"['For indexing large records in databases|||For searching in large databases|||&&&Let the initial tree be:|||Left rotate|||If y has a left subtree, assign x as the parent of the left subtree of y.|||Assign x as the parent of the left subtree of y|||If the parent of x is NULL, make y as the root of the tree.|||Else if x is the left child of p, make y as the left child of p.|||Else assign y as the right child of p.|||Change the parent of x to that of y|||Make y as the parent of x.|||Assign y as the parent of x.|||Let the initial tree be:|||Initial tree|||If x has a right subtree, assign y as the parent of the right subtree of x.|||Assign y as the parent of the right subtree of x|||If the parent of y is NULL, make x as the root of the tree.|||Else if y is the right child of its parent p, make x as the right child of p.|||Else assign x as the left child of p.|||Assign the parent of y as the parent of x.|||Make x as the parent of y.|||Assign x as the parent of y|||Do left rotation on x-y.|||Left rotate x-y|||Do right rotation on y-z.|||Right rotate z-y|||Do right rotation on x-y.|||Right rotate x-y|||Do left rotation on z-y.|||Left rotate z-y|||Let the initial tree be:|||Initial tree for insertion|||Let the node to be inserted be:|||New node|||Go to the appropriate leaf node to insert a newNode using the following recursive steps. Compare newKey with rootKey of the current tree.|||If newKey < rootKey, call insertion algorithm on the left subtree of the current node until the leaf node is reached.|||Else if newKey > rootKey, call insertion algorithm on the right subtree of current node until the leaf node is reached.|||Else, return leafNode.|||Finding the location to insert newNode||||||Compare leafKey obtained from the above steps with newKey:|||If newKey < leafKey, make newNode as the leftChild of leafNode.|||Else, make newNode as rightChild of leafNode.|||Inserting the new node||||||Update balanceFactor of the nodes.|||Updating the balance factor after insertion|||If the nodes are unbalanced, then rebalance the node.|||If balanceFactor > 1, it means the height of the left subtree is greater than that of the right subtree. So, do a right rotation or left-right rotation|||If newNodeKey < leftChildKey do right rotation.|||Else, do left-right rotation.|||Balancing the tree with rotationBalancing the tree with rotation||||||If balanceFactor < -1, it means the height of the right subtree is greater than that of the left subtree. So, do right rotation or right-left rotation|||If newNodeKey > rightChildKey do left rotation.|||Else, do right-left rotation|||||||||The final tree is:|||Final balanced tree|||If newKey < rootKey, call insertion algorithm on the left subtree of the current node until the leaf node is reached.|||Else if newKey > rootKey, call insertion algorithm on the right subtree of current node until the leaf node is reached.|||Else, return leafNode.|||Finding the location to insert newNode|||If newKey < leafKey, make newNode as the leftChild of leafNode.|||Else, make newNode as rightChild of leafNode.|||Inserting the new node|||If balanceFactor > 1, it means the height of the left subtree is greater than that of the right subtree. So, do a right rotation or left-right rotation|||If newNodeKey < leftChildKey do right rotation.|||Else, do left-right rotation.|||Balancing the tree with rotationBalancing the tree with rotation||||||If balanceFactor < -1, it means the height of the right subtree is greater than that of the left subtree. So, do right rotation or right-left rotation|||If newNodeKey > rightChildKey do left rotation.|||Else, do right-left rotation||||||If newNodeKey < leftChildKey do right rotation.|||Else, do left-right rotation.|||Balancing the tree with rotationBalancing the tree with rotation|||If newNodeKey > rightChildKey do left rotation.|||Else, do right-left rotation|||Locate nodeToBeDeleted (recursion is used to find nodeToBeDeleted in the code used below).||||||Locating the node to be deleted|||There are three cases for deleting a node:|||If nodeToBeDeleted is the leaf node (ie. does not have any child), then remove nodeToBeDeleted.|||If nodeToBeDeleted has one child, then substitute the contents of nodeToBeDeleted with that of the child. Remove the child.|||If nodeToBeDeleted has two children, find the inorder successor w of nodeToBeDeleted (ie. node with a minimum value of key in the right subtree).|||Finding the successorSubstitute the contents of nodeToBeDeleted with that of w.||||||Substitute the node to be deleted|||Remove the leaf node w.|||Remove w|||||||||Update balanceFactor of the nodes.|||Update bf|||Rebalance the tree if the balance factor of any of the nodes is not equal to -1, 0 or 1.|||If balanceFactor of currentNode > 1,|||If balanceFactor of leftChild >= 0, do right rotation.|||Right-rotate for balancing the tree|||Else do left-right rotation.||||||If balanceFactor of currentNode < -1,|||If balanceFactor of rightChild <= 0, do left rotation.|||Else do right-left rotation.|||||||||The final tree is:|||Avl tree final|||If nodeToBeDeleted is the leaf node (ie. does not have any child), then remove nodeToBeDeleted.|||If nodeToBeDeleted has one child, then substitute the contents of nodeToBeDeleted with that of the child. Remove the child.|||If nodeToBeDeleted has two children, find the inorder successor w of nodeToBeDeleted (ie. node with a minimum value of key in the right subtree).|||Finding the successorSubstitute the contents of nodeToBeDeleted with that of w.||||||Substitute the node to be deleted|||Remove the leaf node w.|||Remove w||||||Substitute the contents of nodeToBeDeleted with that of w.||||||Substitute the node to be deleted|||Remove the leaf node w.|||Remove w|||If balanceFactor of currentNode > 1,|||If balanceFactor of leftChild >= 0, do right rotation.|||Right-rotate for balancing the tree|||Else do left-right rotation.||||||If balanceFactor of currentNode < -1,|||If balanceFactor of rightChild <= 0, do left rotation.|||Else do right-left rotation.||||||If balanceFactor of leftChild >= 0, do right rotation.|||Right-rotate for balancing the tree|||Else do left-right rotation.|||If balanceFactor of rightChild <= 0, do left rotation.|||Else do right-left rotation.|||']"
28,['B-tree'],"['In this tutorial, you will learn what a B-tree is. Also, you will find working examples of search operation on a B-tree in C, C++, Java and Python.']",[],[],"['Why do you need a B-tree data strcuture?', 'B-tree Properties', 'Operations on a B-tree', 'Algorithm for Searching an Element', 'B-tree operations code in Python, Java, and C/C++', 'Searching Complexity on B Tree', 'B Tree Applications']","['Searching an element in a B-tree', 'Searching Example']","['//cdn.programiz.com/sites/tutorial2program/files/b-tree.png', '//cdn.programiz.com/sites/tutorial2program/files/search-1.png', '//cdn.programiz.com/sites/tutorial2program/files/search-2.png', '//cdn.programiz.com/sites/tutorial2program/files/search-3.png', '//cdn.programiz.com/sites/tutorial2program/files/search-4.png', '//cdn.programiz.com/sites/tutorial2program/files/search-5.png', '//cdn.programiz.com/sites/tutorial2program/files/search-6.png']","['It is also known as a height-balanced m-way tree.', 'To learn more about different B-tree operations, please visit', 'Worst case Time complexity: Θ(log n)', 'Average case Time complexity: Θ(log n)', 'Best case Time complexity: Θ(log n)', 'Average case Space complexity: Θ(n)', 'Worst case Space complexity: Θ(n)']",[],"['B-tree is a special type of self-balancing search tree in which each node can contain more than one key and can have more than two children. It is a generalized form of the binary search tree.', 'The need for B-tree arose with the rise in the need for lesser time in accessing the physical storage media like a hard disk. The secondary storage devices are slower with a larger capacity. There was a need for such types of data structures that minimize the disk accesses.', 'Other data structures such as a binary search tree, avl tree, red-black tree, etc can store only one key in one node. If you have to store a large number of keys, then the height of such trees becomes very large and the access time increases.', 'However, B-tree can store many keys in a single node and can have multiple child nodes. This decreases the height significantly allowing faster disk accesses.', 'Searching for an element in a B-tree is the generalized form of searching an element in a Binary Search Tree. The following steps are followed.']","['BtreeSearch(x, k)', '    do i = i + 1', 'if i  n[x] and k = keyi[x]', '    then return (x, i)', 'if leaf [x]', '    then return NIL', '# Create a node', 'class BTreeNode:', '    self.leaf = leaf', '    self.keys = []', '    self.child = []', 'class BTree:', '  def __init__(self, t):', '    self.t = t', '    # Insert node', '  def insert(self, k):', '    root = self.root', '      temp = BTreeNode()', '      self.root = temp', '    else:', '    # Insert nonfull', '    i = len(x.keys) - 1', '    if x.leaf:', '        i -= 1', '      x.keys[i + 1] = k', '    else:', '        i -= 1', '      i += 1', '        self.split_child(x, i)', '          i += 1', '    # Split the child', '  def split_child(self, x, i):', '    t = self.t', '    y = x.child[i]', '    z = BTreeNode(y.leaf)', '    x.child.insert(i + 1, z)', '    y.keys = y.keys[0: t - 1]', '    if not y.leaf:', '  # Print the tree', '    for i in x.keys:', '      print(i, end="" "")', '    print()', '    l += 1', '    if len(x.child) > 0:', '      for i in x.child:', '        self.print_tree(i, l)', '  # Search key in the tree', '    if x is not None:', '      i = 0', '        i += 1', '        return (x, i)', '      elif x.leaf:', '        return None', '      else:', '    else:', 'def main():', '  B = BTree(3)', '  for i in range(10):', '    B.insert((i, 2 * i))', '  B.print_tree(B.root)', '    print(""\\nFound"")', '    print(""\\nNot Found"")', ""if __name__ == '__main__':"", '  main()', 'public class BTree {', '  private int T;', '  public class Node {', '    int n;', '    boolean leaf = true;', '    public int Find(int k) {', '          return i;', '        }', '      return -1;', '  public BTree(int t) {', '    T = t;', '    root = new Node();', '    root.n = 0;', '    root.leaf = true;', '  private Node root;', '    int i = 0;', '    if (x == null)', '      return x;', '      if (key < x.key[i]) {', '        break;', '      if (key == x.key[i]) {', '        return x;', '    if (x.leaf) {', '      return null;', '    } else {', '    Node z = new Node();', '    z.leaf = y.leaf;', '    z.n = T - 1;', '      z.key[j] = y.key[j + T];', '    if (!y.leaf) {', '    y.n = T - 1;', '    x.child[pos + 1] = z;', '      x.key[j + 1] = x.key[j];', '    x.key[pos] = y.key[T - 1];', '    x.n = x.n + 1;', '    Node r = root;', '    if (r.n == 2 * T - 1) {', '      Node s = new Node();', '      root = s;', '      s.leaf = false;', '      s.n = 0;', '      s.child[0] = r;', '      Split(s, 0, r);', '      insertValue(s, key);', '    } else {', '      insertValue(r, key);', '    if (x.leaf) {', '      int i = 0;', '      x.key[i + 1] = k;', '      x.n = x.n + 1;', '    } else {', '      int i = 0;', '      i++;', '      Node tmp = x.child[i];', '        Split(x, i, tmp);', '        if (k > x.key[i]) {', '          i++;', '        }', '  public void Show() {', '    Show(root);', '  private void Show(Node x) {', '    assert (x == null);', '    if (!x.leaf) {', '        Show(x.child[i]);', '      return true;', '    } else {', '      return false;', '    BTree b = new BTree(3);', '    b.Insert(8);', '    b.Insert(9);', '    b.Insert(10);', '    b.Insert(11);', '    b.Insert(15);', '    b.Insert(20);', '    b.Insert(17);', '    b.Show();', '    if (b.Contain(12)) {', '    } else {', '#include <stdio.h>', '#include <stdlib.h>', '#define MAX 3', '#define MIN 2', 'struct BTreeNode {', '  int val[MAX + 1], count;', 'struct BTreeNode *root;', '  struct BTreeNode *newNode;', '  newNode->val[1] = val;', '  newNode->count = 1;', '  newNode->link[0] = root;', '  newNode->link[1] = child;', '  return newNode;', '  int j = node->count;', '  while (j > pos) {', '    j--;', '  node->val[j + 1] = val;', '  node->link[j + 1] = child;', '  node->count++;', '  int median, j;', '  if (pos > MIN)', '    median = MIN + 1;', '    median = MIN;', '  j = median + 1;', '  while (j <= MAX) {', '    j++;', '  node->count = median;', '  if (pos <= MIN) {', '  } else {', '  node->count--;', '  int pos;', '  if (!node) {', '    *pval = val;', '    *child = NULL;', '    return 1;', '  if (val < node->val[1]) {', '    pos = 0;', '  } else {', '    for (pos = node->count;', '      return 0;', '    if (node->count < MAX) {', '    } else {', '      return 1;', '  return 0;', 'void insert(int val) {', '  int flag, i;', '  struct BTreeNode *child;', '  if (flag)', '  if (!myNode) {', '    return;', '  if (val < myNode->val[1]) {', '    *pos = 0;', '  } else {', '    for (*pos = myNode->count;', '      return;', '  return;', '  int i;', '  if (myNode) {', 'int main() {', '  int val, ch;', '  insert(8);', '  insert(9);', '  insert(10);', '  insert(11);', '  insert(15);', '  insert(16);', '  insert(17);', '  insert(18);', '  insert(20);', '  insert(23);', '  traversal(root);', '  printf(""\\n"");', '  search(11, &ch, root);', '#include <iostream>', 'using namespace std;', 'class TreeNode {', '  int *keys;', '  int t;', '  TreeNode **C;', '  int n;', '  bool leaf;', '   public:', '  void insertNonFull(int k);', '  void traverse();', '  TreeNode *search(int k);', '  friend class BTree;', 'class BTree {', '  TreeNode *root;', '  int t;', '   public:', '  BTree(int temp) {', '    root = NULL;', '    t = temp;', '  void traverse() {', '    if (root != NULL)', '      root->traverse();', '  TreeNode *search(int k) {', '  void insert(int k);', '  t = t1;', '  leaf = leaf1;', '  keys = new int[2 * t - 1];', '  C = new TreeNode *[2 * t];', '  n = 0;', 'void TreeNode::traverse() {', '  int i;', '  for (i = 0; i < n; i++) {', '    if (leaf == false)', '      C[i]->traverse();', '    cout << "" "" << keys[i];', '  if (leaf == false)', '    C[i]->traverse();', '  int i = 0;', '  while (i < n && k > keys[i])', '    i++;', '  if (keys[i] == k)', '    return this;', '  if (leaf == true)', '    return NULL;', '  return C[i]->search(k);', 'void BTree::insert(int k) {', '  if (root == NULL) {', '    root->keys[0] = k;', '    root->n = 1;', '  } else {', '      s->C[0] = root;', '      s->splitChild(0, root);', '      int i = 0;', '      if (s->keys[0] < k)', '        i++;', '      root = s;', '    } else', '      root->insertNonFull(k);', '  int i = n - 1;', '  if (leaf == true) {', '      keys[i + 1] = keys[i];', '      i--;', '    keys[i + 1] = k;', '    n = n + 1;', '  } else {', '      i--;', '      if (keys[i + 1] < k)', '        i++;', '  z->n = t - 1;', '  if (y->leaf == false) {', '      z->C[j] = y->C[j + t];', '  y->n = t - 1;', '    C[j + 1] = C[j];', '  C[i + 1] = z;', '    keys[j + 1] = keys[j];', '  keys[i] = y->keys[t - 1];', '  n = n + 1;', 'int main() {', '  BTree t(3);', '  t.insert(8);', '  t.insert(9);', '  t.insert(10);', '  t.insert(11);', '  t.insert(15);', '  t.insert(16);', '  t.insert(17);', '  t.insert(18);', '  t.insert(20);', '  t.insert(23);', '  cout << ""The B-tree is: "";', '  t.traverse();', '  int k = 10;', '              : cout << endl', '  k = 2;', '              : cout << endl']","[' while i ≤ n[x] and k ≥ keyi[x]        // n[x] means number of keys in x node', '    return BtreeSearch(ci[x], k)', '# Searching a key on a B-tree in Python', '  def __init__(self, leaf=False):', '    if len(root.keys) == (2 * self.t) - 1:', '      temp.child.insert(0, root)', '      self.insert_non_full(temp, k)', '      self.insert_non_full(root, k)', '  def insert_non_full(self, x, k):', '      x.keys.append((None, None))', '      while i >= 0 and k[0] < x.keys[i][0]:', '        x.keys[i + 1] = x.keys[i]', '      while i >= 0 and k[0] < x.keys[i][0]:', '      if len(x.child[i].keys) == (2 * self.t) - 1:', '      self.insert_non_full(x.child[i], k)', '    x.keys.insert(i, y.keys[t - 1])', '    z.keys = y.keys[t: (2 * t) - 1]', '      z.child = y.child[t: 2 * t]', '      y.child = y.child[0: t - 1]', '    print(""Level "", l, "" "", len(x.keys), end="":"")', '  def search_key(self, k, x=None):', '      while i < len(x.keys) and k > x.keys[i][0]:', '      if i < len(x.keys) and k == x.keys[i][0]:', '        return self.search_key(k, x.child[i])', '      return self.search_key(k, self.root)', '  if B.search_key(8) is not None:', '    int key[] = new int[2 * T - 1];', '    Node child[] = new Node[2 * T];', '      for (int i = 0; i < this.n; i++) {', '  private Node Search(Node x, int key) {', '      return Search(x.child[i], key);', '  private void Split(Node x, int pos, Node y) {', '    for (int j = 0; j < T - 1; j++) {', '      for (int j = 0; j < T; j++) {', '        z.child[j] = y.child[j + T];', '    for (int j = x.n; j >= pos + 1; j--) {', '      x.child[j + 1] = x.child[j];', '    for (int j = x.n - 1; j >= pos; j--) {', '  public void Insert(final int key) {', '  final private void insertValue(Node x, int k) {', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '        x.key[i + 1] = x.key[i];', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '      insertValue(x.child[i], k);', '    for (int i = 0; i < x.n; i++) {', '      System.out.print(x.key[i] + "" "");', '      for (int i = 0; i < x.n + 1; i++) {', '  public boolean Contain(int k) {', '    if (this.Search(root, k) != null) {', '  public static void main(String[] args) {', '      System.out.println(""\\nfound"");', '      System.out.println(""\\nnot found"");', '  struct BTreeNode *link[MAX + 1];', 'struct BTreeNode *createNode(int val, struct BTreeNode *child) {', '  newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));', 'void insertNode(int val, int pos, struct BTreeNode *node,', '        struct BTreeNode *child) {', '    node->val[j + 1] = node->val[j];', '    node->link[j + 1] = node->link[j];', 'void splitNode(int val, int *pval, int pos, struct BTreeNode *node,', '         struct BTreeNode *child, struct BTreeNode **newNode) {', '  *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));', '    (*newNode)->val[j - median] = node->val[j];', '    (*newNode)->link[j - median] = node->link[j];', '  (*newNode)->count = MAX - median;', '    insertNode(val, pos, node, child);', '    insertNode(val, pos - median, *newNode, child);', '  *pval = node->val[node->count];', '  (*newNode)->link[0] = node->link[node->count];', 'int setValue(int val, int *pval,', '           struct BTreeNode *node, struct BTreeNode **child) {', '       (val < node->val[pos] && pos > 1); pos--)', '    if (val == node->val[pos]) {', '      printf(""Duplicates are not permitted\\n"");', '  if (setValue(val, pval, node->link[pos], child)) {', '      insertNode(*pval, pos, node, *child);', '      splitNode(*pval, pval, pos, node, *child, child);', '  flag = setValue(val, &i, root, &child);', '    root = createNode(i, child);', 'void search(int val, int *pos, struct BTreeNode *myNode) {', '       (val < myNode->val[*pos] && *pos > 1); (*pos)--)', '    if (val == myNode->val[*pos]) {', '      printf(""%d is found"", val);', '  search(val, pos, myNode->link[*pos]);', 'void traversal(struct BTreeNode *myNode) {', '    for (i = 0; i < myNode->count; i++) {', '      traversal(myNode->link[i]);', '      printf(""%d "", myNode->val[i + 1]);', '  TreeNode(int temp, bool bool_leaf);', '  void splitChild(int i, TreeNode *y);', '    return (root == NULL) ? NULL : root->search(k);', 'TreeNode::TreeNode(int t1, bool leaf1) {', 'TreeNode *TreeNode::search(int k) {', '    root = new TreeNode(t, true);', '      TreeNode *s = new TreeNode(t, false);', '      s->C[i]->insertNonFull(k);', 'void TreeNode::insertNonFull(int k) {', '    while (i >= 0 && keys[i] > k) {', '    while (i >= 0 && keys[i] > k)', '    if (C[i + 1]->n == 2 * t - 1) {', '      splitChild(i + 1, C[i + 1]);', 'void TreeNode::splitChild(int i, TreeNode *y) {', '  TreeNode *z = new TreeNode(y->t, y->leaf);', '  for (int j = 0; j < t - 1; j++)', '    z->keys[j] = y->keys[j + t];', '  for (int j = n; j >= i + 1; j--)', '  for (int j = n - 1; j >= i; j--)', '  (t.search(k) != NULL) ? cout << endl', '                 << k << "" is found""', '                 << k << "" is not Found"";', '  (t.search(k) != NULL) ? cout << endl', '                 << k << "" is found""', '                 << k << "" is not Found\\n"";']",[],[],"['Insertion on B-tree|||Deletion on B-tree|||databases and file systems|||to store blocks of data (secondary storage media)|||multilevel indexing|||&&&For each node x, the keys are stored in increasing order.|||In each node, there is a boolean value x.leaf which is true if x is a leaf.|||If n is the order of the tree, each internal node can contain at most n - 1 keys along with a pointer to each child.|||Each node except root can have at most n children and at least n/2 children.|||All leaves have the same depth (i.e. height-h of the tree).|||The root has at least 2 children and contains a minimum of 1 key.|||If n ≥ 1, then for any n-key B-tree of height h and minimum degree t ≥ 2, h ≥ logt (n+1)/2.|||Starting from the root node, compare k with the first key of the node.|||If k = the first key of the node, return the node and the index.|||If k.leaf = true, return NULL (i.e. not found).|||If k < the first key of the root node, search the left child of this key recursively.|||If there is more than one key in the current node and k > the first key, compare k with the next key in the node.|||If k < next key, search the left child of this key (ie. k lies in between the first and the second keys).|||Else, search the right child of the key.|||Repeat steps 1 to 4 until the leaf is reached.|||Let us search key k = 17 in the tree below of degree 3.||||||B-tree|||k is not found in the root so, compare it with the root key.|||k is not found on the root node|||Since k > 11, go to the right child of the root node.|||Go to the right subtree|||Compare k with 16. Since k > 16, compare k with the next key 18.|||Compare with the keys from left to right|||Since k < 18, k lies between 16 and 18. Search in the right child of 16 or the left child of 18.|||k lies in between 16 and 18|||k is found.|||k is found|||']"
29,['Insertion into a B-tree'],"['In this tutorial, you will learn how to insert a key into a btree. Also, you will find working examples of inserting keys into a B-tree in C, C++, Java and Python.']",[],[],"['Insertion Operation', 'Insertion Example', 'Algorithm for Inserting an Element', 'Python, Java and C/C++ Examples']",[],['//cdn.programiz.com/sites/tutorial2program/files/insertion.png'],"['Let us understand these events below.', 'The elements to be inserted are 8, 9, 10, 11, 15, 20, 17.']",['Let us understand the insertion operation with the illustrations below.'],['Inserting an element on a B-tree consists of two events: searching the appropriate node to insert the element and splitting the node if required.Insertion operation always takes place in the bottom-up approach.'],"['BreeInsertion(T, k)', 'r  root[T]', 'if n[r] = 2t - 1', '    s = AllocateNode()', '    root[T] = s', '    leaf[s] = FALSE', '    n[s] <- 0', '    c1[s] <- r', '    BtreeSplitChild(s, 1, r)', '    BtreeInsertNonFull(s, k)', 'else BtreeInsertNonFull(r, k)', 'BtreeInsertNonFull(x, k)', 'i = n[x]', 'if leaf[x]', '        keyi+1 [x] = keyi[x]', '        i = i - 1', '    keyi+1[x] = k', '    n[x] = n[x] + 1', '        i = i - 1', '    i = i + 1', '    if n[ci[x]] == 2t - 1', '        if k &rt; keyi[x]', '            i = i + 1', 'BtreeSplitChild(x, i)', 'BtreeSplitChild(x, i, y)', 'z = AllocateNode()', 'leaf[z] = leaf[y]', 'n[z] = t - 1', 'for j = 1 to t - 1', '    keyj[z] = keyj+t[y]', 'if not leaf [y]', '    for j = 1 to t', '        cj[z] = cj + t[y]', 'n[y] = t - 1', 'for j = n[x] + 1 to i + 1', '    cj+1[x] = cj[x]', 'ci+1[x] = z', 'for j = n[x] to i', '    keyj+1[x] = keyj[x]', 'keyi[x] = keyt[y]', 'n[x] = n[x] + 1', '# Create a node', 'class BTreeNode:', '        self.leaf = leaf', '        self.keys = []', '        self.child = []', 'class BTree:', '    def __init__(self, t):', '        self.t = t', '    # Insert node', '    def insert(self, k):', '        root = self.root', '            temp = BTreeNode()', '            self.root = temp', '        else:', '    # Insert nonfull', '        i = len(x.keys) - 1', '        if x.leaf:', '                i -= 1', '            x.keys[i + 1] = k', '        else:', '                i -= 1', '            i += 1', '                    i += 1', '    # Split the child', '        t = self.t', '        y = x.child[i]', '        z = BTreeNode(y.leaf)', '        if not y.leaf:', '    # Print the tree', '        for i in x.keys:', '            print(i, end="" "")', '        print()', '        l += 1', '        if len(x.child) > 0:', '            for i in x.child:', 'def main():', '    B = BTree(3)', '    for i in range(10):', '        B.insert((i, 2 * i))', '    B.print_tree(B.root)', ""if __name__ == '__main__':"", '    main()', 'public class BTree {', '  private int T;', '  public class Node {', '    int n;', '    boolean leaf = true;', '    public int Find(int k) {', '          return i;', '        }', '      return -1;', '  public BTree(int t) {', '    T = t;', '    root = new Node();', '    root.n = 0;', '    root.leaf = true;', '  private Node root;', '    Node z = new Node();', '    z.leaf = y.leaf;', '    z.n = T - 1;', '      z.key[j] = y.key[j + T];', '    if (!y.leaf) {', '    y.n = T - 1;', '    x.child[pos + 1] = z;', '      x.key[j + 1] = x.key[j];', '    x.key[pos] = y.key[T - 1];', '    x.n = x.n + 1;', '    Node r = root;', '    if (r.n == 2 * T - 1) {', '      Node s = new Node();', '      root = s;', '      s.leaf = false;', '      s.n = 0;', '      s.child[0] = r;', '      split(s, 0, r);', '      _insert(s, key);', '    } else {', '      _insert(r, key);', '    if (x.leaf) {', '      int i = 0;', '      x.key[i + 1] = k;', '      x.n = x.n + 1;', '    } else {', '      int i = 0;', '      i++;', '      Node tmp = x.child[i];', '        split(x, i, tmp);', '        if (k > x.key[i]) {', '          i++;', '        }', '      _insert(x.child[i], k);', '  public void display() {', '    display(root);', '    assert (x == null);', '    if (!x.leaf) {', '        display(x.child[i]);', '    BTree b = new BTree(3);', '    b.insert(8);', '    b.insert(9);', '    b.insert(10);', '    b.insert(11);', '    b.insert(15);', '    b.insert(20);', '    b.insert(17);', '    b.display();', '#include <stdio.h>', '#include <stdlib.h>', '#define MAX 3', '#define MIN 2', 'struct btreeNode {', '  int item[MAX + 1], count;', 'struct btreeNode *root;', '  struct btreeNode *newNode;', '  newNode->item[1] = item;', '  newNode->count = 1;', '  newNode->link[0] = root;', '  newNode->link[1] = child;', '  return newNode;', '  int j = node->count;', '  while (j > pos) {', '    j--;', '  node->item[j + 1] = item;', '  node->link[j + 1] = child;', '  node->count++;', '  int median, j;', '  if (pos > MIN)', '    median = MIN + 1;', '    median = MIN;', '  j = median + 1;', '  while (j <= MAX) {', '    j++;', '  node->count = median;', '  if (pos <= MIN) {', '  } else {', '  node->count--;', '  int pos;', '  if (!node) {', '    *pval = item;', '    *child = NULL;', '    return 1;', '  if (item < node->item[1]) {', '    pos = 0;', '  } else {', '    for (pos = node->count;', '      return 0;', '    if (node->count < MAX) {', '    } else {', '      return 1;', '  return 0;', 'void insertion(int item) {', '  int flag, i;', '  struct btreeNode *child;', '  if (flag)', '  struct btreeNode *dummy;', '  dummy = myNode->link[pos];', '    dummy = dummy->link[0];', '  int j = x->count;', '  while (j > 0) {', '  x->link[1] = x->link[0];', '  x->count++;', '  x = myNode->link[pos - 1];', '  x->count--;', '  return;', '  int j = 1;', '  x->count++;', '  x = myNode->link[pos];', '  x->link[0] = x->link[1];', '  x->count--;', '  while (j <= x->count) {', '    j++;', '  return;', '  int j = 1;', '  x2->count++;', '  while (j <= x1->count) {', '    x2->count++;', '    j++;', '  j = pos;', '  while (j < myNode->count) {', '    j++;', '  myNode->count--;', '  free(x1);', '  if (!pos) {', '      leftShift(myNode, 1);', '    } else {', '      mergeNodes(myNode, 1);', '  } else {', '      } else {', '        } else {', '        }', '    } else {', '      else', '  int i;', '  if (myNode) {', 'int main() {', '  int item, ch;', '  insertion(8);', '  insertion(9);', '  insertion(10);', '  insertion(11);', '  insertion(15);', '  insertion(16);', '  insertion(17);', '  insertion(18);', '  insertion(20);', '  insertion(23);', '  traversal(root);', '#include <iostream>', 'using namespace std;', 'class Node {', '  int *keys;', '  int t;', '  Node **C;', '  int n;', '  bool leaf;', '   public:', '  Node(int _t, bool _leaf);', '  void insertNonFull(int k);', '  void traverse();', '  friend class BTree;', 'class BTree {', '  Node *root;', '  int t;', '   public:', '  BTree(int _t) {', '    root = NULL;', '    t = _t;', '  void traverse() {', '    if (root != NULL)', '      root->traverse();', '  void insert(int k);', '  t = t1;', '  leaf = leaf1;', '  keys = new int[2 * t - 1];', '  C = new Node *[2 * t];', '  n = 0;', 'void Node::traverse() {', '  int i;', '  for (i = 0; i < n; i++) {', '    if (leaf == false)', '      C[i]->traverse();', '    cout << "" "" << keys[i];', '  if (leaf == false)', '    C[i]->traverse();', 'void BTree::insert(int k) {', '  if (root == NULL) {', '    root = new Node(t, true);', '    root->keys[0] = k;', '    root->n = 1;', '  } else {', '      s->C[0] = root;', '      s->splitChild(0, root);', '      int i = 0;', '      if (s->keys[0] < k)', '        i++;', '      root = s;', '    } else', '      root->insertNonFull(k);', '  int i = n - 1;', '  if (leaf == true) {', '      keys[i + 1] = keys[i];', '      i--;', '    keys[i + 1] = k;', '    n = n + 1;', '  } else {', '      i--;', '      if (keys[i + 1] < k)', '        i++;', '  z->n = t - 1;', '  if (y->leaf == false) {', '      z->C[j] = y->C[j + t];', '  y->n = t - 1;', '    C[j + 1] = C[j];', '  C[i + 1] = z;', '    keys[j + 1] = keys[j];', '  keys[i] = y->keys[t - 1];', '  n = n + 1;', 'int main() {', '  BTree t(3);', '  t.insert(8);', '  t.insert(9);', '  t.insert(10);', '  t.insert(11);', '  t.insert(15);', '  t.insert(16);', '  t.insert(17);', '  t.insert(18);', '  t.insert(20);', '  t.insert(23);', '  cout << ""The B-tree is: "";', '  t.traverse();']","['else while i ≥ 1 and k < keyi[x]', '        BtreeSplitChild(x, i, ci[x])', '    BtreeInsertNonFull(ci[x], k)', '# Inserting a key on a B-tree in Python', '    def __init__(self, leaf=False):', '        self.root = BTreeNode(True)', '        if len(root.keys) == (2 * self.t) - 1:', '            temp.child.insert(0, root)', '            self.split_child(temp, 0)', '            self.insert_non_full(temp, k)', '            self.insert_non_full(root, k)', '    def insert_non_full(self, x, k):', '            x.keys.append((None, None))', '            while i >= 0 and k[0] < x.keys[i][0]:', '                x.keys[i + 1] = x.keys[i]', '            while i >= 0 and k[0] < x.keys[i][0]:', '            if len(x.child[i].keys) == (2 * self.t) - 1:', '                self.split_child(x, i)', '                if k[0] > x.keys[i][0]:', '            self.insert_non_full(x.child[i], k)', '    def split_child(self, x, i):', '        x.child.insert(i + 1, z)', '        x.keys.insert(i, y.keys[t - 1])', '        z.keys = y.keys[t: (2 * t) - 1]', '        y.keys = y.keys[0: t - 1]', '            z.child = y.child[t: 2 * t]', '            y.child = y.child[0: t - 1]', '    def print_tree(self, x, l=0):', '        print(""Level "", l, "" "", len(x.keys), end="":"")', '                self.print_tree(i, l)', '    int key[] = new int[2 * T - 1];', '    Node child[] = new Node[2 * T];', '      for (int i = 0; i < this.n; i++) {', '  private void split(Node x, int pos, Node y) {', '    for (int j = 0; j < T - 1; j++) {', '      for (int j = 0; j < T; j++) {', '        z.child[j] = y.child[j + T];', '    for (int j = x.n; j >= pos + 1; j--) {', '      x.child[j + 1] = x.child[j];', '    for (int j = x.n - 1; j >= pos; j--) {', '  public void insert(final int key) {', '  final private void _insert(Node x, int k) {', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '        x.key[i + 1] = x.key[i];', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '  private void display(Node x) {', '    for (int i = 0; i < x.n; i++) {', '      System.out.print(x.key[i] + "" "");', '      for (int i = 0; i < x.n + 1; i++) {', '  public static void main(String[] args) {', '  struct btreeNode *link[MAX + 1];', 'struct btreeNode *createNode(int item, struct btreeNode *child) {', '  newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));', 'void insertValue(int item, int pos, struct btreeNode *node,', '          struct btreeNode *child) {', '    node->item[j + 1] = node->item[j];', '    node->link[j + 1] = node->link[j];', 'void splitNode(int item, int *pval, int pos, struct btreeNode *node,', '         struct btreeNode *child, struct btreeNode **newNode) {', '  *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));', '    (*newNode)->item[j - median] = node->item[j];', '    (*newNode)->link[j - median] = node->link[j];', '  (*newNode)->count = MAX - median;', '    insertValue(item, pos, node, child);', '    insertValue(item, pos - median, *newNode, child);', '  *pval = node->item[node->count];', '  (*newNode)->link[0] = node->link[node->count];', 'int setNodeValue(int item, int *pval,', '           struct btreeNode *node, struct btreeNode **child) {', '       (item < node->item[pos] && pos > 1); pos--)', '    if (item == node->item[pos]) {', '      printf(""Duplicates not allowed\\n"");', '  if (setNodeValue(item, pval, node->link[pos], child)) {', '      insertValue(*pval, pos, node, *child);', '      splitNode(*pval, pval, pos, node, *child, child);', '  flag = setNodeValue(item, &i, root, &child);', '    root = createNode(i, child);', 'void copySuccessor(struct btreeNode *myNode, int pos) {', '  for (; dummy->link[0] != NULL;)', '  myNode->item[pos] = dummy->item[1];', 'void rightShift(struct btreeNode *myNode, int pos) {', '  struct btreeNode *x = myNode->link[pos];', '    x->item[j + 1] = x->item[j];', '    x->link[j + 1] = x->link[j];', '  x->item[1] = myNode->item[pos];', '  myNode->item[pos] = x->item[x->count];', '  myNode->link[pos] = x->link[x->count];', 'void leftShift(struct btreeNode *myNode, int pos) {', '  struct btreeNode *x = myNode->link[pos - 1];', '  x->item[x->count] = myNode->item[pos];', '  x->link[x->count] = myNode->link[pos]->link[0];', '  myNode->item[pos] = x->item[1];', '    x->item[j] = x->item[j + 1];', '    x->link[j] = x->link[j + 1];', 'void mergeNodes(struct btreeNode *myNode, int pos) {', '  struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];', '  x2->item[x2->count] = myNode->item[pos];', '  x2->link[x2->count] = myNode->link[0];', '    x2->item[x2->count] = x1->item[j];', '    x2->link[x2->count] = x1->link[j];', '    myNode->item[j] = myNode->item[j + 1];', '    myNode->link[j] = myNode->link[j + 1];', 'void adjustNode(struct btreeNode *myNode, int pos) {', '    if (myNode->link[1]->count > MIN) {', '      if (myNode->link[pos - 1]->count > MIN) {', '        rightShift(myNode, pos);', '        if (myNode->link[pos + 1]->count > MIN) {', '          leftShift(myNode, pos + 1);', '          mergeNodes(myNode, pos);', '      if (myNode->link[pos - 1]->count > MIN)', '        rightShift(myNode, pos);', '        mergeNodes(myNode, pos);', 'void traversal(struct btreeNode *myNode) {', '    for (i = 0; i < myNode->count; i++) {', '      traversal(myNode->link[i]);', '      printf(""%d "", myNode->item[i + 1]);', '  void splitChild(int i, Node *y);', 'Node::Node(int t1, bool leaf1) {', '      Node *s = new Node(t, false);', '      s->C[i]->insertNonFull(k);', 'void Node::insertNonFull(int k) {', '    while (i >= 0 && keys[i] > k) {', '    while (i >= 0 && keys[i] > k)', '    if (C[i + 1]->n == 2 * t - 1) {', '      splitChild(i + 1, C[i + 1]);', 'void Node::splitChild(int i, Node *y) {', '  Node *z = new Node(y->t, y->leaf);', '  for (int j = 0; j < t - 1; j++)', '    z->keys[j] = y->keys[j + t];', '  for (int j = n; j >= i + 1; j--)', '  for (int j = n - 1; j >= i; j--)']",[],[],"['If the tree is empty, allocate a root node and insert the key.|||Update the allowed number of keys in the node.|||Search the appropriate node for insertion.|||If the node is full, follow the steps below.|||Insert the elements in increasing order.|||Now, there are elements greater than its limit. So, split at the median.|||Push the median key upwards and make the left keys as a left child and the right keys as a right child.|||If the node is not full, follow the steps below.|||Insert the node in increasing order.|||']"
30,['Deletion from a B-tree'],"['In this tutorial, you will learn how to delete a key from a b-tree. Also, you will find working examples of deleting keys from a B-tree in C, C++, Java and Python.']",[],[],"['Deletion Operation', 'Python, Java and C/C++ Examples', 'Deletion Complexity']","['Case I', 'Case II', 'Case III']","['//cdn.programiz.com/sites/tutorial2program/files/delete-leaf-1.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-leaf-2.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-leaf-3.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-internal-1.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-internal-2.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-internal_3.png']","['There are three main cases for deletion operation in a B tree.', 'Best case Time complexity: Θ(log n)', 'Average case Space complexity: Θ(n)', 'Worst case Space complexity: Θ(n)']","['The terms to be understood before studying deletion operation are:', 'Before going through the steps below, one must know these facts about a B tree of degree m.', 'The key to be deleted lies in the leaf. There are two cases for it.', 'If the key to be deleted lies in the internal node, the following cases occur.']","['Deleting an element on a B-tree consists of three main events: searching the node where the key to be deleted exists, deleting the key and balancing the tree if required.', 'While deleting a tree, a condition called underflow may occur. Underflow occurs when a node contains less than the minimum number of keys it should hold.', 'In this case, the height of the tree shrinks. If the target key lies in an internal node, and the deletion of the key leads to a fewer number of keys in the node (i.e. less than the minimum required), then look for the inorder predecessor and the inorder successor. If both the children contain a minimum number of keys then, borrowing cannot take place. This leads to Case II(3) i.e. merging the children.', 'Again, look for the sibling to borrow a key. But, if the sibling also has only a minimum number of keys then, merge the node with the sibling along with the parent. Arrange the children accordingly (increasing order).']","['# Btree node', 'class BTreeNode:', '        self.leaf = leaf', '        self.keys = []', '        self.child = []', 'class BTree:', '    def __init__(self, t):', '        self.t = t', '    # Insert a key', '    def insert(self, k):', '        root = self.root', '            temp = BTreeNode()', '            self.root = temp', '        else:', '    # Insert non full', '        i = len(x.keys) - 1', '        if x.leaf:', '                i -= 1', '            x.keys[i + 1] = k', '        else:', '                i -= 1', '            i += 1', '                    i += 1', '    # Split the child', '        t = self.t', '        y = x.child[i]', '        z = BTreeNode(y.leaf)', '        if not y.leaf:', '    # Delete a node', '    def delete(self, x, k):', '        t = self.t', '        i = 0', '            i += 1', '        if x.leaf:', '                x.keys.pop(i)', '                return', '            return', '        else:', '                else:', '            elif i == 0:', '                else:', '                else:', '    # Delete internal node', '        t = self.t', '        if x.leaf:', '                x.keys.pop(i)', '                return', '            return', '            return', '            return', '        else:', '    # Delete the predecessor', '        if x.leaf:', '            return x.pop()', '        n = len(x.keys) - 1', '        else:', '    # Delete the successor', '        if x.leaf:', '        else:', '    # Delete resolution', '        cnode = x.child[i]', '        if j > i:', '            new = cnode', '            x.keys.pop(i)', '            x.child.pop(j)', '        else:', '            new = lsnode', '            x.keys.pop(j)', '            x.child.pop(i)', '            self.root = new', '    # Delete the sibling', '        cnode = x.child[i]', '        if i < j:', '            rsnode.keys.pop(0)', '        else:', '    # Print the tree', '        for i in x.keys:', '            print(i, end="" "")', '        print()', '        l += 1', '        if len(x.child) > 0:', '            for i in x.child:', 'B = BTree(3)', 'for i in range(10):', '    B.insert((i, 2 * i))', 'B.print_tree(B.root)', 'B.delete(B.root, (8,))', 'print(""\\n"")', 'B.print_tree(B.root)', 'import java.util.Stack;', 'public class BTree {', '  private int T;', '  public class Node {', '    int n;', '    boolean leaf = true;', '    public int Find(int k) {', '          return i;', '        }', '      return -1;', '  public BTree(int t) {', '    T = t;', '    root = new Node();', '    root.n = 0;', '    root.leaf = true;', '  private Node root;', '    int i = 0;', '    if (x == null)', '      return x;', '      if (key < x.key[i]) {', '        break;', '      if (key == x.key[i]) {', '        return x;', '    if (x.leaf) {', '      return null;', '    } else {', '    Node z = new Node();', '    z.leaf = y.leaf;', '    z.n = T - 1;', '      z.key[j] = y.key[j + T];', '    if (!y.leaf) {', '    y.n = T - 1;', '    x.child[pos + 1] = z;', '      x.key[j + 1] = x.key[j];', '    x.key[pos] = y.key[T - 1];', '    x.n = x.n + 1;', '    Node r = root;', '    if (r.n == 2 * T - 1) {', '      Node s = new Node();', '      root = s;', '      s.leaf = false;', '      s.n = 0;', '      s.child[0] = r;', '      Split(s, 0, r);', '      _Insert(s, key);', '    } else {', '      _Insert(r, key);', '    if (x.leaf) {', '      int i = 0;', '      x.key[i + 1] = k;', '      x.n = x.n + 1;', '    } else {', '      int i = 0;', '      i++;', '      Node tmp = x.child[i];', '        Split(x, i, tmp);', '        if (k > x.key[i]) {', '          i++;', '        }', '      _Insert(x.child[i], k);', '  public void Show() {', '    Show(root);', '    int pos = x.Find(key);', '    if (pos != -1) {', '      if (x.leaf) {', '        int i = 0;', '        }', '        ;', '        for (; i < x.n; i++) {', '          }', '        }', '        x.n--;', '        return;', '      if (!x.leaf) {', '        int predKey = 0;', '        if (pred.n >= T) {', '          for (;;) {', '            if (pred.leaf) {', '              break;', '            } else {', '            }', '          }', '          return;', '        }', '        if (nextNode.n >= T) {', '            for (;;) {', '                break;', '              } else {', '              }', '            }', '          }', '          return;', '        }', '        int temp = pred.n + 1;', '          pred.n++;', '        }', '        }', '        x.child[pos] = pred;', '          }', '        }', '          }', '        }', '        x.n--;', '        if (x.n == 0) {', '          if (x == root) {', '            root = x.child[0];', '          }', '          x = x.child[0];', '        }', '        Remove(pred, key);', '        return;', '    } else {', '          break;', '        }', '      Node tmp = x.child[pos];', '      if (tmp.n >= T) {', '        Remove(tmp, key);', '        return;', '      if (true) {', '        Node nb = null;', '        int devider = -1;', '          }', '          }', '          nb.n--;', '          Remove(tmp, key);', '          return;', '          nb.n--;', '          }', '          }', '          tmp.n++;', '          Remove(tmp, key);', '          return;', '        } else {', '          Node lt = null;', '          Node rt = null;', '          if (pos != x.n) {', '            lt = x.child[pos];', '          } else {', '            rt = x.child[pos];', '            last = true;', '            pos--;', '          }', '          }', '          }', '          x.n--;', '            if (i < rt.n) {', '            }', '          }', '          lt.n += rt.n;', '          if (x.n == 0) {', '            if (x == root) {', '            }', '            x = x.child[0];', '          }', '          Remove(lt, key);', '          return;', '        }', '    if (x == null) {', '      return;', '    Remove(root, key);', '    FindKeys(a, b, root, st);', '    int i = 0;', '      if (x.key[i] > a) {', '        st.push(x.key[i]);', '    if (!x.leaf) {', '      return true;', '    } else {', '      return false;', '  private void Show(Node x) {', '    assert (x == null);', '    if (!x.leaf) {', '        Show(x.child[i]);', '    BTree b = new BTree(3);', '    b.Insert(8);', '    b.Insert(9);', '    b.Insert(10);', '    b.Insert(11);', '    b.Insert(15);', '    b.Insert(20);', '    b.Insert(17);', '    b.Show();', '    b.Remove(10);', '    System.out.println();', '    b.Show();', '#include <stdio.h>', '#include <stdlib.h>', '#define MAX 3', '#define MIN 2', 'struct BTreeNode {', '  int item[MAX + 1], count;', 'struct BTreeNode *root;', '  struct BTreeNode *newNode;', '  newNode->item[1] = item;', '  newNode->count = 1;', '  newNode->linker[0] = root;', '  newNode->linker[1] = child;', '  return newNode;', '  int j = node->count;', '  while (j > pos) {', '    j--;', '  node->item[j + 1] = item;', '  node->linker[j + 1] = child;', '  node->count++;', '  int median, j;', '  if (pos > MIN)', '    median = MIN + 1;', '    median = MIN;', '  j = median + 1;', '  while (j <= MAX) {', '    j++;', '  node->count = median;', '  if (pos <= MIN) {', '  } else {', '  node->count--;', '  int pos;', '  if (!node) {', '    *pval = item;', '    *child = NULL;', '    return 1;', '  if (item < node->item[1]) {', '    pos = 0;', '  } else {', '    for (pos = node->count;', '      return 0;', '    if (node->count < MAX) {', '    } else {', '      return 1;', '  return 0;', 'void insertion(int item) {', '  int flag, i;', '  struct BTreeNode *child;', '  if (flag)', '  struct BTreeNode *dummy;', '  dummy = myNode->linker[pos];', '    dummy = dummy->linker[0];', '  int i = pos + 1;', '  while (i <= myNode->count) {', '    i++;', '  myNode->count--;', '  int j = x->count;', '  while (j > 0) {', '  x->linker[1] = x->linker[0];', '  x->count++;', '  x = myNode->linker[pos - 1];', '  x->count--;', '  return;', '  int j = 1;', '  x->count++;', '  x = myNode->linker[pos];', '  x->linker[0] = x->linker[1];', '  x->count--;', '  while (j <= x->count) {', '    j++;', '  return;', '  int j = 1;', '  x2->count++;', '  while (j <= x1->count) {', '    x2->count++;', '    j++;', '  j = pos;', '  while (j < myNode->count) {', '    j++;', '  myNode->count--;', '  free(x1);', '  if (!pos) {', '      leftShift(myNode, 1);', '    } else {', '      mergeNodes(myNode, 1);', '  } else {', '      } else {', '        } else {', '        }', '    } else {', '      else', '  int pos, flag = 0;', '  if (myNode) {', '      pos = 0;', '      flag = 0;', '    } else {', '        ;', '        flag = 1;', '      } else {', '        flag = 0;', '    if (flag) {', '        if (flag == 0) {', '        }', '      } else {', '    } else {', '    if (myNode->linker[pos]) {', '  return flag;', '  struct BTreeNode *tmp;', '    printf(""Not present\\n"");', '    return;', '  } else {', '    if (myNode->count == 0) {', '      tmp = myNode;', '      free(tmp);', '  root = myNode;', '  return;', '  if (!myNode) {', '    return;', '    *pos = 0;', '  } else {', '    for (*pos = myNode->count;', '      return;', '  return;', '  int i;', '  if (myNode) {', 'int main() {', '  int item, ch;', '  insertion(8);', '  insertion(9);', '  insertion(10);', '  insertion(11);', '  insertion(15);', '  insertion(16);', '  insertion(17);', '  insertion(18);', '  insertion(20);', '  insertion(23);', '  traversal(root);', '  delete (20, root);', '  printf(""\\n"");', '  traversal(root);', '#include <iostream>', 'using namespace std;', 'class BTreeNode {', '  int *keys;', '  int t;', '  BTreeNode **C;', '  int n;', '  bool leaf;', '   public:', '  void traverse();', '  int findKey(int k);', '  void insertNonFull(int k);', '  void deletion(int k);', '  int getPredecessor(int idx);', '  int getSuccessor(int idx);', '  void fill(int idx);', '  void merge(int idx);', '  friend class BTree;', 'class BTree {', '  BTreeNode *root;', '  int t;', '   public:', '  BTree(int _t) {', '    root = NULL;', '    t = _t;', '  void traverse() {', '    if (root != NULL)', '      root->traverse();', '  void insertion(int k);', '  void deletion(int k);', '  t = t1;', '  leaf = leaf1;', '  keys = new int[2 * t - 1];', '  C = new BTreeNode *[2 * t];', '  n = 0;', '  int idx = 0;', '    ++idx;', '  return idx;', '  int idx = findKey(k);', '    if (leaf)', '      removeFromLeaf(idx);', '    else', '      removeFromNonLeaf(idx);', '  } else {', '    if (leaf) {', '      return;', '    if (C[idx]->n < t)', '      fill(idx);', '    if (flag && idx > n)', '      C[idx - 1]->deletion(k);', '    else', '      C[idx]->deletion(k);', '  return;', '    keys[i - 1] = keys[i];', '  return;', '  int k = keys[idx];', '  if (C[idx]->n >= t) {', '    keys[idx] = pred;', '    C[idx]->deletion(pred);', '    keys[idx] = succ;', '  else {', '    merge(idx);', '    C[idx]->deletion(k);', '  return;', '  BTreeNode *cur = C[idx];', '  while (!cur->leaf)', '    cur = cur->C[cur->n];', '  BTreeNode *cur = C[idx + 1];', '  while (!cur->leaf)', '    cur = cur->C[0];', '  return cur->keys[0];', '    borrowFromPrev(idx);', '    borrowFromNext(idx);', '  else {', '    if (idx != n)', '      merge(idx);', '    else', '      merge(idx - 1);', '  return;', '  BTreeNode *child = C[idx];', '  if (!child->leaf) {', '  if (!child->leaf)', '  child->n += 1;', '  sibling->n -= 1;', '  return;', '  BTreeNode *child = C[idx];', '  if (!(child->leaf))', '  if (!sibling->leaf) {', '  child->n += 1;', '  sibling->n -= 1;', '  return;', '  BTreeNode *child = C[idx];', '  if (!child->leaf) {', '    keys[i - 1] = keys[i];', '    C[i - 1] = C[i];', '  child->n += sibling->n + 1;', '  delete (sibling);', '  return;', 'void BTree::insertion(int k) {', '  if (root == NULL) {', '    root->keys[0] = k;', '    root->n = 1;', '  } else {', '      s->C[0] = root;', '      s->splitChild(0, root);', '      int i = 0;', '      if (s->keys[0] < k)', '        i++;', '      root = s;', '    } else', '      root->insertNonFull(k);', '  int i = n - 1;', '  if (leaf == true) {', '      keys[i + 1] = keys[i];', '      i--;', '    keys[i + 1] = k;', '    n = n + 1;', '  } else {', '      i--;', '      if (keys[i + 1] < k)', '        i++;', '  z->n = t - 1;', '  if (y->leaf == false) {', '      z->C[j] = y->C[j + t];', '  y->n = t - 1;', '    C[j + 1] = C[j];', '  C[i + 1] = z;', '    keys[j + 1] = keys[j];', '  keys[i] = y->keys[t - 1];', '  n = n + 1;', 'void BTreeNode::traverse() {', '  int i;', '  for (i = 0; i < n; i++) {', '    if (leaf == false)', '      C[i]->traverse();', '    cout << "" "" << keys[i];', '  if (leaf == false)', '    C[i]->traverse();', 'void BTree::deletion(int k) {', '  if (!root) {', '    return;', '  root->deletion(k);', '  if (root->n == 0) {', '    BTreeNode *tmp = root;', '    if (root->leaf)', '      root = NULL;', '    else', '      root = root->C[0];', '    delete tmp;', '  return;', 'int main() {', '  BTree t(3);', '  t.insertion(8);', '  t.insertion(9);', '  t.insertion(10);', '  t.insertion(11);', '  t.insertion(15);', '  t.insertion(16);', '  t.insertion(17);', '  t.insertion(18);', '  t.insertion(20);', '  t.insertion(23);', '  cout << ""The B-tree is: "";', '  t.traverse();', '  t.deletion(20);', '  cout << ""\\nThe B-tree is: "";', '  t.traverse();']","['# Deleting a key on a B-tree in Python', '    def __init__(self, leaf=False):', '        self.root = BTreeNode(True)', '        if len(root.keys) == (2 * self.t) - 1:', '            temp.child.insert(0, root)', '            self.split_child(temp, 0)', '            self.insert_non_full(temp, k)', '            self.insert_non_full(root, k)', '    def insert_non_full(self, x, k):', '            x.keys.append((None, None))', '            while i >= 0 and k[0] < x.keys[i][0]:', '                x.keys[i + 1] = x.keys[i]', '            while i >= 0 and k[0] < x.keys[i][0]:', '            if len(x.child[i].keys) == (2 * self.t) - 1:', '                self.split_child(x, i)', '                if k[0] > x.keys[i][0]:', '            self.insert_non_full(x.child[i], k)', '    def split_child(self, x, i):', '        x.child.insert(i + 1, z)', '        x.keys.insert(i, y.keys[t - 1])', '        z.keys = y.keys[t: (2 * t) - 1]', '        y.keys = y.keys[0: t - 1]', '            z.child = y.child[t: 2 * t]', '            y.child = y.child[0: t - 1]', '        while i < len(x.keys) and k[0] > x.keys[i][0]:', '            if i < len(x.keys) and x.keys[i][0] == k[0]:', '        if i < len(x.keys) and x.keys[i][0] == k[0]:', '            return self.delete_internal_node(x, k, i)', '        elif len(x.child[i].keys) >= t:', '            self.delete(x.child[i], k)', '            if i != 0 and i + 2 < len(x.child):', '                if len(x.child[i - 1].keys) >= t:', '                    self.delete_sibling(x, i, i - 1)', '                elif len(x.child[i + 1].keys) >= t:', '                    self.delete_sibling(x, i, i + 1)', '                    self.delete_merge(x, i, i + 1)', '                if len(x.child[i + 1].keys) >= t:', '                    self.delete_sibling(x, i, i + 1)', '                    self.delete_merge(x, i, i + 1)', '            elif i + 1 == len(x.child):', '                if len(x.child[i - 1].keys) >= t:', '                    self.delete_sibling(x, i, i - 1)', '                    self.delete_merge(x, i, i - 1)', '            self.delete(x.child[i], k)', '    def delete_internal_node(self, x, k, i):', '            if x.keys[i][0] == k[0]:', '        if len(x.child[i].keys) >= t:', '            x.keys[i] = self.delete_predecessor(x.child[i])', '        elif len(x.child[i + 1].keys) >= t:', '            x.keys[i] = self.delete_successor(x.child[i + 1])', '            self.delete_merge(x, i, i + 1)', '            self.delete_internal_node(x.child[i], k, self.t - 1)', '    def delete_predecessor(self, x):', '        if len(x.child[n].keys) >= self.t:', '            self.delete_sibling(x, n + 1, n)', '            self.delete_merge(x, n, n + 1)', '        self.delete_predecessor(x.child[n])', '    def delete_successor(self, x):', '            return x.keys.pop(0)', '        if len(x.child[1].keys) >= self.t:', '            self.delete_sibling(x, 0, 1)', '            self.delete_merge(x, 0, 1)', '        self.delete_successor(x.child[0])', '    def delete_merge(self, x, i, j):', '            cnode.keys.append(x.keys[i])', '            for k in range(len(rsnode.keys)):', '                cnode.keys.append(rsnode.keys[k])', '                if len(rsnode.child) > 0:', '                    cnode.child.append(rsnode.child[k])', '            if len(rsnode.child) > 0:', '                cnode.child.append(rsnode.child.pop())', '            lsnode.keys.append(x.keys[j])', '            for i in range(len(cnode.keys)):', '                lsnode.keys.append(cnode.keys[i])', '                if len(lsnode.child) > 0:', '                    lsnode.child.append(cnode.child[i])', '            if len(lsnode.child) > 0:', '                lsnode.child.append(cnode.child.pop())', '        if x == self.root and len(x.keys) == 0:', '    def delete_sibling(self, x, i, j):', '            cnode.keys.append(x.keys[i])', '            x.keys[i] = rsnode.keys[0]', '            if len(rsnode.child) > 0:', '                cnode.child.append(rsnode.child[0])', '                rsnode.child.pop(0)', '            cnode.keys.insert(0, x.keys[i - 1])', '            x.keys[i - 1] = lsnode.keys.pop()', '            if len(lsnode.child) > 0:', '                cnode.child.insert(0, lsnode.child.pop())', '    def print_tree(self, x, l=0):', '        print(""Level "", l, "" "", len(x.keys), end="":"")', '                self.print_tree(i, l)', '    int key[] = new int[2 * T - 1];', '    Node child[] = new Node[2 * T];', '      for (int i = 0; i < this.n; i++) {', '  private Node Search(Node x, int key) {', '      return Search(x.child[i], key);', '  private void Split(Node x, int pos, Node y) {', '    for (int j = 0; j < T - 1; j++) {', '      for (int j = 0; j < T; j++) {', '        z.child[j] = y.child[j + T];', '    for (int j = x.n; j >= pos + 1; j--) {', '      x.child[j + 1] = x.child[j];', '    for (int j = x.n - 1; j >= pos; j--) {', '  public void Insert(final int key) {', '  final private void _Insert(Node x, int k) {', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '        x.key[i + 1] = x.key[i];', '      for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {', '  private void Remove(Node x, int key) {', '        for (i = 0; i < x.n && x.key[i] != key; i++) {', '            x.key[i] = x.key[i + 1];', '        Node pred = x.child[pos];', '              System.out.println(pred.n);', '              predKey = pred.key[pred.n - 1];', '              pred = pred.child[pred.n];', '          Remove(pred, predKey);', '        Node nextNode = x.child[pos + 1];', '          int nextKey = nextNode.key[0];', '            nextNode = nextNode.child[0];', '              if (nextNode.leaf) {', '                nextKey = nextNode.key[nextNode.n - 1];', '                nextNode = nextNode.child[nextNode.n];', '          Remove(nextNode, nextKey);', '        pred.key[pred.n++] = x.key[pos];', '        for (int i = 0, j = pred.n; i < nextNode.n; i++) {', '          pred.key[j++] = nextNode.key[i];', '        for (int i = 0; i < nextNode.n + 1; i++) {', '          pred.child[temp++] = nextNode.child[i];', '        for (int i = pos; i < x.n; i++) {', '            x.key[i] = x.key[i + 1];', '        for (int i = pos + 1; i < x.n + 1; i++) {', '            x.child[i] = x.child[i + 1];', '      for (pos = 0; pos < x.n; pos++) {', '        if (pos != x.n && x.child[pos + 1].n >= T) {', '          nb = x.child[pos + 1];', '          x.key[pos] = nb.key[0];', '          tmp.key[tmp.n++] = devider;', '          tmp.child[tmp.n] = nb.child[0];', '          for (int i = 1; i < nb.n; i++) {', '            nb.key[i - 1] = nb.key[i];', '          for (int i = 1; i <= nb.n; i++) {', '            nb.child[i - 1] = nb.child[i];', '        } else if (pos != 0 && x.child[pos - 1].n >= T) {', '          devider = x.key[pos - 1];', '          nb = x.child[pos - 1];', '          x.key[pos - 1] = nb.key[nb.n - 1];', '          Node child = nb.child[nb.n];', '          for (int i = tmp.n; i > 0; i--) {', '            tmp.key[i] = tmp.key[i - 1];', '          for (int i = tmp.n + 1; i > 0; i--) {', '            tmp.child[i] = tmp.child[i - 1];', '            devider = x.key[pos];', '            rt = x.child[pos + 1];', '            devider = x.key[pos - 1];', '            lt = x.child[pos - 1];', '          for (int i = pos; i < x.n - 1; i++) {', '            x.key[i] = x.key[i + 1];', '          for (int i = pos + 1; i < x.n; i++) {', '            x.child[i] = x.child[i + 1];', '          lt.key[lt.n++] = devider;', '          for (int i = 0, j = lt.n; i < rt.n + 1; i++, j++) {', '              lt.key[j] = rt.key[i];', '            lt.child[j] = rt.child[i];', '              root = x.child[0];', '  public void Task(int a, int b) {', '    Stack<Integer> st = new Stack<>();', '    while (st.isEmpty() == false) {', '      this.Remove(root, st.pop());', '  private void FindKeys(int a, int b, Node x, Stack<Integer> st) {', '    for (i = 0; i < x.n && x.key[i] < b; i++) {', '      for (int j = 0; j < i + 1; j++) {', '        FindKeys(a, b, x.child[j], st);', '  public boolean Contain(int k) {', '    if (this.Search(root, k) != null) {', '    for (int i = 0; i < x.n; i++) {', '      System.out.print(x.key[i] + "" "");', '      for (int i = 0; i < x.n + 1; i++) {', '  public static void main(String[] args) {', '  struct BTreeNode *linker[MAX + 1];', 'struct BTreeNode *createNode(int item, struct BTreeNode *child) {', '  newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));', 'void addValToNode(int item, int pos, struct BTreeNode *node,', '          struct BTreeNode *child) {', '    node->item[j + 1] = node->item[j];', '    node->linker[j + 1] = node->linker[j];', 'void splitNode(int item, int *pval, int pos, struct BTreeNode *node,', '         struct BTreeNode *child, struct BTreeNode **newNode) {', '  *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));', '    (*newNode)->item[j - median] = node->item[j];', '    (*newNode)->linker[j - median] = node->linker[j];', '  (*newNode)->count = MAX - median;', '    addValToNode(item, pos, node, child);', '    addValToNode(item, pos - median, *newNode, child);', '  *pval = node->item[node->count];', '  (*newNode)->linker[0] = node->linker[node->count];', 'int setValueInNode(int item, int *pval,', '           struct BTreeNode *node, struct BTreeNode **child) {', '       (item < node->item[pos] && pos > 1); pos--)', '    if (item == node->item[pos]) {', '      printf(""Duplicates not allowed\\n"");', '  if (setValueInNode(item, pval, node->linker[pos], child)) {', '      addValToNode(*pval, pos, node, *child);', '      splitNode(*pval, pval, pos, node, *child, child);', '  flag = setValueInNode(item, &i, root, &child);', '    root = createNode(i, child);', 'void copySuccessor(struct BTreeNode *myNode, int pos) {', '  for (; dummy->linker[0] != NULL;)', '  myNode->item[pos] = dummy->item[1];', 'void removeVal(struct BTreeNode *myNode, int pos) {', '    myNode->item[i - 1] = myNode->item[i];', '    myNode->linker[i - 1] = myNode->linker[i];', 'void rightShift(struct BTreeNode *myNode, int pos) {', '  struct BTreeNode *x = myNode->linker[pos];', '    x->item[j + 1] = x->item[j];', '    x->linker[j + 1] = x->linker[j];', '  x->item[1] = myNode->item[pos];', '  myNode->item[pos] = x->item[x->count];', '  myNode->linker[pos] = x->linker[x->count];', 'void leftShift(struct BTreeNode *myNode, int pos) {', '  struct BTreeNode *x = myNode->linker[pos - 1];', '  x->item[x->count] = myNode->item[pos];', '  x->linker[x->count] = myNode->linker[pos]->linker[0];', '  myNode->item[pos] = x->item[1];', '    x->item[j] = x->item[j + 1];', '    x->linker[j] = x->linker[j + 1];', 'void mergeNodes(struct BTreeNode *myNode, int pos) {', '  struct BTreeNode *x1 = myNode->linker[pos], *x2 = myNode->linker[pos - 1];', '  x2->item[x2->count] = myNode->item[pos];', '  x2->linker[x2->count] = myNode->linker[0];', '    x2->item[x2->count] = x1->item[j];', '    x2->linker[x2->count] = x1->linker[j];', '    myNode->item[j] = myNode->item[j + 1];', '    myNode->linker[j] = myNode->linker[j + 1];', 'void adjustNode(struct BTreeNode *myNode, int pos) {', '    if (myNode->linker[1]->count > MIN) {', '      if (myNode->linker[pos - 1]->count > MIN) {', '        rightShift(myNode, pos);', '        if (myNode->linker[pos + 1]->count > MIN) {', '          leftShift(myNode, pos + 1);', '          mergeNodes(myNode, pos);', '      if (myNode->linker[pos - 1]->count > MIN)', '        rightShift(myNode, pos);', '        mergeNodes(myNode, pos);', 'int delValFromNode(int item, struct BTreeNode *myNode) {', '    if (item < myNode->item[1]) {', '      for (pos = myNode->count; (item < myNode->item[pos] && pos > 1); pos--)', '      if (item == myNode->item[pos]) {', '      if (myNode->linker[pos - 1]) {', '        copySuccessor(myNode, pos);', '        flag = delValFromNode(myNode->item[pos], myNode->linker[pos]);', '          printf(""Given data is not present in B-Tree\\n"");', '      flag = delValFromNode(item, myNode->linker[pos]);', '      if (myNode->linker[pos]->count < MIN)', '        adjustNode(myNode, pos);', 'void delete (int item, struct BTreeNode *myNode) {', '  if (!delValFromNode(item, myNode)) {', '      myNode = myNode->linker[0];', 'void searching(int item, int *pos, struct BTreeNode *myNode) {', '       (item < myNode->item[*pos] && *pos > 1); (*pos)--)', '    if (item == myNode->item[*pos]) {', '      printf(""%d present in B-tree"", item);', '  searching(item, pos, myNode->linker[*pos]);', 'void traversal(struct BTreeNode *myNode) {', '    for (i = 0; i < myNode->count; i++) {', '      traversal(myNode->linker[i]);', '      printf(""%d "", myNode->item[i + 1]);', '    traversal(myNode->linker[i]);', '  BTreeNode(int _t, bool _leaf);', '  void splitChild(int i, BTreeNode *y);', '  void removeFromNonLeaf(int idx);', 'BTreeNode::BTreeNode(int t1, bool leaf1) {', '  while (idx < n && keys[idx] < k)', 'void BTreeNode::deletion(int k) {', '  if (idx < n && keys[idx] == k) {', '      cout << ""The key "" << k << "" is does not exist in the tree\\n"";', '    bool flag = ((idx == n) ? true : false);', 'void BTreeNode::removeFromLeaf(int idx) {', '  for (int i = idx + 1; i < n; ++i)', 'void BTreeNode::removeFromNonLeaf(int idx) {', '    int pred = getPredecessor(idx);', '  else if (C[idx + 1]->n >= t) {', '    int succ = getSuccessor(idx);', 'int BTreeNode::getPredecessor(int idx) {', 'int BTreeNode::getSuccessor(int idx) {', '  if (idx != 0 && C[idx - 1]->n >= t)', '  else if (idx != n && C[idx + 1]->n >= t)', 'void BTreeNode::borrowFromPrev(int idx) {', '  BTreeNode *sibling = C[idx - 1];', '  for (int i = child->n - 1; i >= 0; --i)', '    child->keys[i + 1] = child->keys[i];', '    for (int i = child->n; i >= 0; --i)', '      child->C[i + 1] = child->C[i];', '  child->keys[0] = keys[idx - 1];', '    child->C[0] = sibling->C[sibling->n];', '  keys[idx - 1] = sibling->keys[sibling->n - 1];', 'void BTreeNode::borrowFromNext(int idx) {', '  BTreeNode *sibling = C[idx + 1];', '  child->keys[(child->n)] = keys[idx];', '    child->C[(child->n) + 1] = sibling->C[0];', '  for (int i = 1; i < sibling->n; ++i)', '    sibling->keys[i - 1] = sibling->keys[i];', '    for (int i = 1; i <= sibling->n; ++i)', '      sibling->C[i - 1] = sibling->C[i];', 'void BTreeNode::merge(int idx) {', '  BTreeNode *sibling = C[idx + 1];', '  child->keys[t - 1] = keys[idx];', '  for (int i = 0; i < sibling->n; ++i)', '    child->keys[i + t] = sibling->keys[i];', '    for (int i = 0; i <= sibling->n; ++i)', '      child->C[i + t] = sibling->C[i];', '  for (int i = idx + 1; i < n; ++i)', '  for (int i = idx + 2; i <= n; ++i)', '    root = new BTreeNode(t, true);', '      BTreeNode *s = new BTreeNode(t, false);', '      s->C[i]->insertNonFull(k);', 'void BTreeNode::insertNonFull(int k) {', '    while (i >= 0 && keys[i] > k) {', '    while (i >= 0 && keys[i] > k)', '    if (C[i + 1]->n == 2 * t - 1) {', '      splitChild(i + 1, C[i + 1]);', 'void BTreeNode::splitChild(int i, BTreeNode *y) {', '  BTreeNode *z = new BTreeNode(y->t, y->leaf);', '  for (int j = 0; j < t - 1; j++)', '    z->keys[j] = y->keys[j + t];', '  for (int j = n; j >= i + 1; j--)', '  for (int j = n - 1; j >= i; j--)', '    cout << ""The tree is empty\\n"";']",[],[],"['Inorder Predecessor|||The largest key on the left child of a node is called its inorder predecessor.|||Inorder Successor|||The smallest key on the right child of a node is called its inorder successor.|||A node can have a maximum of m children. (i.e. 3)|||A node can contain a maximum of m - 1 keys. (i.e. 2)|||A node should have a minimum of ⌈m/2⌉ children. (i.e. 2)|||A node (except root node) should contain a minimum of ⌈m/2⌉ - 1 keys. (i.e. 1)|||The deletion of the key does not violate the property of the minimum number of keys a node should hold.|||In the tree below, deleting 32 does not violate the above properties.|||Deleting a leaf key (32) from B-tree|||The deletion of the key violates the property of the minimum number of keys a node should hold. In this case, we borrow a key from its immediate neighboring sibling node in the order of left to right.|||First, visit the immediate left sibling. If the left sibling node has more than a minimum number of keys, then borrow a key from this node.|||Else, check to borrow from the immediate right sibling node.|||In the tree below, deleting 31 results in the above condition. Let us borrow a key from the left sibling node.|||Deleting a leaf key (31)|||If both the immediate sibling nodes already have a minimum number of keys, then merge the node with either the left sibling node or the right sibling node. This merging is done through the parent node.|||Deleting 30 results in the above case.|||\xa0|||Delete a leaf key (30)|||The internal node, which is deleted, is replaced by an inorder predecessor if the left child has more than the minimum number of keys.|||Deleting an internal node (33)|||The internal node, which is deleted, is replaced by an inorder successor if the right child has more than the minimum number of keys.|||If either child has exactly a minimum number of keys then, merge the left and the right children.|||\xa0|||Deleting an internal node (30)|||After merging if the parent node has less than the minimum number of keys then, look for the siblings as in Case I.|||']"
31,['B+ Tree'],"['In this tutorial, you will learn what a B+ tree is. Also, you will find working examples of searching operation on a B+ tree in C, C++, Java and Python.']",[],[],"['Properties of a B+ Tree', 'Comparison between a B-tree and a B+ Tree', 'Searching on a B+ Tree', 'Searching Example on a B+ Tree', 'Python, Java and C/C++ Examples', 'Search Complexity', 'B+ Tree Applications']",['Time Complexity'],"['//cdn.programiz.com/sites/tutorial2program/files/multilevel-indexing.png', '//cdn.programiz.com/sites/tutorial2program/files/B-tree.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/search-tree.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree-1.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree-2.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree-3.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree-4.png', '//cdn.programiz.com/sites/tutorial2program/files/B+tree-5.png']","['Operations on a B+ tree are faster than on a B-tree.', 'Let us search k = 45 on the following B+ tree.']","['A B+ tree is an advanced form of a self-balancing tree in which all the values are present in the leaf level.', 'The leaves are not connected with each other on a B-tree whereas they are connected on a B+ tree.', 'The following steps are followed to search for data in a B+ Tree of order m. Let the data to be searched be k.', 'If linear search is implemented inside a node, then total complexity is Θ(logt n).', 'If binary search is used, then total complexity is Θ(log2t.logt n).']","['An important concept to be understood before learning B+ tree is multilevel indexing. In multilevel indexing, the index of indices is created as in figure below. It makes accessing the data easier and faster.', 'The data pointers are present only at the leaf nodes on a B+ tree whereas the data pointers are present in the internal, leaf or root nodes on a B-tree.']","['# B+ tee in python', 'import math', '# Node creation', 'class Node:', '    def __init__(self, order):', '        self.order = order', '        self.values = []', '        self.keys = []', '        self.nextKey = None', '        self.parent = None', '    # Insert at the leaf', '        if (self.values):', '                    break', '                    break', '                    break', '        else:', '# B plus tree', 'class BplusTree:', '    def __init__(self, order):', '    # Insert operation', '        value = str(value)', '    def search(self, value):', '                    break', '                    break', '                    break', '        return current_node', '    # Find the node', '        l = self.search(value)', '            if item == value:', '                else:', '        return False', '    # Inserting at the parent', '        if (self.root == n):', '            return', '        parentNode = n.parent', '                    else:', '    # Delete a node', '        temp = 0', '            if item == value:', '                temp = 1', '                    else:', '                else:', '                    return', '        if temp == 0:', '            return', '    # Delete an entry', '                    break', '                    break', '            del node_', '            return', '            is_predecessor = 0', '            PrevNode = -1', '            NextNode = -1', '            PrevK = -1', '            PostK = -1', '                    if i > 0:', '            if PrevNode == -1:', '                value_ = PostK', '                value_ = PrevK', '            else:', '                else:', '                else:', '                del node_', '            else:', '                    else:', '                else:', '                    else:', '# Print the tree', 'def printTree(tree):', '    lst = [tree.root]', '    level = [0]', '    leaf = None', '    flag = 0', '    lev_leaf = 0', '    while (len(lst) != 0):', '        x = lst.pop(0)', '        lev = level.pop(0)', '        else:', '            if (flag == 0):', '                lev_leaf = lev', '                leaf = x', '                flag = 1', 'record_len = 3', ""bplustree.insert('5', '33')"", ""bplustree.insert('15', '21')"", ""bplustree.insert('25', '31')"", ""bplustree.insert('35', '41')"", ""bplustree.insert('45', '10')"", 'printTree(bplustree)', ""if(bplustree.find('5', '34')):"", '    print(""Found"")', '    print(""Not found"")', 'import java.util.*;', 'public class BPlusTree {', '  int m;', '  InternalNode root;', '  LeafNode firstLeaf;', '      @Override', '        return a.compareTo(b);', '    int i;', '      if (key < keys[i]) {', '        break;', '      return (LeafNode) child;', '    } else {', '    int i;', '      if (key < keys[i]) {', '        break;', '    } else {', '    int i;', '        break;', '    return i;', '  private int getMidpoint() {', '    InternalNode sibling;', '    if (this.root == in) {', '            this.root = null;', '          }', '        }', '          in.removePointer(i);', '        }', '  private boolean isEmpty() {', '    return firstLeaf == null;', '      if (dps[i] == null) {', '        return i;', '    return -1;', '        return i;', '    return -1;', '    pointers = newPointers;', '      @Override', '          return 0;', '        }', '        if (o1 == null) {', '          return 1;', '        }', '        if (o2 == null) {', '          return -1;', '        }', '      in.removePointer(i);', '    return halfPointers;', '      ln.delete(i);', '    return halfDict;', '      if (pointer != null) {', '    in.rightSibling = sibling;', '    sibling.leftSibling = in;', '    if (parent == null) {', '      keys[0] = newParentKey;', '      this.root = newRoot;', '      in.parent = newRoot;', '    } else {', '      sibling.parent = parent;', '    keys[split] = null;', '      keys[i] = null;', '    return halfKeys;', '    if (isEmpty()) {', '      this.firstLeaf = ln;', '    } else {', '        ln.numPairs++;', '          ln.parent = parent;', '        } else {', '        }', '        }', '        } else {', '          while (in != null) {', '            } else {', '              break;', '            }', '            in = in.parent;', '          }', '        }', '    if (isEmpty()) {', '      return null;', '    if (index < 0) {', '      return null;', '    } else {', '      return dps[index].value;', '    while (currNode != null) {', '        if (dp == null) {', '          break;', '        }', '        }', '    return values;', '  public BPlusTree(int m) {', '    this.m = m;', '    this.root = null;', '  public class Node {', '    InternalNode parent;', '    int maxDegree;', '    int minDegree;', '    int degree;', '    InternalNode leftSibling;', '    InternalNode rightSibling;', '    Integer[] keys;', '    Node[] childPointers;', '      this.degree++;', '          return i;', '        }', '      return -1;', '      this.degree++;', '      this.degree++;', '      this.keys[index] = null;', '      this.degree--;', '        }', '      this.degree--;', '      this.maxDegree = m;', '      this.degree = 0;', '      this.keys = keys;', '      this.maxDegree = m;', '      this.keys = keys;', '    int maxNumPairs;', '    int minNumPairs;', '    int numPairs;', '    LeafNode leftSibling;', '    LeafNode rightSibling;', '      numPairs--;', '      if (this.isFull()) {', '        return false;', '      } else {', '        numPairs++;', '        return true;', '    public boolean isFull() {', '      this.numPairs = 0;', '      this.insert(dp);', '      this.dictionary = dps;', '      this.parent = parent;', '    int key;', '    double value;', '      this.key = key;', '      this.value = value;', '      if (key == o.key) {', '        return 0;', '        return 1;', '      } else {', '        return -1;', '    BPlusTree bpt = null;', '    bpt = new BPlusTree(3);', '    bpt.insert(5, 33);', '    bpt.insert(15, 21);', '    bpt.insert(25, 31);', '    bpt.insert(35, 41);', '    bpt.insert(45, 10);', '    } else {', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', '#include <string.h>', '#define ORDER 3', 'typedef struct record {', '  int value;', '} record;', 'typedef struct node {', '  void **pointers;', '  int *keys;', '  struct node *parent;', '  bool is_leaf;', '  int num_keys;', '  struct node *next;', 'int order = ORDER;', 'node *queue = NULL;', 'bool verbose_output = false;', 'void enqueue(node *new_node);', 'node *dequeue(void);', 'int height(node *const root);', 'int cut(int length);', 'record *makeRecord(int value);', 'node *makeNode(void);', 'node *makeLeaf(void);', 'void enqueue(node *new_node) {', '  node *c;', '  if (queue == NULL) {', '    queue = new_node;', '    queue->next = NULL;', '  } else {', '    c = queue;', '    while (c->next != NULL) {', '      c = c->next;', '    c->next = new_node;', '    new_node->next = NULL;', 'node *dequeue(void) {', '  node *n = queue;', '  queue = queue->next;', '  n->next = NULL;', '  return n;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  int i;', '  node *c = root;', '  while (!c->is_leaf)', '    c = c->pointers[0];', '  while (true) {', '      if (verbose_output)', '    if (verbose_output)', '      printf("" | "");', '    } else', '      break;', '  printf(""\\n"");', 'int height(node *const root) {', '  int h = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    c = c->pointers[0];', '    h++;', '  return h;', '  int length = 0;', '  node *c = child;', '  while (c != root) {', '    c = c->parent;', '    length++;', '  return length;', '  node *n = NULL;', '  int i = 0;', '  int rank = 0;', '  int new_rank = 0;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  queue = NULL;', '  enqueue(root);', '  while (queue != NULL) {', '    n = dequeue();', '      if (new_rank != rank) {', '        rank = new_rank;', '        printf(""\\n"");', '    if (verbose_output)', '      printf(""(%p)"", n);', '      if (verbose_output)', '    if (!n->is_leaf)', '    if (verbose_output) {', '      if (n->is_leaf)', '      else', '    printf(""| "");', '  printf(""\\n"");', '  node *leaf = NULL;', '  if (r == NULL)', '         r, key, r->value);', '             bool verbose) {', '  int i;', '  if (!num_found)', '    printf(""None found.\\n"");', '  else {', '           returned_keys[i],', '           ((record *)', '             ->value);', '  int i, num_found;', '  num_found = 0;', '  if (n == NULL)', '    return 0;', '  if (i == n->num_keys)', '    return 0;', '  while (n != NULL) {', '      num_found++;', '    i = 0;', '  return num_found;', '  if (root == NULL) {', '    if (verbose)', '      printf(""Empty tree.\\n"");', '    return root;', '  int i = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    if (verbose) {', '      printf(""["");', '    i = 0;', '    while (i < c->num_keys) {', '      if (key >= c->keys[i])', '        i++;', '      else', '        break;', '    if (verbose)', '      printf(""%d ->\\n"", i);', '  if (verbose) {', '    printf(""Leaf ["");', '  return c;', '  if (root == NULL) {', '    if (leaf_out != NULL) {', '      *leaf_out = NULL;', '    return NULL;', '  int i = 0;', '  node *leaf = NULL;', '    if (leaf->keys[i] == key)', '      break;', '  if (leaf_out != NULL) {', '    *leaf_out = leaf;', '  if (i == leaf->num_keys)', '    return NULL;', 'int cut(int length) {', '  if (length % 2 == 0)', '    return length / 2;', '    return length / 2 + 1;', '  if (new_record == NULL) {', '    exit(EXIT_FAILURE);', '  } else {', '    new_record->value = value;', '  return new_record;', 'node *makeNode(void) {', '  node *new_node;', '  if (new_node == NULL) {', '    perror(""Node creation."");', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '  new_node->is_leaf = false;', '  new_node->num_keys = 0;', '  new_node->parent = NULL;', '  new_node->next = NULL;', '  return new_node;', 'node *makeLeaf(void) {', '  node *leaf = makeNode();', '  leaf->is_leaf = true;', '  return leaf;', '  int left_index = 0;', '    left_index++;', '  return left_index;', '  int i, insertion_point;', '  insertion_point = 0;', '    insertion_point++;', '  leaf->num_keys++;', '  return leaf;', '  node *new_leaf;', '  int *temp_keys;', '  void **temp_pointers;', '  new_leaf = makeLeaf();', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  insertion_index = 0;', '    insertion_index++;', '    if (j == insertion_index)', '      j++;', '  leaf->num_keys = 0;', '  split = cut(order - 1);', '    leaf->num_keys++;', '    new_leaf->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    leaf->pointers[i] = NULL;', '  new_key = new_leaf->keys[0];', '  int i;', '  n->keys[left_index] = key;', '  n->num_keys++;', '  return root;', '  int i, j, split, k_prime;', '  node *new_node, *child;', '  int *temp_keys;', '  node **temp_pointers;', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '    if (j == left_index + 1)', '      j++;', '    if (j == left_index)', '      j++;', '  temp_keys[left_index] = key;', '  split = cut(order);', '  new_node = makeNode();', '  old_node->num_keys = 0;', '    old_node->num_keys++;', '    new_node->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    child->parent = new_node;', '  int left_index;', '  node *parent;', '  parent = left->parent;', '  if (parent == NULL)', '  node *root = makeNode();', '  root->keys[0] = key;', '  root->pointers[0] = left;', '  root->pointers[1] = right;', '  root->num_keys++;', '  root->parent = NULL;', '  left->parent = root;', '  right->parent = root;', '  return root;', '  node *root = makeLeaf();', '  root->keys[0] = key;', '  root->pointers[0] = pointer;', '  root->parent = NULL;', '  root->num_keys++;', '  return root;', '  node *leaf = NULL;', '    return root;', '  if (root == NULL)', '    return root;', 'int main() {', '  node *root;', '  char instruction;', '  root = NULL;', '  root = insert(root, 5, 33);', '  root = insert(root, 15, 21);', '  root = insert(root, 25, 31);', '  root = insert(root, 35, 41);', '  root = insert(root, 45, 10);', '  printTree(root);', '#include <climits>', '#include <fstream>', '#include <iostream>', '#include <sstream>', 'using namespace std;', 'int MAX = 3;', 'class Node {', '  bool IS_LEAF;', '  int *key, size;', '  Node **ptr;', '  friend class BPTree;', '   public:', '  Node();', 'class BPTree {', '  Node *root;', '   public:', '  BPTree();', '  void search(int);', '  void insert(int);', '  void display(Node *);', '  Node *getRoot();', 'Node::Node() {', '  key = new int[MAX];', '  ptr = new Node *[MAX + 1];', 'BPTree::BPTree() {', '  root = NULL;', 'void BPTree::search(int x) {', '  if (root == NULL) {', '    cout << ""Tree is empty\\n"";', '  } else {', '    Node *cursor = root;', '          break;', '        }', '          break;', '        }', '        cout << ""Found\\n"";', '        return;', '    cout << ""Not found\\n"";', 'void BPTree::insert(int x) {', '  if (root == NULL) {', '    root = new Node;', '    root->key[0] = x;', '    root->IS_LEAF = true;', '    root->size = 1;', '  } else {', '    Node *cursor = root;', '    Node *parent;', '      parent = cursor;', '          break;', '        }', '          break;', '        }', '    if (cursor->size < MAX) {', '      int i = 0;', '        i++;', '      cursor->key[i] = x;', '      cursor->size++;', '    } else {', '      int i = 0, j;', '        i++;', '      virtualNode[i] = x;', '      newLeaf->IS_LEAF = true;', '      cursor->ptr[MAX] = NULL;', '      if (cursor == root) {', '        newRoot->size = 1;', '        root = newRoot;', '      } else {', '  if (cursor->size < MAX) {', '    int i = 0;', '      i++;', '    cursor->key[i] = x;', '    cursor->size++;', '  } else {', '    int virtualKey[MAX + 1];', '    Node *virtualPtr[MAX + 2];', '    int i = 0, j;', '      i++;', '    virtualKey[i] = x;', '    virtualPtr[i + 1] = child;', '    if (cursor == root) {', '      newRoot->size = 1;', '      root = newRoot;', '    } else {', '  Node *parent;', '    return NULL;', '      parent = cursor;', '      return parent;', '    } else {', '      if (parent != NULL)', '        return parent;', '  return parent;', '  if (cursor != NULL) {', '    cout << ""\\n"";', 'Node *BPTree::getRoot() {', '  return root;', 'int main() {', '  BPTree node;', '  node.insert(5);', '  node.insert(15);', '  node.insert(25);', '  node.insert(35);', '  node.insert(45);', '  node.insert(55);', '  node.insert(40);', '  node.insert(30);', '  node.insert(20);', '  node.search(15);']","['    def insert_at_leaf(self, leaf, value, key):', '            for i in range(len(temp1)):', '                if (value == temp1[i]):', '                    self.keys[i].append(key)', '                elif (value < temp1[i]):', '                    self.values = self.values[:i] + [value] + self.values[i:]', '                    self.keys = self.keys[:i] + [[key]] + self.keys[i:]', '                elif (i + 1 == len(temp1)):', '                    self.values.append(value)', '                    self.keys.append([key])', '            self.values = [value]', '        self.root.check_leaf = True', '    def insert(self, value, key):', '        old_node = self.search(value)', '        old_node.insert_at_leaf(old_node, value, key)', '        if (len(old_node.values) == old_node.order):', '            node1 = Node(old_node.order)', '            node1.check_leaf = True', '            node1.parent = old_node.parent', '            mid = int(math.ceil(old_node.order / 2)) - 1', '            node1.values = old_node.values[mid + 1:]', '            node1.keys = old_node.keys[mid + 1:]', '            node1.nextKey = old_node.nextKey', '            old_node.values = old_node.values[:mid + 1]', '            old_node.keys = old_node.keys[:mid + 1]', '            old_node.nextKey = node1', '            self.insert_in_parent(old_node, node1.values[0], node1)', '    # Search operation for different operations', '        current_node = self.root', '        while(current_node.check_leaf == False):', '            temp2 = current_node.values', '            for i in range(len(temp2)):', '                if (value == temp2[i]):', '                    current_node = current_node.keys[i + 1]', '                elif (value < temp2[i]):', '                    current_node = current_node.keys[i]', '                elif (i + 1 == len(current_node.values)):', '                    current_node = current_node.keys[i + 1]', '        for i, item in enumerate(l.values):', '                if key in l.keys[i]:', '                    return False', '    def insert_in_parent(self, n, value, ndash):', '            rootNode = Node(n.order)', '            rootNode.values = [value]', '            rootNode.keys = [n, ndash]', '            self.root = rootNode', '            ndash.parent = rootNode', '        for i in range(len(temp3)):', '                parentNode.values = parentNode.values[:i] + \\', '                    [value] + parentNode.values[i:]', '                parentNode.keys = parentNode.keys[:i +', '                                                  1] + [ndash] + parentNode.keys[i + 1:]', '                if (len(parentNode.keys) > parentNode.order):', '                    parentdash = Node(parentNode.order)', '                    parentdash.parent = parentNode.parent', '                    mid = int(math.ceil(parentNode.order / 2)) - 1', '                    parentdash.values = parentNode.values[mid + 1:]', '                    parentdash.keys = parentNode.keys[mid + 1:]', '                    value_ = parentNode.values[mid]', '                    if (mid == 0):', '                        parentNode.values = parentNode.values[:mid + 1]', '                        parentNode.values = parentNode.values[:mid]', '                    parentNode.keys = parentNode.keys[:mid + 1]', '                    for j in parentNode.keys:', '                        j.parent = parentNode', '                    for j in parentdash.keys:', '                        j.parent = parentdash', '                    self.insert_in_parent(parentNode, value_, parentdash)', '    def delete(self, value, key):', '        node_ = self.search(value)', '        for i, item in enumerate(node_.values):', '                if key in node_.keys[i]:', '                    if len(node_.keys[i]) > 1:', '                        node_.keys[i].pop(node_.keys[i].index(key))', '                    elif node_ == self.root:', '                        node_.values.pop(i)', '                        node_.keys.pop(i)', '                        node_.keys[i].pop(node_.keys[i].index(key))', '                        del node_.keys[i]', '                        node_.values.pop(node_.values.index(value))', '                        self.deleteEntry(node_, value, key)', '                    print(""Value not in Key"")', '            print(""Value not in Tree"")', '    def deleteEntry(self, node_, value, key):', '        if not node_.check_leaf:', '            for i, item in enumerate(node_.keys):', '                    node_.keys.pop(i)', '            for i, item in enumerate(node_.values):', '                if item == value:', '                    node_.values.pop(i)', '        if self.root == node_ and len(node_.keys) == 1:', '            self.root = node_.keys[0]', '            node_.keys[0].parent = None', '        elif (len(node_.keys) < int(math.ceil(node_.order / 2)) and node_.check_leaf == False) or (len(node_.values) < int(math.ceil((node_.order - 1) / 2)) and node_.check_leaf == True):', '            parentNode = node_.parent', '            for i, item in enumerate(parentNode.keys):', '                if item == node_:', '                        PrevNode = parentNode.keys[i - 1]', '                        PrevK = parentNode.values[i - 1]', '                    if i < len(parentNode.keys) - 1:', '                        NextNode = parentNode.keys[i + 1]', '                        PostK = parentNode.values[i]', '                ndash = NextNode', '            elif NextNode == -1:', '                is_predecessor = 1', '                ndash = PrevNode', '                if len(node_.values) + len(NextNode.values) < node_.order:', '                    ndash = NextNode', '                    value_ = PostK', '                    is_predecessor = 1', '                    ndash = PrevNode', '                    value_ = PrevK', '            if len(node_.values) + len(ndash.values) < node_.order:', '                if is_predecessor == 0:', '                    node_, ndash = ndash, node_', '                ndash.keys += node_.keys', '                if not node_.check_leaf:', '                    ndash.values.append(value_)', '                    ndash.nextKey = node_.nextKey', '                ndash.values += node_.values', '                if not ndash.check_leaf:', '                    for j in ndash.keys:', '                        j.parent = ndash', '                self.deleteEntry(node_.parent, value_, node_)', '                if is_predecessor == 1:', '                    if not node_.check_leaf:', '                        ndashpm = ndash.keys.pop(-1)', '                        ndashkm_1 = ndash.values.pop(-1)', '                        node_.keys = [ndashpm] + node_.keys', '                        node_.values = [value_] + node_.values', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                p.values[i] = ndashkm_1', '                                break', '                        ndashpm = ndash.keys.pop(-1)', '                        ndashkm = ndash.values.pop(-1)', '                        node_.keys = [ndashpm] + node_.keys', '                        node_.values = [ndashkm] + node_.values', '                        parentNode = node_.parent', '                        for i, item in enumerate(p.values):', '                            if item == value_:', '                                parentNode.values[i] = ndashkm', '                                break', '                    if not node_.check_leaf:', '                        ndashp0 = ndash.keys.pop(0)', '                        ndashk0 = ndash.values.pop(0)', '                        node_.keys = node_.keys + [ndashp0]', '                        node_.values = node_.values + [value_]', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                parentNode.values[i] = ndashk0', '                                break', '                        ndashp0 = ndash.keys.pop(0)', '                        ndashk0 = ndash.values.pop(0)', '                        node_.keys = node_.keys + [ndashp0]', '                        node_.values = node_.values + [ndashk0]', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                parentNode.values[i] = ndash.values[0]', '                                break', '                if not ndash.check_leaf:', '                    for j in ndash.keys:', '                        j.parent = ndash', '                if not node_.check_leaf:', '                    for j in node_.keys:', '                        j.parent = node_', '                if not parentNode.check_leaf:', '                    for j in parentNode.keys:', '                        j.parent = parentNode', '    node1 = Node(str(level[0]) + str(tree.root.values))', '        if (x.check_leaf == False):', '            for i, item in enumerate(x.keys):', '                print(item.values)', '            for i, item in enumerate(x.keys):', '                print(item.values)', 'bplustree = BplusTree(record_len)', '  private int binarySearch(DictionaryPair[] dps, int numPairs, int t) {', '    Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        Integer a = Integer.valueOf(o1.key);', '        Integer b = Integer.valueOf(o2.key);', '    return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, 0), c);', '  private LeafNode findLeafNode(int key) {', '    Integer[] keys = this.root.keys;', '    for (i = 0; i < this.root.degree - 1; i++) {', '    Node child = this.root.childPointers[i];', '    if (child instanceof LeafNode) {', '      return findLeafNode((InternalNode) child, key);', '  private LeafNode findLeafNode(InternalNode node, int key) {', '    for (i = 0; i < node.degree - 1; i++) {', '    Node childNode = node.childPointers[i];', '    if (childNode instanceof LeafNode) {', '      return (LeafNode) childNode;', '      return findLeafNode((InternalNode) node.childPointers[i], key);', '  private int findIndexOfPointer(Node[] pointers, LeafNode node) {', '    for (i = 0; i < pointers.length; i++) {', '      if (pointers[i] == node) {', '    return (int) Math.ceil((this.m + 1) / 2.0) - 1;', '  private void handleDeficiency(InternalNode in) {', '    InternalNode parent = in.parent;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          if (in.childPointers[i] instanceof InternalNode) {', '            this.root = (InternalNode) in.childPointers[i];', '            this.root.parent = null;', '          } else if (in.childPointers[i] instanceof LeafNode) {', '    else if (in.leftSibling != null && in.leftSibling.isLendable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isLendable()) {', '      sibling = in.rightSibling;', '      int borrowedKey = sibling.keys[0];', '      Node pointer = sibling.childPointers[0];', '      in.keys[in.degree - 1] = parent.keys[0];', '      in.childPointers[in.degree] = pointer;', '      parent.keys[0] = borrowedKey;', '      Arrays.sort(sibling.keys);', '      shiftDown(in.childPointers, 1);', '    } else if (in.leftSibling != null && in.leftSibling.isMergeable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isMergeable()) {', '      sibling = in.rightSibling;', '      sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];', '      Arrays.sort(sibling.keys, 0, sibling.degree);', '      parent.keys[parent.degree - 2] = null;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          sibling.prependChildPointer(in.childPointers[i]);', '          in.childPointers[i].parent = sibling;', '      sibling.leftSibling = in.leftSibling;', '    if (parent != null && parent.isDeficient()) {', '  private int linearNullSearch(DictionaryPair[] dps) {', '    for (int i = 0; i < dps.length; i++) {', '  private int linearNullSearch(Node[] pointers) {', '    for (int i = 0; i < pointers.length; i++) {', '      if (pointers[i] == null) {', '  private void shiftDown(Node[] pointers, int amount) {', '    Node[] newPointers = new Node[this.m + 1];', '    for (int i = amount; i < pointers.length; i++) {', '      newPointers[i - amount] = pointers[i];', '  private void sortDictionary(DictionaryPair[] dictionary) {', '    Arrays.sort(dictionary, new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        if (o1 == null && o2 == null) {', '        return o1.compareTo(o2);', '  private Node[] splitChildPointers(InternalNode in, int split) {', '    Node[] pointers = in.childPointers;', '    Node[] halfPointers = new Node[this.m + 1];', '    for (int i = split + 1; i < pointers.length; i++) {', '      halfPointers[i - split - 1] = pointers[i];', '  private DictionaryPair[] splitDictionary(LeafNode ln, int split) {', '    DictionaryPair[] dictionary = ln.dictionary;', '    DictionaryPair[] halfDict = new DictionaryPair[this.m];', '    for (int i = split; i < dictionary.length; i++) {', '      halfDict[i - split] = dictionary[i];', '  private void splitInternalNode(InternalNode in) {', '    InternalNode parent = in.parent;', '    int midpoint = getMidpoint();', '    int newParentKey = in.keys[midpoint];', '    Integer[] halfKeys = splitKeys(in.keys, midpoint);', '    Node[] halfPointers = splitChildPointers(in, midpoint);', '    in.degree = linearNullSearch(in.childPointers);', '    InternalNode sibling = new InternalNode(this.m, halfKeys, halfPointers);', '    for (Node pointer : halfPointers) {', '        pointer.parent = sibling;', '    sibling.rightSibling = in.rightSibling;', '    if (sibling.rightSibling != null) {', '      sibling.rightSibling.leftSibling = sibling;', '      Integer[] keys = new Integer[this.m];', '      InternalNode newRoot = new InternalNode(this.m, keys);', '      newRoot.appendChildPointer(in);', '      newRoot.appendChildPointer(sibling);', '      parent.keys[parent.degree - 1] = newParentKey;', '      Arrays.sort(parent.keys, 0, parent.degree);', '      int pointerIndex = parent.findIndexOfPointer(in) + 1;', '      parent.insertChildPointer(sibling, pointerIndex);', '  private Integer[] splitKeys(Integer[] keys, int split) {', '    Integer[] halfKeys = new Integer[this.m];', '    for (int i = split + 1; i < keys.length; i++) {', '      halfKeys[i - split - 1] = keys[i];', '  public void insert(int key, double value) {', '      LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));', '      LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '      if (!ln.insert(new DictionaryPair(key, value))) {', '        ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);', '        sortDictionary(ln.dictionary);', '        int midpoint = getMidpoint();', '        DictionaryPair[] halfDict = splitDictionary(ln, midpoint);', '        if (ln.parent == null) {', '          Integer[] parent_keys = new Integer[this.m];', '          parent_keys[0] = halfDict[0].key;', '          InternalNode parent = new InternalNode(this.m, parent_keys);', '          parent.appendChildPointer(ln);', '          int newParentKey = halfDict[0].key;', '          ln.parent.keys[ln.parent.degree - 1] = newParentKey;', '          Arrays.sort(ln.parent.keys, 0, ln.parent.degree);', '        LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);', '        int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;', '        ln.parent.insertChildPointer(newLeafNode, pointerIndex);', '        newLeafNode.rightSibling = ln.rightSibling;', '        if (newLeafNode.rightSibling != null) {', '          newLeafNode.rightSibling.leftSibling = newLeafNode;', '        ln.rightSibling = newLeafNode;', '        newLeafNode.leftSibling = ln;', '        if (this.root == null) {', '          this.root = ln.parent;', '          InternalNode in = ln.parent;', '            if (in.isOverfull()) {', '              splitInternalNode(in);', '  public Double search(int key) {', '    LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '    DictionaryPair[] dps = ln.dictionary;', '    int index = binarySearch(dps, ln.numPairs, key);', '  public ArrayList<Double> search(int lowerBound, int upperBound) {', '    ArrayList<Double> values = new ArrayList<Double>();', '    LeafNode currNode = this.firstLeaf;', '      DictionaryPair dps[] = currNode.dictionary;', '      for (DictionaryPair dp : dps) {', '        if (lowerBound <= dp.key && dp.key <= upperBound) {', '      currNode = currNode.rightSibling;', '  private class InternalNode extends Node {', '    private void appendChildPointer(Node pointer) {', '      this.childPointers[degree] = pointer;', '    private int findIndexOfPointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '    private void insertChildPointer(Node pointer, int index) {', '      for (int i = degree - 1; i >= index; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[index] = pointer;', '    private boolean isDeficient() {', '      return this.degree < this.minDegree;', '    private boolean isLendable() {', '      return this.degree > this.minDegree;', '    private boolean isMergeable() {', '      return this.degree == this.minDegree;', '    private boolean isOverfull() {', '      return this.degree == maxDegree + 1;', '    private void prependChildPointer(Node pointer) {', '      for (int i = degree - 1; i >= 0; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[0] = pointer;', '    private void removeKey(int index) {', '    private void removePointer(int index) {', '      this.childPointers[index] = null;', '    private void removePointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '          this.childPointers[i] = null;', '    private InternalNode(int m, Integer[] keys) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.childPointers = new Node[this.maxDegree + 1];', '    private InternalNode(int m, Integer[] keys, Node[] pointers) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.degree = linearNullSearch(pointers);', '      this.childPointers = pointers;', '  public class LeafNode extends Node {', '    DictionaryPair[] dictionary;', '    public void delete(int index) {', '      this.dictionary[index] = null;', '    public boolean insert(DictionaryPair dp) {', '        this.dictionary[numPairs] = dp;', '        Arrays.sort(this.dictionary, 0, numPairs);', '    public boolean isDeficient() {', '      return numPairs < minNumPairs;', '      return numPairs == maxNumPairs;', '    public boolean isLendable() {', '      return numPairs > minNumPairs;', '    public boolean isMergeable() {', '      return numPairs == minNumPairs;', '    public LeafNode(int m, DictionaryPair dp) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.dictionary = new DictionaryPair[m];', '    public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.numPairs = linearNullSearch(dps);', '  public class DictionaryPair implements Comparable<DictionaryPair> {', '    public DictionaryPair(int key, double value) {', '    public int compareTo(DictionaryPair o) {', '  public static void main(String[] args) {', '    if (bpt.search(15) != null) {', '      System.out.println(""Found"");', '      System.out.println(""Not Found"");', 'int pathToLeaves(node *const root, node *child);', 'void printLeaves(node *const root);', 'void printTree(node *const root);', 'void findAndPrint(node *const root, int key, bool verbose);', 'void findAndPrintRange(node *const root, int range1, int range2, bool verbose);', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]);', 'node *findLeaf(node *const root, int key, bool verbose);', 'record *find(node *root, int key, bool verbose, node **leaf_out);', 'int getLeftIndex(node *parent, node *left);', 'node *insertIntoLeaf(node *leaf, int key, record *pointer);', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key,', '                   record *pointer);', 'node *insertIntoNode(node *root, node *parent,', '           int left_index, int key, node *right);', 'node *insertIntoNodeAfterSplitting(node *root, node *parent,', '                   int left_index,', '                   int key, node *right);', 'node *insertIntoParent(node *root, node *left, int key, node *right);', 'node *insertIntoNewRoot(node *left, int key, node *right);', 'node *startNewTree(int key, record *pointer);', 'node *insert(node *root, int key, int value);', 'void printLeaves(node *const root) {', '    for (i = 0; i < c->num_keys; i++) {', '        printf(""%p "", c->pointers[i]);', '      printf(""%d "", c->keys[i]);', '      printf(""%p "", c->pointers[order - 1]);', '    if (c->pointers[order - 1] != NULL) {', '      c = c->pointers[order - 1];', 'int pathToLeaves(node *const root, node *child) {', 'void printTree(node *const root) {', '    if (n->parent != NULL && n == n->parent->pointers[0]) {', '      new_rank = pathToLeaves(root, n);', '    for (i = 0; i < n->num_keys; i++) {', '        printf(""%p "", n->pointers[i]);', '      printf(""%d "", n->keys[i]);', '      for (i = 0; i <= n->num_keys; i++)', '        enqueue(n->pointers[i]);', '        printf(""%p "", n->pointers[order - 1]);', '        printf(""%p "", n->pointers[n->num_keys]);', 'void findAndPrint(node *const root, int key, bool verbose) {', '  record *r = find(root, key, verbose, NULL);', '    printf(""Record not found under key %d.\\n"", key);', '    printf(""Record at %p -- key %d, value %d.\\n"",', 'void findAndPrintRange(node *const root, int key_start, int key_end,', '  int array_size = key_end - key_start + 1;', '  int returned_keys[array_size];', '  void *returned_pointers[array_size];', '  int num_found = findRange(root, key_start, key_end, verbose,', '                returned_keys, returned_pointers);', '    for (i = 0; i < num_found; i++)', '      printf(""Key: %d   Location: %p  Value: %d\\n"",', '           returned_pointers[i],', '            returned_pointers[i])', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]) {', '  node *n = findLeaf(root, key_start, verbose);', '  for (i = 0; i < n->num_keys && n->keys[i] < key_start; i++)', '    for (; i < n->num_keys && n->keys[i] <= key_end; i++) {', '      returned_keys[num_found] = n->keys[i];', '      returned_pointers[num_found] = n->pointers[i];', 'node *findLeaf(node *const root, int key, bool verbose) {', '      for (i = 0; i < c->num_keys - 1; i++)', '        printf(""%d "", c->keys[i]);', '      printf(""%d] "", c->keys[i]);', '    for (i = 0; i < c->num_keys - 1; i++)', '      printf(""%d "", c->keys[i]);', '    printf(""%d] ->\\n"", c->keys[i]);', 'record *find(node *root, int key, bool verbose, node **leaf_out) {', '  leaf = findLeaf(root, key, verbose);', '  for (i = 0; i < leaf->num_keys; i++)', '    return (record *)leaf->pointers[i];', '  record *new_record = (record *)malloc(sizeof(record));', '  new_node = malloc(sizeof(node));', '  new_node->keys = malloc((order - 1) * sizeof(int));', '    perror(""New node keys array."");', '  new_node->pointers = malloc(order * sizeof(void *));', '  if (new_node->pointers == NULL) {', '    perror(""New node pointers array."");', 'int getLeftIndex(node *parent, node *left) {', '  while (left_index <= parent->num_keys &&', '       parent->pointers[left_index] != left)', 'node *insertIntoLeaf(node *leaf, int key, record *pointer) {', '  while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)', '  for (i = leaf->num_keys; i > insertion_point; i--) {', '    leaf->keys[i] = leaf->keys[i - 1];', '    leaf->pointers[i] = leaf->pointers[i - 1];', '  leaf->keys[insertion_point] = key;', '  leaf->pointers[insertion_point] = pointer;', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key, record *pointer) {', '  int insertion_index, split, new_key, i, j;', '  temp_keys = malloc(order * sizeof(int));', '    perror(""Temporary keys array."");', '  temp_pointers = malloc(order * sizeof(void *));', '    perror(""Temporary pointers array."");', '  while (insertion_index < order - 1 && leaf->keys[insertion_index] < key)', '  for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {', '    temp_keys[j] = leaf->keys[i];', '    temp_pointers[j] = leaf->pointers[i];', '  temp_keys[insertion_index] = key;', '  temp_pointers[insertion_index] = pointer;', '    leaf->pointers[i] = temp_pointers[i];', '    leaf->keys[i] = temp_keys[i];', '  for (i = split, j = 0; i < order; i++, j++) {', '    new_leaf->pointers[j] = temp_pointers[i];', '    new_leaf->keys[j] = temp_keys[i];', '  new_leaf->pointers[order - 1] = leaf->pointers[order - 1];', '  leaf->pointers[order - 1] = new_leaf;', '  for (i = leaf->num_keys; i < order - 1; i++)', '  for (i = new_leaf->num_keys; i < order - 1; i++)', '    new_leaf->pointers[i] = NULL;', '  new_leaf->parent = leaf->parent;', '  return insertIntoParent(root, leaf, new_key, new_leaf);', 'node *insertIntoNode(node *root, node *n,', '           int left_index, int key, node *right) {', '  for (i = n->num_keys; i > left_index; i--) {', '    n->pointers[i + 1] = n->pointers[i];', '    n->keys[i] = n->keys[i - 1];', '  n->pointers[left_index + 1] = right;', 'node *insertIntoNodeAfterSplitting(node *root, node *old_node, int left_index,', '                   int key, node *right) {', '  temp_pointers = malloc((order + 1) * sizeof(node *));', '  temp_keys = malloc(order * sizeof(int));', '  for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {', '    temp_pointers[j] = old_node->pointers[i];', '  for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {', '    temp_keys[j] = old_node->keys[i];', '  temp_pointers[left_index + 1] = right;', '  for (i = 0; i < split - 1; i++) {', '    old_node->pointers[i] = temp_pointers[i];', '    old_node->keys[i] = temp_keys[i];', '  old_node->pointers[i] = temp_pointers[i];', '  k_prime = temp_keys[split - 1];', '  for (++i, j = 0; i < order; i++, j++) {', '    new_node->pointers[j] = temp_pointers[i];', '    new_node->keys[j] = temp_keys[i];', '  new_node->pointers[j] = temp_pointers[i];', '  new_node->parent = old_node->parent;', '  for (i = 0; i <= new_node->num_keys; i++) {', '    child = new_node->pointers[i];', '  return insertIntoParent(root, old_node, k_prime, new_node);', 'node *insertIntoParent(node *root, node *left, int key, node *right) {', '    return insertIntoNewRoot(left, key, right);', '  left_index = getLeftIndex(parent, left);', '  if (parent->num_keys < order - 1)', '    return insertIntoNode(root, parent, left_index, key, right);', '  return insertIntoNodeAfterSplitting(root, parent, left_index, key, right);', 'node *insertIntoNewRoot(node *left, int key, node *right) {', 'node *startNewTree(int key, record *pointer) {', '  root->pointers[order - 1] = NULL;', 'node *insert(node *root, int key, int value) {', '  record *record_pointer = NULL;', '  record_pointer = find(root, key, false, NULL);', '    record_pointer->value = value;', '  record_pointer = makeRecord(value);', '    return startNewTree(key, record_pointer);', '  leaf = findLeaf(root, key, false);', '  if (leaf->num_keys < order - 1) {', '    leaf = insertIntoLeaf(leaf, key, record_pointer);', '  return insertIntoLeafAfterSplitting(root, leaf, key, record_pointer);', ""  findAndPrint(root, 15, instruction = 'a');"", '  void insertInternal(int, Node *, Node *);', '  Node *findParent(Node *, Node *);', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '    for (int i = 0; i < cursor->size; i++) {', '      if (cursor->key[i] == x) {', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '      while (x > cursor->key[i] && i < cursor->size)', '      for (int j = cursor->size; j > i; j--) {', '        cursor->key[j] = cursor->key[j - 1];', '      cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];', '      cursor->ptr[cursor->size - 1] = NULL;', '      for (int i = 0; i < MAX; i++) {', '        virtualNode[i] = cursor->key[i];', '      while (x > virtualNode[i] && i < MAX)', '      for (int j = MAX + 1; j > i; j--) {', '        virtualNode[j] = virtualNode[j - 1];', '      cursor->size = (MAX + 1) / 2;', '      newLeaf->size = MAX + 1 - (MAX + 1) / 2;', '      cursor->ptr[cursor->size] = newLeaf;', '      newLeaf->ptr[newLeaf->size] = cursor->ptr[MAX];', '      for (i = 0; i < cursor->size; i++) {', '        cursor->key[i] = virtualNode[i];', '      for (i = 0, j = cursor->size; i < newLeaf->size; i++, j++) {', '        newLeaf->key[i] = virtualNode[j];', '        Node *newRoot = new Node;', '        newRoot->key[0] = newLeaf->key[0];', '        newRoot->ptr[0] = cursor;', '        newRoot->ptr[1] = newLeaf;', '        newRoot->IS_LEAF = false;', '        insertInternal(newLeaf->key[0], parent, newLeaf);', 'void BPTree::insertInternal(int x, Node *cursor, Node *child) {', '    while (x > cursor->key[i] && i < cursor->size)', '    for (int j = cursor->size; j > i; j--) {', '      cursor->key[j] = cursor->key[j - 1];', '    for (int j = cursor->size + 1; j > i + 1; j--) {', '      cursor->ptr[j] = cursor->ptr[j - 1];', '    Node *newInternal = new Node;', '    for (int i = 0; i < MAX; i++) {', '      virtualKey[i] = cursor->key[i];', '    for (int i = 0; i < MAX + 1; i++) {', '      virtualPtr[i] = cursor->ptr[i];', '    while (x > virtualKey[i] && i < MAX)', '    for (int j = MAX + 1; j > i; j--) {', '      virtualKey[j] = virtualKey[j - 1];', '    for (int j = MAX + 2; j > i + 1; j--) {', '      virtualPtr[j] = virtualPtr[j - 1];', '    newInternal->IS_LEAF = false;', '    cursor->size = (MAX + 1) / 2;', '    newInternal->size = MAX - (MAX + 1) / 2;', '    for (i = 0, j = cursor->size + 1; i < newInternal->size; i++, j++) {', '      newInternal->key[i] = virtualKey[j];', '    for (i = 0, j = cursor->size + 1; i < newInternal->size + 1; i++, j++) {', '      newInternal->ptr[i] = virtualPtr[j];', '      newRoot->key[0] = cursor->key[cursor->size];', '      newRoot->ptr[1] = newInternal;', '      insertInternal(cursor->key[cursor->size], findParent(root, cursor), newInternal);', 'Node *BPTree::findParent(Node *cursor, Node *child) {', '  if (cursor->IS_LEAF || (cursor->ptr[0])->IS_LEAF) {', '  for (int i = 0; i < cursor->size + 1; i++) {', '    if (cursor->ptr[i] == child) {', '      parent = findParent(cursor->ptr[i], child);', 'void BPTree::display(Node *cursor) {', '    for (int i = 0; i < cursor->size; i++) {', '      cout << cursor->key[i] << "" "";', '    if (cursor->IS_LEAF != true) {', '      for (int i = 0; i < cursor->size + 1; i++) {', '        display(cursor->ptr[i]);']",[],[],"['Multilevel Indexing|||Faster operations on the tree (insertion, deletion, search)|||Database indexing|||&&&All leaves are at the same level.|||The root has at least two children.|||Each node except root can have a maximum of m children and at least m/2 children.|||Each node can contain a maximum of m - 1 keys and a minimum of ⌈m/2⌉ - 1 keys.|||Start from the root node. Compare k with the keys at the root node [k1, k2, k3,......km - 1].|||If k < k1, go to the left child of the root node.|||Else if k == k1, compare k2. If k < k2, k lies between k1 and k2. So, search in the left child of k2.|||If k > k2, go for k3, k4,...km-1 as in steps 2 and 3.|||Repeat the above steps until a leaf node is reached.|||If k exists in the leaf node, return true else return false.|||Compare k with the root node.|||k is not found at the root|||Since k > 25, go to the right child.|||Go to right of the root|||Compare k with 35. Since k > 30, compare k with 45.|||k not found|||Since k ≥ 45, so go to the right child.|||go to the right|||k is found.|||k is found|||']"
32,['Insertion on a B+ Tree'],"['In this tutorial, you will learn about insertion operation on a B+ tree. Also, you will find working examples of inserting elements on a B+ tree in C, C++, Java and Python.']",[],[],"['Insertion Operation', 'Insertion Example', 'Python, Java and C/C++ Examples', 'Insertion Complexity']","['Case I', 'Case II']","['//cdn.programiz.com/sites/tutorial2program/files/insert-1-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-2-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-3-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-4-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-5-b+tree.png']","['Let us understand these events below.', 'The following steps are followed for inserting an element.', 'The elements to be inserted are 5,15, 25, 35, 45.', 'Time complexity: Θ(t.logt n)', 'The complexity is dominated by Θ(logt n).']","['Before inserting an element into a B+ tree, these properties must be kept in mind.', 'Let us understand the insertion operation with the illustrations below.']","['Inserting an element into a B+ tree consists of three main events: searching the appropriate leaf, inserting the element and balancing/splitting the tree.']","['# B+ tee in python', 'import math', '# Node creation', 'class Node:', '    def __init__(self, order):', '        self.order = order', '        self.values = []', '        self.keys = []', '        self.nextKey = None', '        self.parent = None', '    # Insert at the leaf', '        if (self.values):', '                    break', '                    break', '                    break', '        else:', '# B plus tree', 'class BplusTree:', '    def __init__(self, order):', '    # Insert operation', '        value = str(value)', '    def search(self, value):', '                    break', '                    break', '                    break', '        return current_node', '    # Find the node', '        l = self.search(value)', '            if item == value:', '                else:', '        return False', '    # Inserting at the parent', '        if (self.root == n):', '            return', '        parentNode = n.parent', '                    else:', '# Print the tree', 'def printTree(tree):', '    lst = [tree.root]', '    level = [0]', '    leaf = None', '    flag = 0', '    lev_leaf = 0', '    while (len(lst) != 0):', '        x = lst.pop(0)', '        lev = level.pop(0)', '        else:', '            if (flag == 0):', '                lev_leaf = lev', '                leaf = x', '                flag = 1', 'record_len = 3', ""bplustree.insert('5', '33')"", ""bplustree.insert('15', '21')"", ""bplustree.insert('25', '31')"", ""bplustree.insert('35', '41')"", ""bplustree.insert('45', '10')"", 'printTree(bplustree)', ""if(bplustree.find('5', '34')):"", '    print(""Found"")', '    print(""Not found"")', 'import java.util.*;', 'public class BPlusTree {', '  int m;', '  InternalNode root;', '  LeafNode firstLeaf;', '      @Override', '        return a.compareTo(b);', '    int i;', '      if (key < keys[i]) {', '        break;', '      return (LeafNode) child;', '    } else {', '    int i;', '      if (key < keys[i]) {', '        break;', '    } else {', '    int i;', '        break;', '    return i;', '  private int getMidpoint() {', '    InternalNode sibling;', '    if (this.root == in) {', '            this.root = null;', '          }', '        }', '          in.removePointer(i);', '        }', '  private boolean isEmpty() {', '    return firstLeaf == null;', '      if (dps[i] == null) {', '        return i;', '    return -1;', '        return i;', '    return -1;', '    pointers = newPointers;', '      @Override', '          return 0;', '        }', '        if (o1 == null) {', '          return 1;', '        }', '        if (o2 == null) {', '          return -1;', '        }', '      in.removePointer(i);', '    return halfPointers;', '      ln.delete(i);', '    return halfDict;', '      if (pointer != null) {', '    in.rightSibling = sibling;', '    sibling.leftSibling = in;', '    if (parent == null) {', '      keys[0] = newParentKey;', '      this.root = newRoot;', '      in.parent = newRoot;', '    } else {', '      sibling.parent = parent;', '    keys[split] = null;', '      keys[i] = null;', '    return halfKeys;', '    if (isEmpty()) {', '      this.firstLeaf = ln;', '    } else {', '        ln.numPairs++;', '          ln.parent = parent;', '        } else {', '        }', '        }', '        } else {', '          while (in != null) {', '            } else {', '              break;', '            }', '            in = in.parent;', '          }', '        }', '    if (isEmpty()) {', '      return null;', '    if (index < 0) {', '      return null;', '    } else {', '      return dps[index].value;', '    while (currNode != null) {', '        if (dp == null) {', '          break;', '        }', '        }', '    return values;', '  public BPlusTree(int m) {', '    this.m = m;', '    this.root = null;', '  public class Node {', '    InternalNode parent;', '    int maxDegree;', '    int minDegree;', '    int degree;', '    InternalNode leftSibling;', '    InternalNode rightSibling;', '    Integer[] keys;', '    Node[] childPointers;', '      this.degree++;', '          return i;', '        }', '      return -1;', '      this.degree++;', '      this.degree++;', '      this.keys[index] = null;', '      this.degree--;', '        }', '      this.degree--;', '      this.maxDegree = m;', '      this.degree = 0;', '      this.keys = keys;', '      this.maxDegree = m;', '      this.keys = keys;', '    int maxNumPairs;', '    int minNumPairs;', '    int numPairs;', '    LeafNode leftSibling;', '    LeafNode rightSibling;', '      numPairs--;', '      if (this.isFull()) {', '        return false;', '      } else {', '        numPairs++;', '        return true;', '    public boolean isFull() {', '      this.numPairs = 0;', '      this.insert(dp);', '      this.dictionary = dps;', '      this.parent = parent;', '    int key;', '    double value;', '      this.key = key;', '      this.value = value;', '      if (key == o.key) {', '        return 0;', '        return 1;', '      } else {', '        return -1;', '    BPlusTree bpt = null;', '    bpt = new BPlusTree(3);', '    bpt.insert(5, 33);', '    bpt.insert(15, 21);', '    bpt.insert(25, 31);', '    bpt.insert(35, 41);', '    bpt.insert(45, 10);', '    } else {', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', '#include <string.h>', '#define ORDER 3', 'typedef struct record {', '  int value;', '} record;', 'typedef struct node {', '  void **pointers;', '  int *keys;', '  struct node *parent;', '  bool is_leaf;', '  int num_keys;', '  struct node *next;', 'int order = ORDER;', 'node *queue = NULL;', 'bool verbose_output = false;', 'void enqueue(node *new_node);', 'node *dequeue(void);', 'int height(node *const root);', 'int cut(int length);', 'record *makeRecord(int value);', 'node *makeNode(void);', 'node *makeLeaf(void);', 'void enqueue(node *new_node) {', '  node *c;', '  if (queue == NULL) {', '    queue = new_node;', '    queue->next = NULL;', '  } else {', '    c = queue;', '    while (c->next != NULL) {', '      c = c->next;', '    c->next = new_node;', '    new_node->next = NULL;', 'node *dequeue(void) {', '  node *n = queue;', '  queue = queue->next;', '  n->next = NULL;', '  return n;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  int i;', '  node *c = root;', '  while (!c->is_leaf)', '    c = c->pointers[0];', '  while (true) {', '      if (verbose_output)', '    if (verbose_output)', '      printf("" | "");', '    } else', '      break;', '  printf(""\\n"");', 'int height(node *const root) {', '  int h = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    c = c->pointers[0];', '    h++;', '  return h;', '  int length = 0;', '  node *c = child;', '  while (c != root) {', '    c = c->parent;', '    length++;', '  return length;', '  node *n = NULL;', '  int i = 0;', '  int rank = 0;', '  int new_rank = 0;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  queue = NULL;', '  enqueue(root);', '  while (queue != NULL) {', '    n = dequeue();', '      if (new_rank != rank) {', '        rank = new_rank;', '        printf(""\\n"");', '    if (verbose_output)', '      printf(""(%p)"", n);', '      if (verbose_output)', '    if (!n->is_leaf)', '    if (verbose_output) {', '      if (n->is_leaf)', '      else', '    printf(""| "");', '  printf(""\\n"");', '  node *leaf = NULL;', '  if (r == NULL)', '         r, key, r->value);', '             bool verbose) {', '  int i;', '  if (!num_found)', '    printf(""None found.\\n"");', '  else {', '           returned_keys[i],', '           ((record *)', '             ->value);', '  int i, num_found;', '  num_found = 0;', '  if (n == NULL)', '    return 0;', '  if (i == n->num_keys)', '    return 0;', '  while (n != NULL) {', '      num_found++;', '    i = 0;', '  return num_found;', '  if (root == NULL) {', '    if (verbose)', '      printf(""Empty tree.\\n"");', '    return root;', '  int i = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    if (verbose) {', '      printf(""["");', '    i = 0;', '    while (i < c->num_keys) {', '      if (key >= c->keys[i])', '        i++;', '      else', '        break;', '    if (verbose)', '      printf(""%d ->\\n"", i);', '  if (verbose) {', '    printf(""Leaf ["");', '  return c;', '  if (root == NULL) {', '    if (leaf_out != NULL) {', '      *leaf_out = NULL;', '    return NULL;', '  int i = 0;', '  node *leaf = NULL;', '    if (leaf->keys[i] == key)', '      break;', '  if (leaf_out != NULL) {', '    *leaf_out = leaf;', '  if (i == leaf->num_keys)', '    return NULL;', 'int cut(int length) {', '  if (length % 2 == 0)', '    return length / 2;', '    return length / 2 + 1;', '  if (new_record == NULL) {', '    exit(EXIT_FAILURE);', '  } else {', '    new_record->value = value;', '  return new_record;', 'node *makeNode(void) {', '  node *new_node;', '  if (new_node == NULL) {', '    perror(""Node creation."");', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '  new_node->is_leaf = false;', '  new_node->num_keys = 0;', '  new_node->parent = NULL;', '  new_node->next = NULL;', '  return new_node;', 'node *makeLeaf(void) {', '  node *leaf = makeNode();', '  leaf->is_leaf = true;', '  return leaf;', '  int left_index = 0;', '    left_index++;', '  return left_index;', '  int i, insertion_point;', '  insertion_point = 0;', '    insertion_point++;', '  leaf->num_keys++;', '  return leaf;', '  node *new_leaf;', '  int *temp_keys;', '  void **temp_pointers;', '  new_leaf = makeLeaf();', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  insertion_index = 0;', '    insertion_index++;', '    if (j == insertion_index)', '      j++;', '  leaf->num_keys = 0;', '  split = cut(order - 1);', '    leaf->num_keys++;', '    new_leaf->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    leaf->pointers[i] = NULL;', '  new_key = new_leaf->keys[0];', '  int i;', '  n->keys[left_index] = key;', '  n->num_keys++;', '  return root;', '  int i, j, split, k_prime;', '  node *new_node, *child;', '  int *temp_keys;', '  node **temp_pointers;', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '    if (j == left_index + 1)', '      j++;', '    if (j == left_index)', '      j++;', '  temp_keys[left_index] = key;', '  split = cut(order);', '  new_node = makeNode();', '  old_node->num_keys = 0;', '    old_node->num_keys++;', '    new_node->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    child->parent = new_node;', '  int left_index;', '  node *parent;', '  parent = left->parent;', '  if (parent == NULL)', '  node *root = makeNode();', '  root->keys[0] = key;', '  root->pointers[0] = left;', '  root->pointers[1] = right;', '  root->num_keys++;', '  root->parent = NULL;', '  left->parent = root;', '  right->parent = root;', '  return root;', '  node *root = makeLeaf();', '  root->keys[0] = key;', '  root->pointers[0] = pointer;', '  root->parent = NULL;', '  root->num_keys++;', '  return root;', '  node *leaf = NULL;', '    return root;', '  if (root == NULL)', '    return root;', 'int main() {', '  node *root;', '  char instruction;', '  root = NULL;', '  root = insert(root, 5, 33);', '  root = insert(root, 15, 21);', '  root = insert(root, 25, 31);', '  root = insert(root, 35, 41);', '  root = insert(root, 45, 10);', '  printTree(root);', '#include <climits>', '#include <fstream>', '#include <iostream>', '#include <sstream>', 'using namespace std;', 'int MAX = 3;', 'class Node {', '  bool IS_LEAF;', '  int *key, size;', '  Node **ptr;', '  friend class BPTree;', '   public:', '  Node();', 'class BPTree {', '  Node *root;', '   public:', '  BPTree();', '  void search(int);', '  void insert(int);', '  void display(Node *);', '  Node *getRoot();', 'Node::Node() {', '  key = new int[MAX];', '  ptr = new Node *[MAX + 1];', 'BPTree::BPTree() {', '  root = NULL;', 'void BPTree::search(int x) {', '  if (root == NULL) {', '    cout << ""Tree is empty\\n"";', '  } else {', '    Node *cursor = root;', '          break;', '        }', '          break;', '        }', '        cout << ""Found\\n"";', '        return;', '    cout << ""Not found\\n"";', 'void BPTree::insert(int x) {', '  if (root == NULL) {', '    root = new Node;', '    root->key[0] = x;', '    root->IS_LEAF = true;', '    root->size = 1;', '  } else {', '    Node *cursor = root;', '    Node *parent;', '      parent = cursor;', '          break;', '        }', '          break;', '        }', '    if (cursor->size < MAX) {', '      int i = 0;', '        i++;', '      cursor->key[i] = x;', '      cursor->size++;', '    } else {', '      int i = 0, j;', '        i++;', '      virtualNode[i] = x;', '      newLeaf->IS_LEAF = true;', '      cursor->ptr[MAX] = NULL;', '      if (cursor == root) {', '        newRoot->size = 1;', '        root = newRoot;', '      } else {', '  if (cursor->size < MAX) {', '    int i = 0;', '      i++;', '    cursor->key[i] = x;', '    cursor->size++;', '  } else {', '    int virtualKey[MAX + 1];', '    Node *virtualPtr[MAX + 2];', '    int i = 0, j;', '      i++;', '    virtualKey[i] = x;', '    virtualPtr[i + 1] = child;', '    if (cursor == root) {', '      newRoot->size = 1;', '      root = newRoot;', '    } else {', '  Node *parent;', '    return NULL;', '      parent = cursor;', '      return parent;', '    } else {', '      if (parent != NULL)', '        return parent;', '  return parent;', '  if (cursor != NULL) {', '    cout << ""\\n"";', 'Node *BPTree::getRoot() {', '  return root;', 'int main() {', '  BPTree node;', '  node.insert(5);', '  node.insert(15);', '  node.insert(25);', '  node.insert(35);', '  node.insert(45);', '  node.insert(55);', '  node.insert(40);', '  node.insert(30);', '  node.insert(20);', '  node.search(15);']","['    def insert_at_leaf(self, leaf, value, key):', '            for i in range(len(temp1)):', '                if (value == temp1[i]):', '                    self.keys[i].append(key)', '                elif (value < temp1[i]):', '                    self.values = self.values[:i] + [value] + self.values[i:]', '                    self.keys = self.keys[:i] + [[key]] + self.keys[i:]', '                elif (i + 1 == len(temp1)):', '                    self.values.append(value)', '                    self.keys.append([key])', '            self.values = [value]', '        self.root.check_leaf = True', '    def insert(self, value, key):', '        old_node = self.search(value)', '        old_node.insert_at_leaf(old_node, value, key)', '        if (len(old_node.values) == old_node.order):', '            node1 = Node(old_node.order)', '            node1.check_leaf = True', '            node1.parent = old_node.parent', '            mid = int(math.ceil(old_node.order / 2)) - 1', '            node1.values = old_node.values[mid + 1:]', '            node1.keys = old_node.keys[mid + 1:]', '            node1.nextKey = old_node.nextKey', '            old_node.values = old_node.values[:mid + 1]', '            old_node.keys = old_node.keys[:mid + 1]', '            old_node.nextKey = node1', '            self.insert_in_parent(old_node, node1.values[0], node1)', '    # Search operation for different operations', '        current_node = self.root', '        while(current_node.check_leaf == False):', '            temp2 = current_node.values', '            for i in range(len(temp2)):', '                if (value == temp2[i]):', '                    current_node = current_node.keys[i + 1]', '                elif (value < temp2[i]):', '                    current_node = current_node.keys[i]', '                elif (i + 1 == len(current_node.values)):', '                    current_node = current_node.keys[i + 1]', '        for i, item in enumerate(l.values):', '                if key in l.keys[i]:', '                    return False', '    def insert_in_parent(self, n, value, ndash):', '            rootNode = Node(n.order)', '            rootNode.values = [value]', '            rootNode.keys = [n, ndash]', '            self.root = rootNode', '            ndash.parent = rootNode', '        for i in range(len(temp3)):', '                parentNode.values = parentNode.values[:i] + \\', '                    [value] + parentNode.values[i:]', '                parentNode.keys = parentNode.keys[:i +', '                                                  1] + [ndash] + parentNode.keys[i + 1:]', '                if (len(parentNode.keys) > parentNode.order):', '                    parentdash = Node(parentNode.order)', '                    parentdash.parent = parentNode.parent', '                    mid = int(math.ceil(parentNode.order / 2)) - 1', '                    parentdash.values = parentNode.values[mid + 1:]', '                    parentdash.keys = parentNode.keys[mid + 1:]', '                    value_ = parentNode.values[mid]', '                    if (mid == 0):', '                        parentNode.values = parentNode.values[:mid + 1]', '                        parentNode.values = parentNode.values[:mid]', '                    parentNode.keys = parentNode.keys[:mid + 1]', '                    for j in parentNode.keys:', '                        j.parent = parentNode', '                    for j in parentdash.keys:', '                        j.parent = parentdash', '                    self.insert_in_parent(parentNode, value_, parentdash)', '    node1 = Node(str(level[0]) + str(tree.root.values))', '        if (x.check_leaf == False):', '            for i, item in enumerate(x.keys):', '                print(item.values)', '            for i, item in enumerate(x.keys):', '                print(item.values)', 'bplustree = BplusTree(record_len)', '  private int binarySearch(DictionaryPair[] dps, int numPairs, int t) {', '    Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        Integer a = Integer.valueOf(o1.key);', '        Integer b = Integer.valueOf(o2.key);', '    return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, 0), c);', '  private LeafNode findLeafNode(int key) {', '    Integer[] keys = this.root.keys;', '    for (i = 0; i < this.root.degree - 1; i++) {', '    Node child = this.root.childPointers[i];', '    if (child instanceof LeafNode) {', '      return findLeafNode((InternalNode) child, key);', '  private LeafNode findLeafNode(InternalNode node, int key) {', '    for (i = 0; i < node.degree - 1; i++) {', '    Node childNode = node.childPointers[i];', '    if (childNode instanceof LeafNode) {', '      return (LeafNode) childNode;', '      return findLeafNode((InternalNode) node.childPointers[i], key);', '  private int findIndexOfPointer(Node[] pointers, LeafNode node) {', '    for (i = 0; i < pointers.length; i++) {', '      if (pointers[i] == node) {', '    return (int) Math.ceil((this.m + 1) / 2.0) - 1;', '  private void handleDeficiency(InternalNode in) {', '    InternalNode parent = in.parent;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          if (in.childPointers[i] instanceof InternalNode) {', '            this.root = (InternalNode) in.childPointers[i];', '            this.root.parent = null;', '          } else if (in.childPointers[i] instanceof LeafNode) {', '    else if (in.leftSibling != null && in.leftSibling.isLendable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isLendable()) {', '      sibling = in.rightSibling;', '      int borrowedKey = sibling.keys[0];', '      Node pointer = sibling.childPointers[0];', '      in.keys[in.degree - 1] = parent.keys[0];', '      in.childPointers[in.degree] = pointer;', '      parent.keys[0] = borrowedKey;', '      Arrays.sort(sibling.keys);', '      shiftDown(in.childPointers, 1);', '    } else if (in.leftSibling != null && in.leftSibling.isMergeable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isMergeable()) {', '      sibling = in.rightSibling;', '      sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];', '      Arrays.sort(sibling.keys, 0, sibling.degree);', '      parent.keys[parent.degree - 2] = null;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          sibling.prependChildPointer(in.childPointers[i]);', '          in.childPointers[i].parent = sibling;', '      sibling.leftSibling = in.leftSibling;', '    if (parent != null && parent.isDeficient()) {', '  private int linearNullSearch(DictionaryPair[] dps) {', '    for (int i = 0; i < dps.length; i++) {', '  private int linearNullSearch(Node[] pointers) {', '    for (int i = 0; i < pointers.length; i++) {', '      if (pointers[i] == null) {', '  private void shiftDown(Node[] pointers, int amount) {', '    Node[] newPointers = new Node[this.m + 1];', '    for (int i = amount; i < pointers.length; i++) {', '      newPointers[i - amount] = pointers[i];', '  private void sortDictionary(DictionaryPair[] dictionary) {', '    Arrays.sort(dictionary, new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        if (o1 == null && o2 == null) {', '        return o1.compareTo(o2);', '  private Node[] splitChildPointers(InternalNode in, int split) {', '    Node[] pointers = in.childPointers;', '    Node[] halfPointers = new Node[this.m + 1];', '    for (int i = split + 1; i < pointers.length; i++) {', '      halfPointers[i - split - 1] = pointers[i];', '  private DictionaryPair[] splitDictionary(LeafNode ln, int split) {', '    DictionaryPair[] dictionary = ln.dictionary;', '    DictionaryPair[] halfDict = new DictionaryPair[this.m];', '    for (int i = split; i < dictionary.length; i++) {', '      halfDict[i - split] = dictionary[i];', '  private void splitInternalNode(InternalNode in) {', '    InternalNode parent = in.parent;', '    int midpoint = getMidpoint();', '    int newParentKey = in.keys[midpoint];', '    Integer[] halfKeys = splitKeys(in.keys, midpoint);', '    Node[] halfPointers = splitChildPointers(in, midpoint);', '    in.degree = linearNullSearch(in.childPointers);', '    InternalNode sibling = new InternalNode(this.m, halfKeys, halfPointers);', '    for (Node pointer : halfPointers) {', '        pointer.parent = sibling;', '    sibling.rightSibling = in.rightSibling;', '    if (sibling.rightSibling != null) {', '      sibling.rightSibling.leftSibling = sibling;', '      Integer[] keys = new Integer[this.m];', '      InternalNode newRoot = new InternalNode(this.m, keys);', '      newRoot.appendChildPointer(in);', '      newRoot.appendChildPointer(sibling);', '      parent.keys[parent.degree - 1] = newParentKey;', '      Arrays.sort(parent.keys, 0, parent.degree);', '      int pointerIndex = parent.findIndexOfPointer(in) + 1;', '      parent.insertChildPointer(sibling, pointerIndex);', '  private Integer[] splitKeys(Integer[] keys, int split) {', '    Integer[] halfKeys = new Integer[this.m];', '    for (int i = split + 1; i < keys.length; i++) {', '      halfKeys[i - split - 1] = keys[i];', '  public void insert(int key, double value) {', '      LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));', '      LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '      if (!ln.insert(new DictionaryPair(key, value))) {', '        ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);', '        sortDictionary(ln.dictionary);', '        int midpoint = getMidpoint();', '        DictionaryPair[] halfDict = splitDictionary(ln, midpoint);', '        if (ln.parent == null) {', '          Integer[] parent_keys = new Integer[this.m];', '          parent_keys[0] = halfDict[0].key;', '          InternalNode parent = new InternalNode(this.m, parent_keys);', '          parent.appendChildPointer(ln);', '          int newParentKey = halfDict[0].key;', '          ln.parent.keys[ln.parent.degree - 1] = newParentKey;', '          Arrays.sort(ln.parent.keys, 0, ln.parent.degree);', '        LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);', '        int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;', '        ln.parent.insertChildPointer(newLeafNode, pointerIndex);', '        newLeafNode.rightSibling = ln.rightSibling;', '        if (newLeafNode.rightSibling != null) {', '          newLeafNode.rightSibling.leftSibling = newLeafNode;', '        ln.rightSibling = newLeafNode;', '        newLeafNode.leftSibling = ln;', '        if (this.root == null) {', '          this.root = ln.parent;', '          InternalNode in = ln.parent;', '            if (in.isOverfull()) {', '              splitInternalNode(in);', '  public Double search(int key) {', '    LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '    DictionaryPair[] dps = ln.dictionary;', '    int index = binarySearch(dps, ln.numPairs, key);', '  public ArrayList<Double> search(int lowerBound, int upperBound) {', '    ArrayList<Double> values = new ArrayList<Double>();', '    LeafNode currNode = this.firstLeaf;', '      DictionaryPair dps[] = currNode.dictionary;', '      for (DictionaryPair dp : dps) {', '        if (lowerBound <= dp.key && dp.key <= upperBound) {', '      currNode = currNode.rightSibling;', '  private class InternalNode extends Node {', '    private void appendChildPointer(Node pointer) {', '      this.childPointers[degree] = pointer;', '    private int findIndexOfPointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '    private void insertChildPointer(Node pointer, int index) {', '      for (int i = degree - 1; i >= index; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[index] = pointer;', '    private boolean isDeficient() {', '      return this.degree < this.minDegree;', '    private boolean isLendable() {', '      return this.degree > this.minDegree;', '    private boolean isMergeable() {', '      return this.degree == this.minDegree;', '    private boolean isOverfull() {', '      return this.degree == maxDegree + 1;', '    private void prependChildPointer(Node pointer) {', '      for (int i = degree - 1; i >= 0; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[0] = pointer;', '    private void removeKey(int index) {', '    private void removePointer(int index) {', '      this.childPointers[index] = null;', '    private void removePointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '          this.childPointers[i] = null;', '    private InternalNode(int m, Integer[] keys) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.childPointers = new Node[this.maxDegree + 1];', '    private InternalNode(int m, Integer[] keys, Node[] pointers) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.degree = linearNullSearch(pointers);', '      this.childPointers = pointers;', '  public class LeafNode extends Node {', '    DictionaryPair[] dictionary;', '    public void delete(int index) {', '      this.dictionary[index] = null;', '    public boolean insert(DictionaryPair dp) {', '        this.dictionary[numPairs] = dp;', '        Arrays.sort(this.dictionary, 0, numPairs);', '    public boolean isDeficient() {', '      return numPairs < minNumPairs;', '      return numPairs == maxNumPairs;', '    public boolean isLendable() {', '      return numPairs > minNumPairs;', '    public boolean isMergeable() {', '      return numPairs == minNumPairs;', '    public LeafNode(int m, DictionaryPair dp) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.dictionary = new DictionaryPair[m];', '    public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.numPairs = linearNullSearch(dps);', '  public class DictionaryPair implements Comparable<DictionaryPair> {', '    public DictionaryPair(int key, double value) {', '    public int compareTo(DictionaryPair o) {', '  public static void main(String[] args) {', '    if (bpt.search(15) != null) {', '      System.out.println(""Found"");', '      System.out.println(""Not Found"");', 'int pathToLeaves(node *const root, node *child);', 'void printLeaves(node *const root);', 'void printTree(node *const root);', 'void findAndPrint(node *const root, int key, bool verbose);', 'void findAndPrintRange(node *const root, int range1, int range2, bool verbose);', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]);', 'node *findLeaf(node *const root, int key, bool verbose);', 'record *find(node *root, int key, bool verbose, node **leaf_out);', 'int getLeftIndex(node *parent, node *left);', 'node *insertIntoLeaf(node *leaf, int key, record *pointer);', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key,', '                   record *pointer);', 'node *insertIntoNode(node *root, node *parent,', '           int left_index, int key, node *right);', 'node *insertIntoNodeAfterSplitting(node *root, node *parent,', '                   int left_index,', '                   int key, node *right);', 'node *insertIntoParent(node *root, node *left, int key, node *right);', 'node *insertIntoNewRoot(node *left, int key, node *right);', 'node *startNewTree(int key, record *pointer);', 'node *insert(node *root, int key, int value);', 'void printLeaves(node *const root) {', '    for (i = 0; i < c->num_keys; i++) {', '        printf(""%p "", c->pointers[i]);', '      printf(""%d "", c->keys[i]);', '      printf(""%p "", c->pointers[order - 1]);', '    if (c->pointers[order - 1] != NULL) {', '      c = c->pointers[order - 1];', 'int pathToLeaves(node *const root, node *child) {', 'void printTree(node *const root) {', '    if (n->parent != NULL && n == n->parent->pointers[0]) {', '      new_rank = pathToLeaves(root, n);', '    for (i = 0; i < n->num_keys; i++) {', '        printf(""%p "", n->pointers[i]);', '      printf(""%d "", n->keys[i]);', '      for (i = 0; i <= n->num_keys; i++)', '        enqueue(n->pointers[i]);', '        printf(""%p "", n->pointers[order - 1]);', '        printf(""%p "", n->pointers[n->num_keys]);', 'void findAndPrint(node *const root, int key, bool verbose) {', '  record *r = find(root, key, verbose, NULL);', '    printf(""Record not found under key %d.\\n"", key);', '    printf(""Record at %p -- key %d, value %d.\\n"",', 'void findAndPrintRange(node *const root, int key_start, int key_end,', '  int array_size = key_end - key_start + 1;', '  int returned_keys[array_size];', '  void *returned_pointers[array_size];', '  int num_found = findRange(root, key_start, key_end, verbose,', '                returned_keys, returned_pointers);', '    for (i = 0; i < num_found; i++)', '      printf(""Key: %d   Location: %p  Value: %d\\n"",', '           returned_pointers[i],', '            returned_pointers[i])', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]) {', '  node *n = findLeaf(root, key_start, verbose);', '  for (i = 0; i < n->num_keys && n->keys[i] < key_start; i++)', '    for (; i < n->num_keys && n->keys[i] <= key_end; i++) {', '      returned_keys[num_found] = n->keys[i];', '      returned_pointers[num_found] = n->pointers[i];', 'node *findLeaf(node *const root, int key, bool verbose) {', '      for (i = 0; i < c->num_keys - 1; i++)', '        printf(""%d "", c->keys[i]);', '      printf(""%d] "", c->keys[i]);', '    for (i = 0; i < c->num_keys - 1; i++)', '      printf(""%d "", c->keys[i]);', '    printf(""%d] ->\\n"", c->keys[i]);', 'record *find(node *root, int key, bool verbose, node **leaf_out) {', '  leaf = findLeaf(root, key, verbose);', '  for (i = 0; i < leaf->num_keys; i++)', '    return (record *)leaf->pointers[i];', '  record *new_record = (record *)malloc(sizeof(record));', '  new_node = malloc(sizeof(node));', '  new_node->keys = malloc((order - 1) * sizeof(int));', '    perror(""New node keys array."");', '  new_node->pointers = malloc(order * sizeof(void *));', '  if (new_node->pointers == NULL) {', '    perror(""New node pointers array."");', 'int getLeftIndex(node *parent, node *left) {', '  while (left_index <= parent->num_keys &&', '       parent->pointers[left_index] != left)', 'node *insertIntoLeaf(node *leaf, int key, record *pointer) {', '  while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)', '  for (i = leaf->num_keys; i > insertion_point; i--) {', '    leaf->keys[i] = leaf->keys[i - 1];', '    leaf->pointers[i] = leaf->pointers[i - 1];', '  leaf->keys[insertion_point] = key;', '  leaf->pointers[insertion_point] = pointer;', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key, record *pointer) {', '  int insertion_index, split, new_key, i, j;', '  temp_keys = malloc(order * sizeof(int));', '    perror(""Temporary keys array."");', '  temp_pointers = malloc(order * sizeof(void *));', '    perror(""Temporary pointers array."");', '  while (insertion_index < order - 1 && leaf->keys[insertion_index] < key)', '  for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {', '    temp_keys[j] = leaf->keys[i];', '    temp_pointers[j] = leaf->pointers[i];', '  temp_keys[insertion_index] = key;', '  temp_pointers[insertion_index] = pointer;', '    leaf->pointers[i] = temp_pointers[i];', '    leaf->keys[i] = temp_keys[i];', '  for (i = split, j = 0; i < order; i++, j++) {', '    new_leaf->pointers[j] = temp_pointers[i];', '    new_leaf->keys[j] = temp_keys[i];', '  new_leaf->pointers[order - 1] = leaf->pointers[order - 1];', '  leaf->pointers[order - 1] = new_leaf;', '  for (i = leaf->num_keys; i < order - 1; i++)', '  for (i = new_leaf->num_keys; i < order - 1; i++)', '    new_leaf->pointers[i] = NULL;', '  new_leaf->parent = leaf->parent;', '  return insertIntoParent(root, leaf, new_key, new_leaf);', 'node *insertIntoNode(node *root, node *n,', '           int left_index, int key, node *right) {', '  for (i = n->num_keys; i > left_index; i--) {', '    n->pointers[i + 1] = n->pointers[i];', '    n->keys[i] = n->keys[i - 1];', '  n->pointers[left_index + 1] = right;', 'node *insertIntoNodeAfterSplitting(node *root, node *old_node, int left_index,', '                   int key, node *right) {', '  temp_pointers = malloc((order + 1) * sizeof(node *));', '  temp_keys = malloc(order * sizeof(int));', '  for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {', '    temp_pointers[j] = old_node->pointers[i];', '  for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {', '    temp_keys[j] = old_node->keys[i];', '  temp_pointers[left_index + 1] = right;', '  for (i = 0; i < split - 1; i++) {', '    old_node->pointers[i] = temp_pointers[i];', '    old_node->keys[i] = temp_keys[i];', '  old_node->pointers[i] = temp_pointers[i];', '  k_prime = temp_keys[split - 1];', '  for (++i, j = 0; i < order; i++, j++) {', '    new_node->pointers[j] = temp_pointers[i];', '    new_node->keys[j] = temp_keys[i];', '  new_node->pointers[j] = temp_pointers[i];', '  new_node->parent = old_node->parent;', '  for (i = 0; i <= new_node->num_keys; i++) {', '    child = new_node->pointers[i];', '  return insertIntoParent(root, old_node, k_prime, new_node);', 'node *insertIntoParent(node *root, node *left, int key, node *right) {', '    return insertIntoNewRoot(left, key, right);', '  left_index = getLeftIndex(parent, left);', '  if (parent->num_keys < order - 1)', '    return insertIntoNode(root, parent, left_index, key, right);', '  return insertIntoNodeAfterSplitting(root, parent, left_index, key, right);', 'node *insertIntoNewRoot(node *left, int key, node *right) {', 'node *startNewTree(int key, record *pointer) {', '  root->pointers[order - 1] = NULL;', 'node *insert(node *root, int key, int value) {', '  record *record_pointer = NULL;', '  record_pointer = find(root, key, false, NULL);', '    record_pointer->value = value;', '  record_pointer = makeRecord(value);', '    return startNewTree(key, record_pointer);', '  leaf = findLeaf(root, key, false);', '  if (leaf->num_keys < order - 1) {', '    leaf = insertIntoLeaf(leaf, key, record_pointer);', '  return insertIntoLeafAfterSplitting(root, leaf, key, record_pointer);', ""  findAndPrint(root, 15, instruction = 'a');"", '  void insertInternal(int, Node *, Node *);', '  Node *findParent(Node *, Node *);', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '    for (int i = 0; i < cursor->size; i++) {', '      if (cursor->key[i] == x) {', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '      while (x > cursor->key[i] && i < cursor->size)', '      for (int j = cursor->size; j > i; j--) {', '        cursor->key[j] = cursor->key[j - 1];', '      cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];', '      cursor->ptr[cursor->size - 1] = NULL;', '      for (int i = 0; i < MAX; i++) {', '        virtualNode[i] = cursor->key[i];', '      while (x > virtualNode[i] && i < MAX)', '      for (int j = MAX + 1; j > i; j--) {', '        virtualNode[j] = virtualNode[j - 1];', '      cursor->size = (MAX + 1) / 2;', '      newLeaf->size = MAX + 1 - (MAX + 1) / 2;', '      cursor->ptr[cursor->size] = newLeaf;', '      newLeaf->ptr[newLeaf->size] = cursor->ptr[MAX];', '      for (i = 0; i < cursor->size; i++) {', '        cursor->key[i] = virtualNode[i];', '      for (i = 0, j = cursor->size; i < newLeaf->size; i++, j++) {', '        newLeaf->key[i] = virtualNode[j];', '        Node *newRoot = new Node;', '        newRoot->key[0] = newLeaf->key[0];', '        newRoot->ptr[0] = cursor;', '        newRoot->ptr[1] = newLeaf;', '        newRoot->IS_LEAF = false;', '        insertInternal(newLeaf->key[0], parent, newLeaf);', 'void BPTree::insertInternal(int x, Node *cursor, Node *child) {', '    while (x > cursor->key[i] && i < cursor->size)', '    for (int j = cursor->size; j > i; j--) {', '      cursor->key[j] = cursor->key[j - 1];', '    for (int j = cursor->size + 1; j > i + 1; j--) {', '      cursor->ptr[j] = cursor->ptr[j - 1];', '    Node *newInternal = new Node;', '    for (int i = 0; i < MAX; i++) {', '      virtualKey[i] = cursor->key[i];', '    for (int i = 0; i < MAX + 1; i++) {', '      virtualPtr[i] = cursor->ptr[i];', '    while (x > virtualKey[i] && i < MAX)', '    for (int j = MAX + 1; j > i; j--) {', '      virtualKey[j] = virtualKey[j - 1];', '    for (int j = MAX + 2; j > i + 1; j--) {', '      virtualPtr[j] = virtualPtr[j - 1];', '    newInternal->IS_LEAF = false;', '    cursor->size = (MAX + 1) / 2;', '    newInternal->size = MAX - (MAX + 1) / 2;', '    for (i = 0, j = cursor->size + 1; i < newInternal->size; i++, j++) {', '      newInternal->key[i] = virtualKey[j];', '    for (i = 0, j = cursor->size + 1; i < newInternal->size + 1; i++, j++) {', '      newInternal->ptr[i] = virtualPtr[j];', '      newRoot->key[0] = cursor->key[cursor->size];', '      newRoot->ptr[1] = newInternal;', '      insertInternal(cursor->key[cursor->size], findParent(root, cursor), newInternal);', 'Node *BPTree::findParent(Node *cursor, Node *child) {', '  if (cursor->IS_LEAF || (cursor->ptr[0])->IS_LEAF) {', '  for (int i = 0; i < cursor->size + 1; i++) {', '    if (cursor->ptr[i] == child) {', '      parent = findParent(cursor->ptr[i], child);', 'void BPTree::display(Node *cursor) {', '    for (int i = 0; i < cursor->size; i++) {', '      cout << cursor->key[i] << "" "";', '    if (cursor->IS_LEAF != true) {', '      for (int i = 0; i < cursor->size + 1; i++) {', '        display(cursor->ptr[i]);']",[],[],"['The root has at least two children.|||Each node except root can have a maximum of m children and at least m/2 children.|||Each node can contain a maximum of m - 1 keys and a minimum of ⌈m/2⌉ - 1 keys.|||&&&Since every element is inserted into the leaf node, go to the appropriate leaf node.|||Insert the key into the leaf node.|||If the leaf is not full, insert the key into the leaf node in increasing order.|||If the leaf is full, insert the key into the leaf node in increasing order and balance the tree in the following way.|||Break the node at m/2th position.|||Add m/2th key to the parent node as well.|||If the parent node is already full, follow steps 2 to 3.|||Insert 5.|||Insert 5|||Insert 15.|||Insert 15|||Insert 25.|||Insert 25|||Insert 35.|||Insert 35|||Insert 45.|||Insert 45|||']"
33,['Deletion from a B+ Tree'],"['In this tutorial, you will learn about deletion operation on a B+ tree. Also, you will find working examples of deleting elements from a B+ tree in C, C++, Java and Python.']",[],[],"['Deletion Operation', 'Python, Java and C/C++ Examples', 'Deletion Complexity']","['Case I', 'Case II', 'Case III']","['//cdn.programiz.com/sites/tutorial2program/files/deletion-1-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/deletion-2-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/deletion-3-b+tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/deletion-4-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/deletion-5-b+tree.png', '//cdn.programiz.com/sites/tutorial2program/files/deletion-6-b+tree.png']","['Time complexity: Θ(t.logt n)', 'The complexity is dominated by Θ(logt n).']","['Before going through the steps below, one must know these facts about a B+ tree of degree m.', 'The key to be deleted is present only at the leaf node not in the indexes (or internal nodes). There are two cases for it:']","['Deleting an element on a B+ tree consists of three main events: searching the node where the key to be deleted exists, deleting the key and balancing the tree if required.Underflow is a situation when there is less number of keys in a node than the minimum number of keys it should hold.', 'While deleting a key, we have to take care of the keys present in the internal nodes (i.e. indexes) as well because the values are redundant in a B+ tree. Search the key to be deleted then follow the following steps.', 'The key to be deleted is present in the internal nodes as well. Then we have to remove them from the internal nodes as well. There are the following cases for this situation.', 'In this case, the height of the tree gets shrinked. It is a little complicated.Deleting 55 from the tree below leads to this condition. It can be understood in the illustrations below.']","['# B+ tee in python', 'import math', '# Node creation', 'class Node:', '    def __init__(self, order):', '        self.order = order', '        self.values = []', '        self.keys = []', '        self.nextKey = None', '        self.parent = None', '    # Insert at the leaf', '        if (self.values):', '                    break', '                    break', '                    break', '        else:', '# B plus tree', 'class BplusTree:', '    def __init__(self, order):', '    # Insert operation', '        value = str(value)', '    def search(self, value):', '                    break', '                    break', '                    break', '        return current_node', '    # Find the node', '        l = self.search(value)', '            if item == value:', '                else:', '        return False', '    # Inserting at the parent', '        if (self.root == n):', '            return', '        parentNode = n.parent', '                    else:', '    # Delete a node', '        temp = 0', '            if item == value:', '                temp = 1', '                    else:', '                else:', '                    return', '        if temp == 0:', '            return', '    # Delete an entry', '                    break', '                    break', '            del node_', '            return', '            is_predecessor = 0', '            PrevNode = -1', '            NextNode = -1', '            PrevK = -1', '            PostK = -1', '                    if i > 0:', '            if PrevNode == -1:', '                value_ = PostK', '                value_ = PrevK', '            else:', '                else:', '                else:', '                del node_', '            else:', '                    else:', '                else:', '                    else:', '# Print the tree', 'def printTree(tree):', '    lst = [tree.root]', '    level = [0]', '    leaf = None', '    flag = 0', '    lev_leaf = 0', '    while (len(lst) != 0):', '        x = lst.pop(0)', '        lev = level.pop(0)', '        else:', '            if (flag == 0):', '                lev_leaf = lev', '                leaf = x', '                flag = 1', 'record_len = 3', ""bplustree.insert('5', '33')"", ""bplustree.insert('15', '21')"", ""bplustree.insert('25', '31')"", ""bplustree.insert('35', '41')"", ""bplustree.insert('45', '10')"", 'printTree(bplustree)', ""if(bplustree.find('5', '34')):"", '    print(""Found"")', '    print(""Not found"")', 'import java.util.*;', 'public class BPlusTree {', '  int m;', '  InternalNode root;', '  LeafNode firstLeaf;', '      @Override', '        return a.compareTo(b);', '    int i;', '      if (key < keys[i]) {', '        break;', '      return (LeafNode) child;', '    } else {', '    int i;', '      if (key < keys[i]) {', '        break;', '    } else {', '    int i;', '        break;', '    return i;', '  private int getMidpoint() {', '    InternalNode sibling;', '    if (this.root == in) {', '            this.root = null;', '          }', '        }', '          in.removePointer(i);', '        }', '  private boolean isEmpty() {', '    return firstLeaf == null;', '      if (dps[i] == null) {', '        return i;', '    return -1;', '        return i;', '    return -1;', '    pointers = newPointers;', '      @Override', '          return 0;', '        }', '        if (o1 == null) {', '          return 1;', '        }', '        if (o2 == null) {', '          return -1;', '        }', '      in.removePointer(i);', '    return halfPointers;', '      ln.delete(i);', '    return halfDict;', '      if (pointer != null) {', '    in.rightSibling = sibling;', '    sibling.leftSibling = in;', '    if (parent == null) {', '      keys[0] = newParentKey;', '      this.root = newRoot;', '      in.parent = newRoot;', '    } else {', '      sibling.parent = parent;', '    keys[split] = null;', '      keys[i] = null;', '    return halfKeys;', '    if (isEmpty()) {', '      this.firstLeaf = ln;', '    } else {', '        ln.numPairs++;', '          ln.parent = parent;', '        } else {', '        }', '        }', '        } else {', '          while (in != null) {', '            } else {', '              break;', '            }', '            in = in.parent;', '          }', '        }', '    if (isEmpty()) {', '      return null;', '    if (index < 0) {', '      return null;', '    } else {', '      return dps[index].value;', '    while (currNode != null) {', '        if (dp == null) {', '          break;', '        }', '        }', '    return values;', '  public BPlusTree(int m) {', '    this.m = m;', '    this.root = null;', '  public class Node {', '    InternalNode parent;', '    int maxDegree;', '    int minDegree;', '    int degree;', '    InternalNode leftSibling;', '    InternalNode rightSibling;', '    Integer[] keys;', '    Node[] childPointers;', '      this.degree++;', '          return i;', '        }', '      return -1;', '      this.degree++;', '      this.degree++;', '      this.keys[index] = null;', '      this.degree--;', '        }', '      this.degree--;', '      this.maxDegree = m;', '      this.degree = 0;', '      this.keys = keys;', '      this.maxDegree = m;', '      this.keys = keys;', '    int maxNumPairs;', '    int minNumPairs;', '    int numPairs;', '    LeafNode leftSibling;', '    LeafNode rightSibling;', '      numPairs--;', '      if (this.isFull()) {', '        return false;', '      } else {', '        numPairs++;', '        return true;', '    public boolean isFull() {', '      this.numPairs = 0;', '      this.insert(dp);', '      this.dictionary = dps;', '      this.parent = parent;', '    int key;', '    double value;', '      this.key = key;', '      this.value = value;', '      if (key == o.key) {', '        return 0;', '        return 1;', '      } else {', '        return -1;', '    BPlusTree bpt = null;', '    bpt = new BPlusTree(3);', '    bpt.insert(5, 33);', '    bpt.insert(15, 21);', '    bpt.insert(25, 31);', '    bpt.insert(35, 41);', '    bpt.insert(45, 10);', '    } else {', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', '#include <string.h>', '#define ORDER 3', 'typedef struct record {', '  int value;', '} record;', 'typedef struct node {', '  void **pointers;', '  int *keys;', '  struct node *parent;', '  bool is_leaf;', '  int num_keys;', '  struct node *next;', 'int order = ORDER;', 'node *queue = NULL;', 'bool verbose_output = false;', 'void enqueue(node *new_node);', 'node *dequeue(void);', 'int height(node *const root);', 'int cut(int length);', 'record *makeRecord(int value);', 'node *makeNode(void);', 'node *makeLeaf(void);', 'void enqueue(node *new_node) {', '  node *c;', '  if (queue == NULL) {', '    queue = new_node;', '    queue->next = NULL;', '  } else {', '    c = queue;', '    while (c->next != NULL) {', '      c = c->next;', '    c->next = new_node;', '    new_node->next = NULL;', 'node *dequeue(void) {', '  node *n = queue;', '  queue = queue->next;', '  n->next = NULL;', '  return n;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  int i;', '  node *c = root;', '  while (!c->is_leaf)', '    c = c->pointers[0];', '  while (true) {', '      if (verbose_output)', '    if (verbose_output)', '      printf("" | "");', '    } else', '      break;', '  printf(""\\n"");', 'int height(node *const root) {', '  int h = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    c = c->pointers[0];', '    h++;', '  return h;', '  int length = 0;', '  node *c = child;', '  while (c != root) {', '    c = c->parent;', '    length++;', '  return length;', '  node *n = NULL;', '  int i = 0;', '  int rank = 0;', '  int new_rank = 0;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  queue = NULL;', '  enqueue(root);', '  while (queue != NULL) {', '    n = dequeue();', '      if (new_rank != rank) {', '        rank = new_rank;', '        printf(""\\n"");', '    if (verbose_output)', '      printf(""(%p)"", n);', '      if (verbose_output)', '    if (!n->is_leaf)', '    if (verbose_output) {', '      if (n->is_leaf)', '      else', '    printf(""| "");', '  printf(""\\n"");', '  node *leaf = NULL;', '  if (r == NULL)', '         r, key, r->value);', '             bool verbose) {', '  int i;', '  if (!num_found)', '    printf(""None found.\\n"");', '  else {', '           returned_keys[i],', '           ((record *)', '             ->value);', '  int i, num_found;', '  num_found = 0;', '  if (n == NULL)', '    return 0;', '  if (i == n->num_keys)', '    return 0;', '  while (n != NULL) {', '      num_found++;', '    i = 0;', '  return num_found;', '  if (root == NULL) {', '    if (verbose)', '      printf(""Empty tree.\\n"");', '    return root;', '  int i = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    if (verbose) {', '      printf(""["");', '    i = 0;', '    while (i < c->num_keys) {', '      if (key >= c->keys[i])', '        i++;', '      else', '        break;', '    if (verbose)', '      printf(""%d ->\\n"", i);', '  if (verbose) {', '    printf(""Leaf ["");', '  return c;', '  if (root == NULL) {', '    if (leaf_out != NULL) {', '      *leaf_out = NULL;', '    return NULL;', '  int i = 0;', '  node *leaf = NULL;', '    if (leaf->keys[i] == key)', '      break;', '  if (leaf_out != NULL) {', '    *leaf_out = leaf;', '  if (i == leaf->num_keys)', '    return NULL;', 'int cut(int length) {', '  if (length % 2 == 0)', '    return length / 2;', '    return length / 2 + 1;', '  if (new_record == NULL) {', '    exit(EXIT_FAILURE);', '  } else {', '    new_record->value = value;', '  return new_record;', 'node *makeNode(void) {', '  node *new_node;', '  if (new_node == NULL) {', '    perror(""Node creation."");', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '  new_node->is_leaf = false;', '  new_node->num_keys = 0;', '  new_node->parent = NULL;', '  new_node->next = NULL;', '  return new_node;', 'node *makeLeaf(void) {', '  node *leaf = makeNode();', '  leaf->is_leaf = true;', '  return leaf;', '  int left_index = 0;', '    left_index++;', '  return left_index;', '  int i, insertion_point;', '  insertion_point = 0;', '    insertion_point++;', '  leaf->num_keys++;', '  return leaf;', '  node *new_leaf;', '  int *temp_keys;', '  void **temp_pointers;', '  new_leaf = makeLeaf();', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  insertion_index = 0;', '    insertion_index++;', '    if (j == insertion_index)', '      j++;', '  leaf->num_keys = 0;', '  split = cut(order - 1);', '    leaf->num_keys++;', '    new_leaf->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    leaf->pointers[i] = NULL;', '  new_key = new_leaf->keys[0];', '  int i;', '  n->keys[left_index] = key;', '  n->num_keys++;', '  return root;', '  int i, j, split, k_prime;', '  node *new_node, *child;', '  int *temp_keys;', '  node **temp_pointers;', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '    if (j == left_index + 1)', '      j++;', '    if (j == left_index)', '      j++;', '  temp_keys[left_index] = key;', '  split = cut(order);', '  new_node = makeNode();', '  old_node->num_keys = 0;', '    old_node->num_keys++;', '    new_node->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    child->parent = new_node;', '  int left_index;', '  node *parent;', '  parent = left->parent;', '  if (parent == NULL)', '  node *root = makeNode();', '  root->keys[0] = key;', '  root->pointers[0] = left;', '  root->pointers[1] = right;', '  root->num_keys++;', '  root->parent = NULL;', '  left->parent = root;', '  right->parent = root;', '  return root;', '  node *root = makeLeaf();', '  root->keys[0] = key;', '  root->pointers[0] = pointer;', '  root->parent = NULL;', '  root->num_keys++;', '  return root;', '  node *leaf = NULL;', '    return root;', '  if (root == NULL)', '    return root;', 'int main() {', '  node *root;', '  char instruction;', '  root = NULL;', '  root = insert(root, 5, 33);', '  root = insert(root, 15, 21);', '  root = insert(root, 25, 31);', '  root = insert(root, 35, 41);', '  root = insert(root, 45, 10);', '  printTree(root);', '#include <stdbool.h>', '#include <stdio.h>', '#include <stdlib.h>', '#include <string.h>', '#define DEFAULT_ORDER 3', 'typedef struct record {', '  int value;', '} record;', 'typedef struct node {', '  void **pointers;', '  int *keys;', '  struct node *parent;', '  bool is_leaf;', '  int num_keys;', '  struct node *next;', 'int order = DEFAULT_ORDER;', 'node *queue = NULL;', 'bool verbose_output = false;', 'void enqueue(node *new_node);', 'node *dequeue(void);', 'int height(node *const root);', 'int cut(int length);', 'node *make_node(void);', 'node *make_leaf(void);', 'node *adjust_root(node *root);', 'void enqueue(node *new_node) {', '  node *c;', '  if (queue == NULL) {', '    queue = new_node;', '    queue->next = NULL;', '  } else {', '    c = queue;', '    while (c->next != NULL) {', '      c = c->next;', '    c->next = new_node;', '    new_node->next = NULL;', 'node *dequeue(void) {', '  node *n = queue;', '  queue = queue->next;', '  n->next = NULL;', '  return n;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  int i;', '  node *c = root;', '  while (!c->is_leaf)', '    c = c->pointers[0];', '  while (true) {', '      if (verbose_output)', '    if (verbose_output)', '      printf("" | "");', '    } else', '      break;', '  printf(""\\n"");', 'int height(node *const root) {', '  int h = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    c = c->pointers[0];', '    h++;', '  return h;', '  int length = 0;', '  node *c = child;', '  while (c != root) {', '    c = c->parent;', '    length++;', '  return length;', '  node *n = NULL;', '  int i = 0;', '  int rank = 0;', '  int new_rank = 0;', '  if (root == NULL) {', '    printf(""Empty tree.\\n"");', '    return;', '  queue = NULL;', '  enqueue(root);', '  while (queue != NULL) {', '    n = dequeue();', '      if (new_rank != rank) {', '        rank = new_rank;', '        printf(""\\n"");', '    if (verbose_output)', '      printf(""(%p)"", n);', '      if (verbose_output)', '    if (!n->is_leaf)', '    if (verbose_output) {', '      if (n->is_leaf)', '      else', '    printf(""| "");', '  printf(""\\n"");', '  node *leaf = NULL;', '  if (r == NULL)', '         r, key, r->value);', '              bool verbose) {', '  int i;', '  if (!num_found)', '    printf(""None found.\\n"");', '  else {', '           returned_keys[i],', '           ((record *)', '             ->value);', '  int i, num_found;', '  num_found = 0;', '  if (n == NULL)', '    return 0;', '  if (i == n->num_keys)', '    return 0;', '  while (n != NULL) {', '      num_found++;', '    i = 0;', '  return num_found;', '  if (root == NULL) {', '    if (verbose)', '      printf(""Empty tree.\\n"");', '    return root;', '  int i = 0;', '  node *c = root;', '  while (!c->is_leaf) {', '    if (verbose) {', '      printf(""["");', '    i = 0;', '    while (i < c->num_keys) {', '      if (key >= c->keys[i])', '        i++;', '      else', '        break;', '    if (verbose)', '      printf(""%d ->\\n"", i);', '  if (verbose) {', '    printf(""Leaf ["");', '  return c;', '  if (root == NULL) {', '    if (leaf_out != NULL) {', '      *leaf_out = NULL;', '    return NULL;', '  int i = 0;', '  node *leaf = NULL;', '    if (leaf->keys[i] == key)', '      break;', '  if (leaf_out != NULL) {', '    *leaf_out = leaf;', '  if (i == leaf->num_keys)', '    return NULL;', 'int cut(int length) {', '  if (length % 2 == 0)', '    return length / 2;', '    return length / 2 + 1;', '  if (new_record == NULL) {', '    exit(EXIT_FAILURE);', '  } else {', '    new_record->value = value;', '  return new_record;', 'node *make_node(void) {', '  node *new_node;', '  if (new_node == NULL) {', '    perror(""Node creation."");', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '    exit(EXIT_FAILURE);', '  new_node->is_leaf = false;', '  new_node->num_keys = 0;', '  new_node->parent = NULL;', '  new_node->next = NULL;', '  return new_node;', 'node *make_leaf(void) {', '  node *leaf = make_node();', '  leaf->is_leaf = true;', '  return leaf;', '  int left_index = 0;', '    left_index++;', '  return left_index;', '  int i, insertion_point;', '  insertion_point = 0;', '    insertion_point++;', '  leaf->num_keys++;', '  return leaf;', '  node *new_leaf;', '  int *temp_keys;', '  void **temp_pointers;', '  new_leaf = make_leaf();', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  insertion_index = 0;', '    insertion_index++;', '    if (j == insertion_index)', '      j++;', '  leaf->num_keys = 0;', '  split = cut(order - 1);', '    leaf->num_keys++;', '    new_leaf->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    leaf->pointers[i] = NULL;', '  new_key = new_leaf->keys[0];', '  int i;', '  n->keys[left_index] = key;', '  n->num_keys++;', '  return root;', '  int i, j, split, k_prime;', '  node *new_node, *child;', '  int *temp_keys;', '  node **temp_pointers;', '  if (temp_pointers == NULL) {', '    exit(EXIT_FAILURE);', '  if (temp_keys == NULL) {', '    exit(EXIT_FAILURE);', '    if (j == left_index + 1)', '      j++;', '    if (j == left_index)', '      j++;', '  temp_keys[left_index] = key;', '  split = cut(order);', '  new_node = make_node();', '  old_node->num_keys = 0;', '    old_node->num_keys++;', '    new_node->num_keys++;', '  free(temp_pointers);', '  free(temp_keys);', '    child->parent = new_node;', '  int left_index;', '  node *parent;', '  parent = left->parent;', '  if (parent == NULL)', '  node *root = make_node();', '  root->keys[0] = key;', '  root->pointers[0] = left;', '  root->pointers[1] = right;', '  root->num_keys++;', '  root->parent = NULL;', '  left->parent = root;', '  right->parent = root;', '  return root;', '  node *root = make_leaf();', '  root->keys[0] = key;', '  root->pointers[0] = pointer;', '  root->parent = NULL;', '  root->num_keys++;', '  return root;', '  node *leaf = NULL;', '    return root;', '  if (root == NULL)', '    return root;', '  int i;', '      return i - 1;', '  exit(EXIT_FAILURE);', '  int i, num_pointers;', '  i = 0;', '  while (n->keys[i] != key)', '    i++;', '  i = 0;', '    i++;', '  n->num_keys--;', '  if (n->is_leaf)', '      n->pointers[i] = NULL;', '      n->pointers[i] = NULL;', '  return n;', '  node *new_root;', '  if (root->num_keys > 0)', '    return root;', '  if (!root->is_leaf) {', '    new_root->parent = NULL;', '    new_root = NULL;', '  free(root->keys);', '  free(root->pointers);', '  free(root);', '  return new_root;', '  node *tmp;', '  if (neighbor_index == -1) {', '    tmp = n;', '    n = neighbor;', '    neighbor = tmp;', '  if (!n->is_leaf) {', '    neighbor->num_keys++;', '    n_end = n->num_keys;', '      neighbor->num_keys++;', '      n->num_keys--;', '      tmp->parent = neighbor;', '  else {', '      neighbor->num_keys++;', '  free(n->keys);', '  free(n->pointers);', '  free(n);', '  return root;', '  int i;', '  node *tmp;', '  if (neighbor_index != -1) {', '    if (!n->is_leaf)', '    if (!n->is_leaf) {', '      tmp->parent = n;', '      n->keys[0] = k_prime;', '    } else {', '  else {', '    if (n->is_leaf) {', '    } else {', '      tmp->parent = n;', '    if (!n->is_leaf)', '  n->num_keys++;', '  neighbor->num_keys--;', '  return root;', '  int min_keys;', '  node *neighbor;', '  int neighbor_index;', '  int k_prime_index, k_prime;', '  int capacity;', '  if (n == root)', '    return adjust_root(root);', '  if (n->num_keys >= min_keys)', '    return root;', '  node *key_leaf = NULL;', '  record *key_record = NULL;', '    free(key_record);', '  return root;', '  int i;', '  if (root->is_leaf)', '      free(root->pointers[i]);', '  free(root->pointers);', '  free(root->keys);', '  free(root);', '  destroy_tree_nodes(root);', '  return NULL;', 'int main() {', '  node *root;', '  char instruction;', '  root = NULL;', '  root = insert(root, 5, 33);', '  root = insert(root, 15, 21);', '  root = insert(root, 25, 31);', '  root = insert(root, 35, 41);', '  root = insert(root, 45, 10);', '  print_tree(root);', '  root = delete (root, 5);', '  print_tree(root);', '#include <climits>', '#include <fstream>', '#include <iostream>', '#include <sstream>', 'using namespace std;', 'int MAX = 3;', 'class BPTree;', 'class Node {', '  bool IS_LEAF;', '  int *key, size;', '  Node **ptr;', '  friend class BPTree;', '   public:', '  Node();', 'class BPTree {', '  Node *root;', '   public:', '  BPTree();', '  void search(int);', '  void insert(int);', '  void remove(int);', '  void display(Node *);', '  Node *getRoot();', 'Node::Node() {', '  key = new int[MAX];', '  ptr = new Node *[MAX + 1];', 'BPTree::BPTree() {', '  root = NULL;', 'void BPTree::insert(int x) {', '  if (root == NULL) {', '    root = new Node;', '    root->key[0] = x;', '    root->IS_LEAF = true;', '    root->size = 1;', '  } else {', '    Node *cursor = root;', '    Node *parent;', '      parent = cursor;', '          break;', '        }', '          break;', '        }', '    if (cursor->size < MAX) {', '      int i = 0;', '        i++;', '      cursor->key[i] = x;', '      cursor->size++;', '    } else {', '      int i = 0, j;', '        i++;', '      virtualNode[i] = x;', '      newLeaf->IS_LEAF = true;', '      cursor->ptr[MAX] = NULL;', '      if (cursor == root) {', '        newRoot->size = 1;', '        root = newRoot;', '      } else {', '  if (cursor->size < MAX) {', '    int i = 0;', '      i++;', '    cursor->key[i] = x;', '    cursor->size++;', '  } else {', '    int virtualKey[MAX + 1];', '    Node *virtualPtr[MAX + 2];', '    int i = 0, j;', '      i++;', '    virtualKey[i] = x;', '    virtualPtr[i + 1] = child;', '    if (cursor == root) {', '      newRoot->size = 1;', '      root = newRoot;', '    } else {', '  Node *parent;', '    return NULL;', '      parent = cursor;', '      return parent;', '    } else {', '      if (parent != NULL)', '        return parent;', '  return parent;', 'void BPTree::remove(int x) {', '  if (root == NULL) {', '    cout << ""Tree empty\\n"";', '  } else {', '    Node *cursor = root;', '    Node *parent;', '        parent = cursor;', '        leftSibling = i - 1;', '        rightSibling = i + 1;', '          break;', '        }', '          leftSibling = i;', '          break;', '        }', '    bool found = false;', '    int pos;', '        found = true;', '        break;', '    if (!found) {', '      cout << ""Not found\\n"";', '      return;', '    cursor->size--;', '    if (cursor == root) {', '        cursor->ptr[i] = NULL;', '      if (cursor->size == 0) {', '        cout << ""Tree died\\n"";', '        delete[] cursor->key;', '        delete[] cursor->ptr;', '        delete cursor;', '        root = NULL;', '      return;', '      return;', '    if (leftSibling >= 0) {', '        }', '        cursor->size++;', '        leftNode->size--;', '        return;', '        cursor->size++;', '        rightNode->size--;', '        }', '        return;', '    if (leftSibling >= 0) {', '      delete[] cursor->key;', '      delete[] cursor->ptr;', '      delete cursor;', '      delete[] rightNode->key;', '      delete[] rightNode->ptr;', '      delete rightNode;', '  if (cursor == root) {', '    if (cursor->size == 1) {', '        delete[] child->key;', '        delete[] child->ptr;', '        delete child;', '        root = cursor->ptr[0];', '        delete[] cursor->key;', '        delete[] cursor->ptr;', '        delete cursor;', '        return;', '        delete[] child->key;', '        delete[] child->ptr;', '        delete child;', '        root = cursor->ptr[1];', '        delete[] cursor->key;', '        delete[] cursor->ptr;', '        delete cursor;', '        return;', '  int pos;', '      break;', '      break;', '  cursor->size--;', '    return;', '  if (cursor == root)', '    return;', '      leftSibling = pos - 1;', '      rightSibling = pos + 1;', '      break;', '  if (leftSibling >= 0) {', '      cursor->size++;', '      leftNode->size--;', '      return;', '      cursor->size++;', '      rightNode->size--;', '      return;', '  if (leftSibling >= 0) {', '      cursor->ptr[j] = NULL;', '    cursor->size = 0;', '    rightNode->size = 0;', '  if (cursor != NULL) {', '    cout << ""\\n"";', 'Node *BPTree::getRoot() {', '  return root;', 'int main() {', '  BPTree node;', '  node.insert(5);', '  node.insert(15);', '  node.insert(25);', '  node.insert(35);', '  node.insert(45);', '  node.remove(15);']","['    def insert_at_leaf(self, leaf, value, key):', '            for i in range(len(temp1)):', '                if (value == temp1[i]):', '                    self.keys[i].append(key)', '                elif (value < temp1[i]):', '                    self.values = self.values[:i] + [value] + self.values[i:]', '                    self.keys = self.keys[:i] + [[key]] + self.keys[i:]', '                elif (i + 1 == len(temp1)):', '                    self.values.append(value)', '                    self.keys.append([key])', '            self.values = [value]', '        self.root.check_leaf = True', '    def insert(self, value, key):', '        old_node = self.search(value)', '        old_node.insert_at_leaf(old_node, value, key)', '        if (len(old_node.values) == old_node.order):', '            node1 = Node(old_node.order)', '            node1.check_leaf = True', '            node1.parent = old_node.parent', '            mid = int(math.ceil(old_node.order / 2)) - 1', '            node1.values = old_node.values[mid + 1:]', '            node1.keys = old_node.keys[mid + 1:]', '            node1.nextKey = old_node.nextKey', '            old_node.values = old_node.values[:mid + 1]', '            old_node.keys = old_node.keys[:mid + 1]', '            old_node.nextKey = node1', '            self.insert_in_parent(old_node, node1.values[0], node1)', '    # Search operation for different operations', '        current_node = self.root', '        while(current_node.check_leaf == False):', '            temp2 = current_node.values', '            for i in range(len(temp2)):', '                if (value == temp2[i]):', '                    current_node = current_node.keys[i + 1]', '                elif (value < temp2[i]):', '                    current_node = current_node.keys[i]', '                elif (i + 1 == len(current_node.values)):', '                    current_node = current_node.keys[i + 1]', '        for i, item in enumerate(l.values):', '                if key in l.keys[i]:', '                    return False', '    def insert_in_parent(self, n, value, ndash):', '            rootNode = Node(n.order)', '            rootNode.values = [value]', '            rootNode.keys = [n, ndash]', '            self.root = rootNode', '            ndash.parent = rootNode', '        for i in range(len(temp3)):', '                parentNode.values = parentNode.values[:i] + \\', '                    [value] + parentNode.values[i:]', '                parentNode.keys = parentNode.keys[:i +', '                                                  1] + [ndash] + parentNode.keys[i + 1:]', '                if (len(parentNode.keys) > parentNode.order):', '                    parentdash = Node(parentNode.order)', '                    parentdash.parent = parentNode.parent', '                    mid = int(math.ceil(parentNode.order / 2)) - 1', '                    parentdash.values = parentNode.values[mid + 1:]', '                    parentdash.keys = parentNode.keys[mid + 1:]', '                    value_ = parentNode.values[mid]', '                    if (mid == 0):', '                        parentNode.values = parentNode.values[:mid + 1]', '                        parentNode.values = parentNode.values[:mid]', '                    parentNode.keys = parentNode.keys[:mid + 1]', '                    for j in parentNode.keys:', '                        j.parent = parentNode', '                    for j in parentdash.keys:', '                        j.parent = parentdash', '                    self.insert_in_parent(parentNode, value_, parentdash)', '    def delete(self, value, key):', '        node_ = self.search(value)', '        for i, item in enumerate(node_.values):', '                if key in node_.keys[i]:', '                    if len(node_.keys[i]) > 1:', '                        node_.keys[i].pop(node_.keys[i].index(key))', '                    elif node_ == self.root:', '                        node_.values.pop(i)', '                        node_.keys.pop(i)', '                        node_.keys[i].pop(node_.keys[i].index(key))', '                        del node_.keys[i]', '                        node_.values.pop(node_.values.index(value))', '                        self.deleteEntry(node_, value, key)', '                    print(""Value not in Key"")', '            print(""Value not in Tree"")', '    def deleteEntry(self, node_, value, key):', '        if not node_.check_leaf:', '            for i, item in enumerate(node_.keys):', '                    node_.keys.pop(i)', '            for i, item in enumerate(node_.values):', '                if item == value:', '                    node_.values.pop(i)', '        if self.root == node_ and len(node_.keys) == 1:', '            self.root = node_.keys[0]', '            node_.keys[0].parent = None', '        elif (len(node_.keys) < int(math.ceil(node_.order / 2)) and node_.check_leaf == False) or (len(node_.values) < int(math.ceil((node_.order - 1) / 2)) and node_.check_leaf == True):', '            parentNode = node_.parent', '            for i, item in enumerate(parentNode.keys):', '                if item == node_:', '                        PrevNode = parentNode.keys[i - 1]', '                        PrevK = parentNode.values[i - 1]', '                    if i < len(parentNode.keys) - 1:', '                        NextNode = parentNode.keys[i + 1]', '                        PostK = parentNode.values[i]', '                ndash = NextNode', '            elif NextNode == -1:', '                is_predecessor = 1', '                ndash = PrevNode', '                if len(node_.values) + len(NextNode.values) < node_.order:', '                    ndash = NextNode', '                    value_ = PostK', '                    is_predecessor = 1', '                    ndash = PrevNode', '                    value_ = PrevK', '            if len(node_.values) + len(ndash.values) < node_.order:', '                if is_predecessor == 0:', '                    node_, ndash = ndash, node_', '                ndash.keys += node_.keys', '                if not node_.check_leaf:', '                    ndash.values.append(value_)', '                    ndash.nextKey = node_.nextKey', '                ndash.values += node_.values', '                if not ndash.check_leaf:', '                    for j in ndash.keys:', '                        j.parent = ndash', '                self.deleteEntry(node_.parent, value_, node_)', '                if is_predecessor == 1:', '                    if not node_.check_leaf:', '                        ndashpm = ndash.keys.pop(-1)', '                        ndashkm_1 = ndash.values.pop(-1)', '                        node_.keys = [ndashpm] + node_.keys', '                        node_.values = [value_] + node_.values', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                p.values[i] = ndashkm_1', '                                break', '                        ndashpm = ndash.keys.pop(-1)', '                        ndashkm = ndash.values.pop(-1)', '                        node_.keys = [ndashpm] + node_.keys', '                        node_.values = [ndashkm] + node_.values', '                        parentNode = node_.parent', '                        for i, item in enumerate(p.values):', '                            if item == value_:', '                                parentNode.values[i] = ndashkm', '                                break', '                    if not node_.check_leaf:', '                        ndashp0 = ndash.keys.pop(0)', '                        ndashk0 = ndash.values.pop(0)', '                        node_.keys = node_.keys + [ndashp0]', '                        node_.values = node_.values + [value_]', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                parentNode.values[i] = ndashk0', '                                break', '                        ndashp0 = ndash.keys.pop(0)', '                        ndashk0 = ndash.values.pop(0)', '                        node_.keys = node_.keys + [ndashp0]', '                        node_.values = node_.values + [ndashk0]', '                        parentNode = node_.parent', '                        for i, item in enumerate(parentNode.values):', '                            if item == value_:', '                                parentNode.values[i] = ndash.values[0]', '                                break', '                if not ndash.check_leaf:', '                    for j in ndash.keys:', '                        j.parent = ndash', '                if not node_.check_leaf:', '                    for j in node_.keys:', '                        j.parent = node_', '                if not parentNode.check_leaf:', '                    for j in parentNode.keys:', '                        j.parent = parentNode', '    node1 = Node(str(level[0]) + str(tree.root.values))', '        if (x.check_leaf == False):', '            for i, item in enumerate(x.keys):', '                print(item.values)', '            for i, item in enumerate(x.keys):', '                print(item.values)', 'bplustree = BplusTree(record_len)', '  private int binarySearch(DictionaryPair[] dps, int numPairs, int t) {', '    Comparator<DictionaryPair> c = new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        Integer a = Integer.valueOf(o1.key);', '        Integer b = Integer.valueOf(o2.key);', '    return Arrays.binarySearch(dps, 0, numPairs, new DictionaryPair(t, 0), c);', '  private LeafNode findLeafNode(int key) {', '    Integer[] keys = this.root.keys;', '    for (i = 0; i < this.root.degree - 1; i++) {', '    Node child = this.root.childPointers[i];', '    if (child instanceof LeafNode) {', '      return findLeafNode((InternalNode) child, key);', '  private LeafNode findLeafNode(InternalNode node, int key) {', '    for (i = 0; i < node.degree - 1; i++) {', '    Node childNode = node.childPointers[i];', '    if (childNode instanceof LeafNode) {', '      return (LeafNode) childNode;', '      return findLeafNode((InternalNode) node.childPointers[i], key);', '  private int findIndexOfPointer(Node[] pointers, LeafNode node) {', '    for (i = 0; i < pointers.length; i++) {', '      if (pointers[i] == node) {', '    return (int) Math.ceil((this.m + 1) / 2.0) - 1;', '  private void handleDeficiency(InternalNode in) {', '    InternalNode parent = in.parent;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          if (in.childPointers[i] instanceof InternalNode) {', '            this.root = (InternalNode) in.childPointers[i];', '            this.root.parent = null;', '          } else if (in.childPointers[i] instanceof LeafNode) {', '    else if (in.leftSibling != null && in.leftSibling.isLendable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isLendable()) {', '      sibling = in.rightSibling;', '      int borrowedKey = sibling.keys[0];', '      Node pointer = sibling.childPointers[0];', '      in.keys[in.degree - 1] = parent.keys[0];', '      in.childPointers[in.degree] = pointer;', '      parent.keys[0] = borrowedKey;', '      Arrays.sort(sibling.keys);', '      shiftDown(in.childPointers, 1);', '    } else if (in.leftSibling != null && in.leftSibling.isMergeable()) {', '    } else if (in.rightSibling != null && in.rightSibling.isMergeable()) {', '      sibling = in.rightSibling;', '      sibling.keys[sibling.degree - 1] = parent.keys[parent.degree - 2];', '      Arrays.sort(sibling.keys, 0, sibling.degree);', '      parent.keys[parent.degree - 2] = null;', '      for (int i = 0; i < in.childPointers.length; i++) {', '        if (in.childPointers[i] != null) {', '          sibling.prependChildPointer(in.childPointers[i]);', '          in.childPointers[i].parent = sibling;', '      sibling.leftSibling = in.leftSibling;', '    if (parent != null && parent.isDeficient()) {', '  private int linearNullSearch(DictionaryPair[] dps) {', '    for (int i = 0; i < dps.length; i++) {', '  private int linearNullSearch(Node[] pointers) {', '    for (int i = 0; i < pointers.length; i++) {', '      if (pointers[i] == null) {', '  private void shiftDown(Node[] pointers, int amount) {', '    Node[] newPointers = new Node[this.m + 1];', '    for (int i = amount; i < pointers.length; i++) {', '      newPointers[i - amount] = pointers[i];', '  private void sortDictionary(DictionaryPair[] dictionary) {', '    Arrays.sort(dictionary, new Comparator<DictionaryPair>() {', '      public int compare(DictionaryPair o1, DictionaryPair o2) {', '        if (o1 == null && o2 == null) {', '        return o1.compareTo(o2);', '  private Node[] splitChildPointers(InternalNode in, int split) {', '    Node[] pointers = in.childPointers;', '    Node[] halfPointers = new Node[this.m + 1];', '    for (int i = split + 1; i < pointers.length; i++) {', '      halfPointers[i - split - 1] = pointers[i];', '  private DictionaryPair[] splitDictionary(LeafNode ln, int split) {', '    DictionaryPair[] dictionary = ln.dictionary;', '    DictionaryPair[] halfDict = new DictionaryPair[this.m];', '    for (int i = split; i < dictionary.length; i++) {', '      halfDict[i - split] = dictionary[i];', '  private void splitInternalNode(InternalNode in) {', '    InternalNode parent = in.parent;', '    int midpoint = getMidpoint();', '    int newParentKey = in.keys[midpoint];', '    Integer[] halfKeys = splitKeys(in.keys, midpoint);', '    Node[] halfPointers = splitChildPointers(in, midpoint);', '    in.degree = linearNullSearch(in.childPointers);', '    InternalNode sibling = new InternalNode(this.m, halfKeys, halfPointers);', '    for (Node pointer : halfPointers) {', '        pointer.parent = sibling;', '    sibling.rightSibling = in.rightSibling;', '    if (sibling.rightSibling != null) {', '      sibling.rightSibling.leftSibling = sibling;', '      Integer[] keys = new Integer[this.m];', '      InternalNode newRoot = new InternalNode(this.m, keys);', '      newRoot.appendChildPointer(in);', '      newRoot.appendChildPointer(sibling);', '      parent.keys[parent.degree - 1] = newParentKey;', '      Arrays.sort(parent.keys, 0, parent.degree);', '      int pointerIndex = parent.findIndexOfPointer(in) + 1;', '      parent.insertChildPointer(sibling, pointerIndex);', '  private Integer[] splitKeys(Integer[] keys, int split) {', '    Integer[] halfKeys = new Integer[this.m];', '    for (int i = split + 1; i < keys.length; i++) {', '      halfKeys[i - split - 1] = keys[i];', '  public void insert(int key, double value) {', '      LeafNode ln = new LeafNode(this.m, new DictionaryPair(key, value));', '      LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '      if (!ln.insert(new DictionaryPair(key, value))) {', '        ln.dictionary[ln.numPairs] = new DictionaryPair(key, value);', '        sortDictionary(ln.dictionary);', '        int midpoint = getMidpoint();', '        DictionaryPair[] halfDict = splitDictionary(ln, midpoint);', '        if (ln.parent == null) {', '          Integer[] parent_keys = new Integer[this.m];', '          parent_keys[0] = halfDict[0].key;', '          InternalNode parent = new InternalNode(this.m, parent_keys);', '          parent.appendChildPointer(ln);', '          int newParentKey = halfDict[0].key;', '          ln.parent.keys[ln.parent.degree - 1] = newParentKey;', '          Arrays.sort(ln.parent.keys, 0, ln.parent.degree);', '        LeafNode newLeafNode = new LeafNode(this.m, halfDict, ln.parent);', '        int pointerIndex = ln.parent.findIndexOfPointer(ln) + 1;', '        ln.parent.insertChildPointer(newLeafNode, pointerIndex);', '        newLeafNode.rightSibling = ln.rightSibling;', '        if (newLeafNode.rightSibling != null) {', '          newLeafNode.rightSibling.leftSibling = newLeafNode;', '        ln.rightSibling = newLeafNode;', '        newLeafNode.leftSibling = ln;', '        if (this.root == null) {', '          this.root = ln.parent;', '          InternalNode in = ln.parent;', '            if (in.isOverfull()) {', '              splitInternalNode(in);', '  public Double search(int key) {', '    LeafNode ln = (this.root == null) ? this.firstLeaf : findLeafNode(key);', '    DictionaryPair[] dps = ln.dictionary;', '    int index = binarySearch(dps, ln.numPairs, key);', '  public ArrayList<Double> search(int lowerBound, int upperBound) {', '    ArrayList<Double> values = new ArrayList<Double>();', '    LeafNode currNode = this.firstLeaf;', '      DictionaryPair dps[] = currNode.dictionary;', '      for (DictionaryPair dp : dps) {', '        if (lowerBound <= dp.key && dp.key <= upperBound) {', '      currNode = currNode.rightSibling;', '  private class InternalNode extends Node {', '    private void appendChildPointer(Node pointer) {', '      this.childPointers[degree] = pointer;', '    private int findIndexOfPointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '    private void insertChildPointer(Node pointer, int index) {', '      for (int i = degree - 1; i >= index; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[index] = pointer;', '    private boolean isDeficient() {', '      return this.degree < this.minDegree;', '    private boolean isLendable() {', '      return this.degree > this.minDegree;', '    private boolean isMergeable() {', '      return this.degree == this.minDegree;', '    private boolean isOverfull() {', '      return this.degree == maxDegree + 1;', '    private void prependChildPointer(Node pointer) {', '      for (int i = degree - 1; i >= 0; i--) {', '        childPointers[i + 1] = childPointers[i];', '      this.childPointers[0] = pointer;', '    private void removeKey(int index) {', '    private void removePointer(int index) {', '      this.childPointers[index] = null;', '    private void removePointer(Node pointer) {', '      for (int i = 0; i < childPointers.length; i++) {', '        if (childPointers[i] == pointer) {', '          this.childPointers[i] = null;', '    private InternalNode(int m, Integer[] keys) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.childPointers = new Node[this.maxDegree + 1];', '    private InternalNode(int m, Integer[] keys, Node[] pointers) {', '      this.minDegree = (int) Math.ceil(m / 2.0);', '      this.degree = linearNullSearch(pointers);', '      this.childPointers = pointers;', '  public class LeafNode extends Node {', '    DictionaryPair[] dictionary;', '    public void delete(int index) {', '      this.dictionary[index] = null;', '    public boolean insert(DictionaryPair dp) {', '        this.dictionary[numPairs] = dp;', '        Arrays.sort(this.dictionary, 0, numPairs);', '    public boolean isDeficient() {', '      return numPairs < minNumPairs;', '      return numPairs == maxNumPairs;', '    public boolean isLendable() {', '      return numPairs > minNumPairs;', '    public boolean isMergeable() {', '      return numPairs == minNumPairs;', '    public LeafNode(int m, DictionaryPair dp) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.dictionary = new DictionaryPair[m];', '    public LeafNode(int m, DictionaryPair[] dps, InternalNode parent) {', '      this.minNumPairs = (int) (Math.ceil(m / 2) - 1);', '      this.numPairs = linearNullSearch(dps);', '  public class DictionaryPair implements Comparable<DictionaryPair> {', '    public DictionaryPair(int key, double value) {', '    public int compareTo(DictionaryPair o) {', '  public static void main(String[] args) {', '    if (bpt.search(15) != null) {', '      System.out.println(""Found"");', '      System.out.println(""Not Found"");', 'int pathToLeaves(node *const root, node *child);', 'void printLeaves(node *const root);', 'void printTree(node *const root);', 'void findAndPrint(node *const root, int key, bool verbose);', 'void findAndPrintRange(node *const root, int range1, int range2, bool verbose);', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]);', 'node *findLeaf(node *const root, int key, bool verbose);', 'record *find(node *root, int key, bool verbose, node **leaf_out);', 'int getLeftIndex(node *parent, node *left);', 'node *insertIntoLeaf(node *leaf, int key, record *pointer);', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key,', '                   record *pointer);', 'node *insertIntoNode(node *root, node *parent,', '           int left_index, int key, node *right);', 'node *insertIntoNodeAfterSplitting(node *root, node *parent,', '                   int left_index,', '                   int key, node *right);', 'node *insertIntoParent(node *root, node *left, int key, node *right);', 'node *insertIntoNewRoot(node *left, int key, node *right);', 'node *startNewTree(int key, record *pointer);', 'node *insert(node *root, int key, int value);', 'void printLeaves(node *const root) {', '    for (i = 0; i < c->num_keys; i++) {', '        printf(""%p "", c->pointers[i]);', '      printf(""%d "", c->keys[i]);', '      printf(""%p "", c->pointers[order - 1]);', '    if (c->pointers[order - 1] != NULL) {', '      c = c->pointers[order - 1];', 'int pathToLeaves(node *const root, node *child) {', 'void printTree(node *const root) {', '    if (n->parent != NULL && n == n->parent->pointers[0]) {', '      new_rank = pathToLeaves(root, n);', '    for (i = 0; i < n->num_keys; i++) {', '        printf(""%p "", n->pointers[i]);', '      printf(""%d "", n->keys[i]);', '      for (i = 0; i <= n->num_keys; i++)', '        enqueue(n->pointers[i]);', '        printf(""%p "", n->pointers[order - 1]);', '        printf(""%p "", n->pointers[n->num_keys]);', 'void findAndPrint(node *const root, int key, bool verbose) {', '  record *r = find(root, key, verbose, NULL);', '    printf(""Record not found under key %d.\\n"", key);', '    printf(""Record at %p -- key %d, value %d.\\n"",', 'void findAndPrintRange(node *const root, int key_start, int key_end,', '  int array_size = key_end - key_start + 1;', '  int returned_keys[array_size];', '  void *returned_pointers[array_size];', '  int num_found = findRange(root, key_start, key_end, verbose,', '                returned_keys, returned_pointers);', '    for (i = 0; i < num_found; i++)', '      printf(""Key: %d   Location: %p  Value: %d\\n"",', '           returned_pointers[i],', '            returned_pointers[i])', 'int findRange(node *const root, int key_start, int key_end, bool verbose,', '        int returned_keys[], void *returned_pointers[]) {', '  node *n = findLeaf(root, key_start, verbose);', '  for (i = 0; i < n->num_keys && n->keys[i] < key_start; i++)', '    for (; i < n->num_keys && n->keys[i] <= key_end; i++) {', '      returned_keys[num_found] = n->keys[i];', '      returned_pointers[num_found] = n->pointers[i];', 'node *findLeaf(node *const root, int key, bool verbose) {', '      for (i = 0; i < c->num_keys - 1; i++)', '        printf(""%d "", c->keys[i]);', '      printf(""%d] "", c->keys[i]);', '    for (i = 0; i < c->num_keys - 1; i++)', '      printf(""%d "", c->keys[i]);', '    printf(""%d] ->\\n"", c->keys[i]);', 'record *find(node *root, int key, bool verbose, node **leaf_out) {', '  leaf = findLeaf(root, key, verbose);', '  for (i = 0; i < leaf->num_keys; i++)', '    return (record *)leaf->pointers[i];', '  record *new_record = (record *)malloc(sizeof(record));', '  new_node = malloc(sizeof(node));', '  new_node->keys = malloc((order - 1) * sizeof(int));', '    perror(""New node keys array."");', '  new_node->pointers = malloc(order * sizeof(void *));', '  if (new_node->pointers == NULL) {', '    perror(""New node pointers array."");', 'int getLeftIndex(node *parent, node *left) {', '  while (left_index <= parent->num_keys &&', '       parent->pointers[left_index] != left)', 'node *insertIntoLeaf(node *leaf, int key, record *pointer) {', '  while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)', '  for (i = leaf->num_keys; i > insertion_point; i--) {', '    leaf->keys[i] = leaf->keys[i - 1];', '    leaf->pointers[i] = leaf->pointers[i - 1];', '  leaf->keys[insertion_point] = key;', '  leaf->pointers[insertion_point] = pointer;', 'node *insertIntoLeafAfterSplitting(node *root, node *leaf, int key, record *pointer) {', '  int insertion_index, split, new_key, i, j;', '  temp_keys = malloc(order * sizeof(int));', '    perror(""Temporary keys array."");', '  temp_pointers = malloc(order * sizeof(void *));', '    perror(""Temporary pointers array."");', '  while (insertion_index < order - 1 && leaf->keys[insertion_index] < key)', '  for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {', '    temp_keys[j] = leaf->keys[i];', '    temp_pointers[j] = leaf->pointers[i];', '  temp_keys[insertion_index] = key;', '  temp_pointers[insertion_index] = pointer;', '    leaf->pointers[i] = temp_pointers[i];', '    leaf->keys[i] = temp_keys[i];', '  for (i = split, j = 0; i < order; i++, j++) {', '    new_leaf->pointers[j] = temp_pointers[i];', '    new_leaf->keys[j] = temp_keys[i];', '  new_leaf->pointers[order - 1] = leaf->pointers[order - 1];', '  leaf->pointers[order - 1] = new_leaf;', '  for (i = leaf->num_keys; i < order - 1; i++)', '  for (i = new_leaf->num_keys; i < order - 1; i++)', '    new_leaf->pointers[i] = NULL;', '  new_leaf->parent = leaf->parent;', '  return insertIntoParent(root, leaf, new_key, new_leaf);', 'node *insertIntoNode(node *root, node *n,', '           int left_index, int key, node *right) {', '  for (i = n->num_keys; i > left_index; i--) {', '    n->pointers[i + 1] = n->pointers[i];', '    n->keys[i] = n->keys[i - 1];', '  n->pointers[left_index + 1] = right;', 'node *insertIntoNodeAfterSplitting(node *root, node *old_node, int left_index,', '                   int key, node *right) {', '  temp_pointers = malloc((order + 1) * sizeof(node *));', '  temp_keys = malloc(order * sizeof(int));', '  for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {', '    temp_pointers[j] = old_node->pointers[i];', '  for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {', '    temp_keys[j] = old_node->keys[i];', '  temp_pointers[left_index + 1] = right;', '  for (i = 0; i < split - 1; i++) {', '    old_node->pointers[i] = temp_pointers[i];', '    old_node->keys[i] = temp_keys[i];', '  old_node->pointers[i] = temp_pointers[i];', '  k_prime = temp_keys[split - 1];', '  for (++i, j = 0; i < order; i++, j++) {', '    new_node->pointers[j] = temp_pointers[i];', '    new_node->keys[j] = temp_keys[i];', '  new_node->pointers[j] = temp_pointers[i];', '  new_node->parent = old_node->parent;', '  for (i = 0; i <= new_node->num_keys; i++) {', '    child = new_node->pointers[i];', '  return insertIntoParent(root, old_node, k_prime, new_node);', 'node *insertIntoParent(node *root, node *left, int key, node *right) {', '    return insertIntoNewRoot(left, key, right);', '  left_index = getLeftIndex(parent, left);', '  if (parent->num_keys < order - 1)', '    return insertIntoNode(root, parent, left_index, key, right);', '  return insertIntoNodeAfterSplitting(root, parent, left_index, key, right);', 'node *insertIntoNewRoot(node *left, int key, node *right) {', 'node *startNewTree(int key, record *pointer) {', '  root->pointers[order - 1] = NULL;', 'node *insert(node *root, int key, int value) {', '  record *record_pointer = NULL;', '  record_pointer = find(root, key, false, NULL);', '    record_pointer->value = value;', '  record_pointer = makeRecord(value);', '    return startNewTree(key, record_pointer);', '  leaf = findLeaf(root, key, false);', '  if (leaf->num_keys < order - 1) {', '    leaf = insertIntoLeaf(leaf, key, record_pointer);', '  return insertIntoLeafAfterSplitting(root, leaf, key, record_pointer);', ""  findAndPrint(root, 15, instruction = 'a');"", 'int path_to_root(node *const root, node *child);', 'void print_leaves(node *const root);', 'void print_tree(node *const root);', 'void find_and_print(node *const root, int key, bool verbose);', 'void find_and_print_range(node *const root, int range1, int range2, bool verbose);', 'int find_range(node *const root, int key_start, int key_end, bool verbose,', '         int returned_keys[], void *returned_pointers[]);', 'node *find_leaf(node *const root, int key, bool verbose);', 'record *find(node *root, int key, bool verbose, node **leaf_out);', 'int get_left_index(node *parent, node *left);', 'node *insert_into_leaf(node *leaf, int key, record *pointer);', 'node *insert_into_leaf_after_splitting(node *root, node *leaf, int key,', '                     record *pointer);', 'node *insert_into_node(node *root, node *parent,', '             int left_index, int key, node *right);', 'node *insert_into_node_after_splitting(node *root, node *parent,', '                     int left_index,', '                     int key, node *right);', 'node *insert_into_parent(node *root, node *left, int key, node *right);', 'node *insert_into_new_root(node *left, int key, node *right);', 'node *start_new_tree(int key, record *pointer);', 'node *insert(node *root, int key, int value);', 'int get_neighbor_index(node *n);', 'node *coalesce_nodes(node *root, node *n, node *neighbor,', '           int neighbor_index, int k_prime);', 'node *redistribute_nodes(node *root, node *n, node *neighbor,', '             int neighbor_index,', '             int k_prime_index, int k_prime);', 'node *delete_entry(node *root, node *n, int key, void *pointer);', 'node *delete (node *root, int key);', 'void print_leaves(node *const root) {', '    for (i = 0; i < c->num_keys; i++) {', '        printf(""%p "", c->pointers[i]);', '      printf(""%d "", c->keys[i]);', '      printf(""%p "", c->pointers[order - 1]);', '    if (c->pointers[order - 1] != NULL) {', '      c = c->pointers[order - 1];', 'int path_to_root(node *const root, node *child) {', 'void print_tree(node *const root) {', '    if (n->parent != NULL && n == n->parent->pointers[0]) {', '      new_rank = path_to_root(root, n);', '    for (i = 0; i < n->num_keys; i++) {', '        printf(""%p "", n->pointers[i]);', '      printf(""%d "", n->keys[i]);', '      for (i = 0; i <= n->num_keys; i++)', '        enqueue(n->pointers[i]);', '        printf(""%p "", n->pointers[order - 1]);', '        printf(""%p "", n->pointers[n->num_keys]);', 'void find_and_print(node *const root, int key, bool verbose) {', '  record *r = find(root, key, verbose, NULL);', '    printf(""Record not found under key %d.\\n"", key);', '    printf(""Record at %p -- key %d, value %d.\\n"",', 'void find_and_print_range(node *const root, int key_start, int key_end,', '  int array_size = key_end - key_start + 1;', '  int returned_keys[array_size];', '  void *returned_pointers[array_size];', '  int num_found = find_range(root, key_start, key_end, verbose,', '                 returned_keys, returned_pointers);', '    for (i = 0; i < num_found; i++)', '      printf(""Key: %d   Location: %p  Value: %d\\n"",', '           returned_pointers[i],', '            returned_pointers[i])', 'int find_range(node *const root, int key_start, int key_end, bool verbose,', '         int returned_keys[], void *returned_pointers[]) {', '  node *n = find_leaf(root, key_start, verbose);', '  for (i = 0; i < n->num_keys && n->keys[i] < key_start; i++)', '    for (; i < n->num_keys && n->keys[i] <= key_end; i++) {', '      returned_keys[num_found] = n->keys[i];', '      returned_pointers[num_found] = n->pointers[i];', 'node *find_leaf(node *const root, int key, bool verbose) {', '      for (i = 0; i < c->num_keys - 1; i++)', '        printf(""%d "", c->keys[i]);', '      printf(""%d] "", c->keys[i]);', '    for (i = 0; i < c->num_keys - 1; i++)', '      printf(""%d "", c->keys[i]);', '    printf(""%d] ->\\n"", c->keys[i]);', 'record *find(node *root, int key, bool verbose, node **leaf_out) {', '  leaf = find_leaf(root, key, verbose);', '  for (i = 0; i < leaf->num_keys; i++)', '    return (record *)leaf->pointers[i];', 'record *make_record(int value) {', '  record *new_record = (record *)malloc(sizeof(record));', '  new_node = malloc(sizeof(node));', '  new_node->keys = malloc((order - 1) * sizeof(int));', '    perror(""New node keys array."");', '  new_node->pointers = malloc(order * sizeof(void *));', '  if (new_node->pointers == NULL) {', '    perror(""New node pointers array."");', 'int get_left_index(node *parent, node *left) {', '  while (left_index <= parent->num_keys &&', '       parent->pointers[left_index] != left)', 'node *insert_into_leaf(node *leaf, int key, record *pointer) {', '  while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)', '  for (i = leaf->num_keys; i > insertion_point; i--) {', '    leaf->keys[i] = leaf->keys[i - 1];', '    leaf->pointers[i] = leaf->pointers[i - 1];', '  leaf->keys[insertion_point] = key;', '  leaf->pointers[insertion_point] = pointer;', 'node *insert_into_leaf_after_splitting(node *root, node *leaf, int key, record *pointer) {', '  int insertion_index, split, new_key, i, j;', '  temp_keys = malloc(order * sizeof(int));', '    perror(""Temporary keys array."");', '  temp_pointers = malloc(order * sizeof(void *));', '    perror(""Temporary pointers array."");', '  while (insertion_index < order - 1 && leaf->keys[insertion_index] < key)', '  for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {', '    temp_keys[j] = leaf->keys[i];', '    temp_pointers[j] = leaf->pointers[i];', '  temp_keys[insertion_index] = key;', '  temp_pointers[insertion_index] = pointer;', '    leaf->pointers[i] = temp_pointers[i];', '    leaf->keys[i] = temp_keys[i];', '  for (i = split, j = 0; i < order; i++, j++) {', '    new_leaf->pointers[j] = temp_pointers[i];', '    new_leaf->keys[j] = temp_keys[i];', '  new_leaf->pointers[order - 1] = leaf->pointers[order - 1];', '  leaf->pointers[order - 1] = new_leaf;', '  for (i = leaf->num_keys; i < order - 1; i++)', '  for (i = new_leaf->num_keys; i < order - 1; i++)', '    new_leaf->pointers[i] = NULL;', '  new_leaf->parent = leaf->parent;', '  return insert_into_parent(root, leaf, new_key, new_leaf);', 'node *insert_into_node(node *root, node *n,', '             int left_index, int key, node *right) {', '  for (i = n->num_keys; i > left_index; i--) {', '    n->pointers[i + 1] = n->pointers[i];', '    n->keys[i] = n->keys[i - 1];', '  n->pointers[left_index + 1] = right;', 'node *insert_into_node_after_splitting(node *root, node *old_node, int left_index,', '                     int key, node *right) {', '  temp_pointers = malloc((order + 1) * sizeof(node *));', '    perror(""Temporary pointers array for splitting nodes."");', '  temp_keys = malloc(order * sizeof(int));', '    perror(""Temporary keys array for splitting nodes."");', '  for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {', '    temp_pointers[j] = old_node->pointers[i];', '  for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {', '    temp_keys[j] = old_node->keys[i];', '  temp_pointers[left_index + 1] = right;', '  for (i = 0; i < split - 1; i++) {', '    old_node->pointers[i] = temp_pointers[i];', '    old_node->keys[i] = temp_keys[i];', '  old_node->pointers[i] = temp_pointers[i];', '  k_prime = temp_keys[split - 1];', '  for (++i, j = 0; i < order; i++, j++) {', '    new_node->pointers[j] = temp_pointers[i];', '    new_node->keys[j] = temp_keys[i];', '  new_node->pointers[j] = temp_pointers[i];', '  new_node->parent = old_node->parent;', '  for (i = 0; i <= new_node->num_keys; i++) {', '    child = new_node->pointers[i];', '  return insert_into_parent(root, old_node, k_prime, new_node);', 'node *insert_into_parent(node *root, node *left, int key, node *right) {', '    return insert_into_new_root(left, key, right);', '  left_index = get_left_index(parent, left);', '  if (parent->num_keys < order - 1)', '    return insert_into_node(root, parent, left_index, key, right);', '  return insert_into_node_after_splitting(root, parent, left_index, key, right);', 'node *insert_into_new_root(node *left, int key, node *right) {', 'node *start_new_tree(int key, record *pointer) {', '  root->pointers[order - 1] = NULL;', 'node *insert(node *root, int key, int value) {', '  record *record_pointer = NULL;', '  record_pointer = find(root, key, false, NULL);', '    record_pointer->value = value;', '  record_pointer = make_record(value);', '    return start_new_tree(key, record_pointer);', '  leaf = find_leaf(root, key, false);', '  if (leaf->num_keys < order - 1) {', '    leaf = insert_into_leaf(leaf, key, record_pointer);', '  return insert_into_leaf_after_splitting(root, leaf, key, record_pointer);', 'int get_neighbor_index(node *n) {', '  for (i = 0; i <= n->parent->num_keys; i++)', '    if (n->parent->pointers[i] == n)', '  printf(""Search for nonexistent pointer to node in parent.\\n"");', '  printf(""Node:  %#lx\\n"", (unsigned long)n);', 'node *remove_entry_from_node(node *n, int key, node *pointer) {', '  for (++i; i < n->num_keys; i++)', '    n->keys[i - 1] = n->keys[i];', '  num_pointers = n->is_leaf ? n->num_keys : n->num_keys + 1;', '  while (n->pointers[i] != pointer)', '  for (++i; i < num_pointers; i++)', '    n->pointers[i - 1] = n->pointers[i];', '    for (i = n->num_keys; i < order - 1; i++)', '    for (i = n->num_keys + 1; i < order; i++)', '    new_root = root->pointers[0];', 'node *coalesce_nodes(node *root, node *n, node *neighbor, int neighbor_index, int k_prime) {', '  int i, j, neighbor_insertion_index, n_end;', '  neighbor_insertion_index = neighbor->num_keys;', '    neighbor->keys[neighbor_insertion_index] = k_prime;', '    for (i = neighbor_insertion_index + 1, j = 0; j < n_end; i++, j++) {', '      neighbor->keys[i] = n->keys[j];', '      neighbor->pointers[i] = n->pointers[j];', '    neighbor->pointers[i] = n->pointers[j];', '    for (i = 0; i < neighbor->num_keys + 1; i++) {', '      tmp = (node *)neighbor->pointers[i];', '    for (i = neighbor_insertion_index, j = 0; j < n->num_keys; i++, j++) {', '      neighbor->keys[i] = n->keys[j];', '      neighbor->pointers[i] = n->pointers[j];', '    neighbor->pointers[order - 1] = n->pointers[order - 1];', '  root = delete_entry(root, n->parent, k_prime, n);', 'node *redistribute_nodes(node *root, node *n, node *neighbor, int neighbor_index,', '             int k_prime_index, int k_prime) {', '      n->pointers[n->num_keys + 1] = n->pointers[n->num_keys];', '    for (i = n->num_keys; i > 0; i--) {', '      n->keys[i] = n->keys[i - 1];', '      n->pointers[i] = n->pointers[i - 1];', '      n->pointers[0] = neighbor->pointers[neighbor->num_keys];', '      tmp = (node *)n->pointers[0];', '      neighbor->pointers[neighbor->num_keys] = NULL;', '      n->parent->keys[k_prime_index] = neighbor->keys[neighbor->num_keys - 1];', '      n->pointers[0] = neighbor->pointers[neighbor->num_keys - 1];', '      neighbor->pointers[neighbor->num_keys - 1] = NULL;', '      n->keys[0] = neighbor->keys[neighbor->num_keys - 1];', '      n->parent->keys[k_prime_index] = n->keys[0];', '      n->keys[n->num_keys] = neighbor->keys[0];', '      n->pointers[n->num_keys] = neighbor->pointers[0];', '      n->parent->keys[k_prime_index] = neighbor->keys[1];', '      n->keys[n->num_keys] = k_prime;', '      n->pointers[n->num_keys + 1] = neighbor->pointers[0];', '      tmp = (node *)n->pointers[n->num_keys + 1];', '      n->parent->keys[k_prime_index] = neighbor->keys[0];', '    for (i = 0; i < neighbor->num_keys - 1; i++) {', '      neighbor->keys[i] = neighbor->keys[i + 1];', '      neighbor->pointers[i] = neighbor->pointers[i + 1];', '      neighbor->pointers[i] = neighbor->pointers[i + 1];', 'node *delete_entry(node *root, node *n, int key, void *pointer) {', '  n = remove_entry_from_node(n, key, pointer);', '  min_keys = n->is_leaf ? cut(order - 1) : cut(order) - 1;', '  neighbor_index = get_neighbor_index(n);', '  k_prime_index = neighbor_index == -1 ? 0 : neighbor_index;', '  k_prime = n->parent->keys[k_prime_index];', '  neighbor = neighbor_index == -1 ? n->parent->pointers[1] : n->parent->pointers[neighbor_index];', '  capacity = n->is_leaf ? order : order - 1;', '  if (neighbor->num_keys + n->num_keys < capacity)', '    return coalesce_nodes(root, n, neighbor, neighbor_index, k_prime);', '    return redistribute_nodes(root, n, neighbor, neighbor_index, k_prime_index, k_prime);', 'node *delete (node *root, int key) {', '  key_record = find(root, key, false, &key_leaf);', '  if (key_record != NULL && key_leaf != NULL) {', '    root = delete_entry(root, key_leaf, key, key_record);', 'void destroy_tree_nodes(node *root) {', '    for (i = 0; i < root->num_keys; i++)', '    for (i = 0; i < root->num_keys + 1; i++)', '      destroy_tree_nodes(root->pointers[i]);', 'node *destroy_tree(node *root) {', '  void insertInternal(int, Node *, Node *);', '  void removeInternal(int, Node *, Node *);', '  Node *findParent(Node *, Node *);', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '      while (x > cursor->key[i] && i < cursor->size)', '      for (int j = cursor->size; j > i; j--) {', '        cursor->key[j] = cursor->key[j - 1];', '      cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];', '      cursor->ptr[cursor->size - 1] = NULL;', '      for (int i = 0; i < MAX; i++) {', '        virtualNode[i] = cursor->key[i];', '      while (x > virtualNode[i] && i < MAX)', '      for (int j = MAX + 1; j > i; j--) {', '        virtualNode[j] = virtualNode[j - 1];', '      cursor->size = (MAX + 1) / 2;', '      newLeaf->size = MAX + 1 - (MAX + 1) / 2;', '      cursor->ptr[cursor->size] = newLeaf;', '      newLeaf->ptr[newLeaf->size] = cursor->ptr[MAX];', '      for (i = 0; i < cursor->size; i++) {', '        cursor->key[i] = virtualNode[i];', '      for (i = 0, j = cursor->size; i < newLeaf->size; i++, j++) {', '        newLeaf->key[i] = virtualNode[j];', '        Node *newRoot = new Node;', '        newRoot->key[0] = newLeaf->key[0];', '        newRoot->ptr[0] = cursor;', '        newRoot->ptr[1] = newLeaf;', '        newRoot->IS_LEAF = false;', '        insertInternal(newLeaf->key[0], parent, newLeaf);', 'void BPTree::insertInternal(int x, Node *cursor, Node *child) {', '    while (x > cursor->key[i] && i < cursor->size)', '    for (int j = cursor->size; j > i; j--) {', '      cursor->key[j] = cursor->key[j - 1];', '    for (int j = cursor->size + 1; j > i + 1; j--) {', '      cursor->ptr[j] = cursor->ptr[j - 1];', '    Node *newInternal = new Node;', '    for (int i = 0; i < MAX; i++) {', '      virtualKey[i] = cursor->key[i];', '    for (int i = 0; i < MAX + 1; i++) {', '      virtualPtr[i] = cursor->ptr[i];', '    while (x > virtualKey[i] && i < MAX)', '    for (int j = MAX + 1; j > i; j--) {', '      virtualKey[j] = virtualKey[j - 1];', '    for (int j = MAX + 2; j > i + 1; j--) {', '      virtualPtr[j] = virtualPtr[j - 1];', '    newInternal->IS_LEAF = false;', '    cursor->size = (MAX + 1) / 2;', '    newInternal->size = MAX - (MAX + 1) / 2;', '    for (i = 0, j = cursor->size + 1; i < newInternal->size; i++, j++) {', '      newInternal->key[i] = virtualKey[j];', '    for (i = 0, j = cursor->size + 1; i < newInternal->size + 1; i++, j++) {', '      newInternal->ptr[i] = virtualPtr[j];', '      newRoot->key[0] = cursor->key[cursor->size];', '      newRoot->ptr[1] = newInternal;', '      insertInternal(cursor->key[cursor->size], findParent(root, cursor), newInternal);', 'Node *BPTree::findParent(Node *cursor, Node *child) {', '  if (cursor->IS_LEAF || (cursor->ptr[0])->IS_LEAF) {', '  for (int i = 0; i < cursor->size + 1; i++) {', '    if (cursor->ptr[i] == child) {', '      parent = findParent(cursor->ptr[i], child);', '    int leftSibling, rightSibling;', '    while (cursor->IS_LEAF == false) {', '      for (int i = 0; i < cursor->size; i++) {', '        if (x < cursor->key[i]) {', '          cursor = cursor->ptr[i];', '        if (i == cursor->size - 1) {', '          cursor = cursor->ptr[i + 1];', '    for (pos = 0; pos < cursor->size; pos++) {', '      if (cursor->key[pos] == x) {', '    for (int i = pos; i < cursor->size; i++) {', '      cursor->key[i] = cursor->key[i + 1];', '      for (int i = 0; i < MAX + 1; i++) {', '    cursor->ptr[cursor->size] = cursor->ptr[cursor->size + 1];', '    cursor->ptr[cursor->size + 1] = NULL;', '    if (cursor->size >= (MAX + 1) / 2) {', '      Node *leftNode = parent->ptr[leftSibling];', '      if (leftNode->size >= (MAX + 1) / 2 + 1) {', '        for (int i = cursor->size; i > 0; i--) {', '          cursor->key[i] = cursor->key[i - 1];', '        cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];', '        cursor->ptr[cursor->size - 1] = NULL;', '        cursor->key[0] = leftNode->key[leftNode->size - 1];', '        leftNode->ptr[leftNode->size] = cursor;', '        leftNode->ptr[leftNode->size + 1] = NULL;', '        parent->key[leftSibling] = cursor->key[0];', '    if (rightSibling <= parent->size) {', '      Node *rightNode = parent->ptr[rightSibling];', '      if (rightNode->size >= (MAX + 1) / 2 + 1) {', '        cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];', '        cursor->ptr[cursor->size - 1] = NULL;', '        cursor->key[cursor->size - 1] = rightNode->key[0];', '        rightNode->ptr[rightNode->size] = rightNode->ptr[rightNode->size + 1];', '        rightNode->ptr[rightNode->size + 1] = NULL;', '        for (int i = 0; i < rightNode->size; i++) {', '          rightNode->key[i] = rightNode->key[i + 1];', '        parent->key[rightSibling - 1] = rightNode->key[0];', '      Node *leftNode = parent->ptr[leftSibling];', '      for (int i = leftNode->size, j = 0; j < cursor->size; i++, j++) {', '        leftNode->key[i] = cursor->key[j];', '      leftNode->ptr[leftNode->size] = NULL;', '      leftNode->size += cursor->size;', '      leftNode->ptr[leftNode->size] = cursor->ptr[cursor->size];', '      removeInternal(parent->key[leftSibling], parent, cursor);', '    } else if (rightSibling <= parent->size) {', '      Node *rightNode = parent->ptr[rightSibling];', '      for (int i = cursor->size, j = 0; j < rightNode->size; i++, j++) {', '        cursor->key[i] = rightNode->key[j];', '      cursor->ptr[cursor->size] = NULL;', '      cursor->size += rightNode->size;', '      cursor->ptr[cursor->size] = rightNode->ptr[rightNode->size];', '      cout << ""Merging two leaf nodes\\n"";', '      removeInternal(parent->key[rightSibling - 1], parent, rightNode);', 'void BPTree::removeInternal(int x, Node *cursor, Node *child) {', '      if (cursor->ptr[1] == child) {', '        cout << ""Changed root node\\n"";', '      } else if (cursor->ptr[0] == child) {', '        cout << ""Changed root node\\n"";', '  for (pos = 0; pos < cursor->size; pos++) {', '    if (cursor->key[pos] == x) {', '  for (int i = pos; i < cursor->size; i++) {', '    cursor->key[i] = cursor->key[i + 1];', '  for (pos = 0; pos < cursor->size + 1; pos++) {', '    if (cursor->ptr[pos] == child) {', '  for (int i = pos; i < cursor->size + 1; i++) {', '    cursor->ptr[i] = cursor->ptr[i + 1];', '  if (cursor->size >= (MAX + 1) / 2 - 1) {', '  Node *parent = findParent(root, cursor);', '  int leftSibling, rightSibling;', '  for (pos = 0; pos < parent->size + 1; pos++) {', '    if (parent->ptr[pos] == cursor) {', '    Node *leftNode = parent->ptr[leftSibling];', '    if (leftNode->size >= (MAX + 1) / 2) {', '      for (int i = cursor->size; i > 0; i--) {', '        cursor->key[i] = cursor->key[i - 1];', '      cursor->key[0] = parent->key[leftSibling];', '      parent->key[leftSibling] = leftNode->key[leftNode->size - 1];', '      for (int i = cursor->size + 1; i > 0; i--) {', '        cursor->ptr[i] = cursor->ptr[i - 1];', '      cursor->ptr[0] = leftNode->ptr[leftNode->size];', '  if (rightSibling <= parent->size) {', '    Node *rightNode = parent->ptr[rightSibling];', '    if (rightNode->size >= (MAX + 1) / 2) {', '      cursor->key[cursor->size] = parent->key[pos];', '      parent->key[pos] = rightNode->key[0];', '      for (int i = 0; i < rightNode->size - 1; i++) {', '        rightNode->key[i] = rightNode->key[i + 1];', '      cursor->ptr[cursor->size + 1] = rightNode->ptr[0];', '      for (int i = 0; i < rightNode->size; ++i) {', '        rightNode->ptr[i] = rightNode->ptr[i + 1];', '    Node *leftNode = parent->ptr[leftSibling];', '    leftNode->key[leftNode->size] = parent->key[leftSibling];', '    for (int i = leftNode->size + 1, j = 0; j < cursor->size; j++) {', '      leftNode->key[i] = cursor->key[j];', '    for (int i = leftNode->size + 1, j = 0; j < cursor->size + 1; j++) {', '      leftNode->ptr[i] = cursor->ptr[j];', '    leftNode->size += cursor->size + 1;', '    removeInternal(parent->key[leftSibling], parent, cursor);', '  } else if (rightSibling <= parent->size) {', '    Node *rightNode = parent->ptr[rightSibling];', '    cursor->key[cursor->size] = parent->key[rightSibling - 1];', '    for (int i = cursor->size + 1, j = 0; j < rightNode->size; j++) {', '      cursor->key[i] = rightNode->key[j];', '    for (int i = cursor->size + 1, j = 0; j < rightNode->size + 1; j++) {', '      cursor->ptr[i] = rightNode->ptr[j];', '    cursor->size += rightNode->size + 1;', '    removeInternal(parent->key[rightSibling - 1], parent, rightNode);', 'void BPTree::display(Node *cursor) {', '    for (int i = 0; i < cursor->size; i++) {', '      cout << cursor->key[i] << "" "";', '    if (cursor->IS_LEAF != true) {', '      for (int i = 0; i < cursor->size + 1; i++) {', '        display(cursor->ptr[i]);']",[],[],"['A node can have a maximum of m children. (i.e. 3)|||A node can contain a maximum of m - 1 keys. (i.e. 2)|||A node should have a minimum of ⌈m/2⌉ children. (i.e. 2)|||A node (except root node) should contain a minimum of ⌈m/2⌉ - 1 keys. (i.e. 1)|||There is more than the minimum number of keys in the node. Simply delete the key.|||Deleting 40 from B-tree|||There is an exact minimum number of keys in the node. Delete the key and borrow a key from the immediate sibling. Add the median key of the sibling node to the parent.|||Deleting 5 from B-tree|||If there is more than the minimum number of keys in the node, simply delete the key from the leaf node and delete the key from the internal node as well.|||Fill the empty space in the internal node with the inorder successor.|||Deleting 45 from B-tree|||If there is an exact minimum number of keys in the node, then delete the key and borrow a key from its immediate sibling (through the parent).|||Fill the empty space created in the index (internal node) with the borrowed key.|||Deleting 35 from B-tree|||This case is similar to Case II(1) but here, empty space is generated above the immediate parent node.|||After deleting the key, merge the empty space with its sibling.|||Fill the empty space in the grandparent node with the inorder successor.|||Deleting 25 from B-tree|||']"
34,['Red-Black Tree'],"['In this tutorial, you will learn  what a red-black tree is. Also, you will find working examples of various operations performed on a red-black tree in C, C++, Java and Python.']",[],[],"['Operations on a Red-Black Tree', 'Python, Java and C/C++ Examples', 'Red-Black Tree Applications']","['Rotating the subtrees in a Red-Black Tree', 'Left Rotate', 'Right Rotate', 'Left-Right and Right-Left Rotate', 'Inserting an element into a Red-Black Tree', 'Algorithm to insert a node', 'Algorithm to maintain red-black property after insertion', 'Deleting an element from a Red-Black Tree', 'Algorithm to delete a node', 'Algorithm to maintain Red-Black property after deletion']","['//cdn.programiz.com/sites/tutorial2program/files/red-black-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftrotate-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftrotate-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftrotate-3_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftrotate-4_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightrotate-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightrotate-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightrotate-3_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightrotate-4_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftright-rotate-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/leftright-rotate-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightleft-rotate-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/rightleft-rotate-2_0.png']","['A red-black tree satisfies the following properties:', 'An example of a red-black tree is:', 'Each node has the following attributes:', 'How the red-black tree maintains the property of self-balancing?', 'The red-black color is meant for balancing the tree.', 'Various operations that can be performed on a red-black tree are:', 'There are two types of rotations:', 'Algorithm', 'Why newly inserted nodes are always red in a red-black tree?', 'The extra black can be removed if']","['In rotation operation, the positions of the nodes of a subtree are interchanged.', 'In left-rotation, the arrangement of the nodes on the right is transformed into the arrangements on the left node.', 'In right-rotation, the arrangement of the nodes on the left is transformed into the arrangements on the right node.', 'In left-right rotation, the arrangements are first shifted to the left and then to the right.', 'In right-left rotation, the arrangements are first shifted to the right and then to the left.', 'Following steps are followed for inserting a new element into a red-black tree:', 'This is because inserting a red node does not violate the depth property of a red-black tree.', 'This algorithm is used for maintaining the property of a red-black tree if the insertion of a newNode violates this property.', 'This operation removes a node from the tree. After deleting a node, the red-black property is maintained again.', 'This algorithm is implemented when a black node is deleted because it violates the black depth property of the red-black tree.', ""However, the color attribute of x is not changed rather the extra black is represented in x's pointing to the node."", 'The following algorithm retains the properties of a red-black tree.', 'Please refer to insertion and deletion operations for more explanation with examples.']","['Red-Black tree is a self-balancing binary search tree in which each node contains an extra bit for denoting the color of the node, either red or black.', 'The limitations put on the node colors ensure that any simple path from the root to a leaf is not more than twice as long as any other such path. It helps in maintaining the self-balancing property of the red-black tree.', 'Rotation operation is used for maintaining the properties of a red-black tree when they are violated by other operations such as insertion and deletion.', 'While inserting a new node, the new node is always inserted as a RED node. After insertion of a new node, if the tree is violating the properties of the red-black tree then, we do the following operations.', 'If you attach a red node to a red node, then the rule is violated but it is easier to fix this problem than the problem introduced by violating the depth property.', ""This violation is corrected by assuming that node x (which is occupying y's original position) has an extra black. This makes node x neither red nor black. It is either doubly black or black-and-red. This violates the red-black properties.""]","['import sys', '# Node creation', 'class Node():', '    def __init__(self, item):', '        self.item = item', '        self.parent = None', '        self.left = None', '        self.right = None', '        self.color = 1', 'class RedBlackTree():', '    def __init__(self):', '        self.TNULL = Node(0)', '        self.TNULL.color = 0', '        self.TNULL.left = None', '        self.root = self.TNULL', '    # Preorder', '        if node != TNULL:', '    # Inorder', '        if node != TNULL:', '    # Postorder', '        if node != TNULL:', '    # Search the tree', '            return node', '        if key < node.item:', '    def delete_fix(self, x):', '                else:', '            else:', '                else:', '        x.color = 0', '        if u.parent == None:', '            self.root = v', '            u.parent.left = v', '        else:', '            u.parent.right = v', '        v.parent = u.parent', '    # Node deletion', '        z = self.TNULL', '                z = node', '            else:', '        if z == self.TNULL:', '            return', '        y = z', '            x = z.right', '            x = z.left', '        else:', '            x = y.right', '            if y.parent == z:', '                x.parent = y', '            else:', '            y.left = z.left', '            y.left.parent = y', '            y.color = z.color', '            self.delete_fix(x)', '    def fix_insert(self, k):', '                else:', '            else:', '                else:', '            if k == self.root:', '                break', '        self.root.color = 0', '    # Printing the tree', '        if node != self.TNULL:', '            if last:', '            else:', '    def preorder(self):', '    def inorder(self):', '    def postorder(self):', '    def searchTree(self, k):', '    def minimum(self, node):', '            node = node.left', '        return node', '    def maximum(self, node):', '            node = node.right', '        return node', '    def successor(self, x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def predecessor(self,  x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def left_rotate(self, x):', '        y = x.right', '        x.right = y.left', '            y.left.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.left = y', '        else:', '            x.parent.right = y', '        y.left = x', '        x.parent = y', '    def right_rotate(self, x):', '        y = x.left', '        x.left = y.right', '            y.right.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.right = y', '        else:', '            x.parent.left = y', '        y.right = x', '        x.parent = y', '    def insert(self, key):', '        node = Node(key)', '        node.parent = None', '        node.item = key', '        node.left = self.TNULL', '        node.color = 1', '        y = None', '        x = self.root', '        while x != self.TNULL:', '            y = x', '                x = x.left', '            else:', '                x = x.right', '        node.parent = y', '        if y == None:', '            self.root = node', '            y.left = node', '        else:', '            y.right = node', '            node.color = 0', '            return', '            return', '        self.fix_insert(node)', '    def get_root(self):', '        return self.root', '    def print_tree(self):', 'if __name__ == ""__main__"":', '    bst = RedBlackTree()', '    bst.insert(55)', '    bst.insert(40)', '    bst.insert(65)', '    bst.insert(60)', '    bst.insert(75)', '    bst.insert(57)', '    bst.print_tree()', '    bst.delete_node(40)', '    bst.print_tree()', 'class Node {', '  int data;', '  Node parent;', '  Node left;', '  Node right;', '  int color;', 'public class RedBlackTree {', '  private Node root;', '  private Node TNULL;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node.data) {', '    Node s;', '        s = x.parent.right;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.right;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.left.color = 0;', '            s.color = 1;', '            rightRotate(s);', '          }', '          x.parent.color = 0;', '          s.right.color = 0;', '          x = root;', '        }', '      } else {', '        s = x.parent.left;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.left;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.right.color = 0;', '            s.color = 1;', '            leftRotate(s);', '            s = x.parent.left;', '          }', '          x.parent.color = 0;', '          s.left.color = 0;', '          x = root;', '        }', '    x.color = 0;', '    if (u.parent == null) {', '      root = v;', '      u.parent.left = v;', '    } else {', '      u.parent.right = v;', '    v.parent = u.parent;', '    Node z = TNULL;', '    Node x, y;', '    while (node != TNULL) {', '      if (node.data == key) {', '        z = node;', '      if (node.data <= key) {', '        node = node.right;', '      } else {', '        node = node.left;', '    if (z == TNULL) {', '      return;', '    y = z;', '    if (z.left == TNULL) {', '      x = z.right;', '      x = z.left;', '      rbTransplant(z, z.left);', '    } else {', '      y = minimum(z.right);', '      x = y.right;', '      if (y.parent == z) {', '        x.parent = y;', '      } else {', '        y.right = z.right;', '        y.right.parent = y;', '      rbTransplant(z, y);', '      y.left = z.left;', '      y.left.parent = y;', '      y.color = z.color;', '    if (yOriginalColor == 0) {', '      fixDelete(x);', '    Node u;', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            rightRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      } else {', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            leftRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      if (k == root) {', '        break;', '    root.color = 0;', '    if (root != TNULL) {', '      if (last) {', '        indent += ""   "";', '      } else {', '        indent += ""|  "";', '  public RedBlackTree() {', '    TNULL = new Node();', '    TNULL.color = 0;', '    TNULL.left = null;', '    TNULL.right = null;', '    root = TNULL;', '  public void preorder() {', '    preOrderHelper(this.root);', '  public void inorder() {', '    inOrderHelper(this.root);', '  public void postorder() {', '      node = node.left;', '    return node;', '      node = node.right;', '    return node;', '    if (x.right != TNULL) {', '      return minimum(x.right);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    if (x.left != TNULL) {', '      return maximum(x.left);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    Node y = x.right;', '    x.right = y.left;', '    if (y.left != TNULL) {', '      y.left.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.left = y;', '    } else {', '      x.parent.right = y;', '    y.left = x;', '    x.parent = y;', '    Node y = x.left;', '    x.left = y.right;', '    if (y.right != TNULL) {', '      y.right.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.right = y;', '    } else {', '      x.parent.left = y;', '    y.right = x;', '    x.parent = y;', '    Node node = new Node();', '    node.parent = null;', '    node.data = key;', '    node.left = TNULL;', '    node.right = TNULL;', '    node.color = 1;', '    Node y = null;', '    Node x = this.root;', '    while (x != TNULL) {', '      y = x;', '        x = x.left;', '      } else {', '        x = x.right;', '    node.parent = y;', '    if (y == null) {', '      root = node;', '      y.left = node;', '    } else {', '      y.right = node;', '    if (node.parent == null) {', '      node.color = 0;', '      return;', '      return;', '    fixInsert(node);', '  public Node getRoot() {', '    return this.root;', '  public void printTree() {', '    bst.insert(55);', '    bst.insert(40);', '    bst.insert(65);', '    bst.insert(60);', '    bst.insert(75);', '    bst.insert(57);', '    bst.printTree();', '    bst.deleteNode(40);', '    bst.printTree();', '#include <stdio.h>', '#include <stdlib.h>', 'enum nodeColor {', 'struct rbNode {', '  int data, color;', '  struct rbNode *link[2];', 'struct rbNode *root = NULL;', '  struct rbNode *newnode;', '  newnode->data = data;', '  newnode->color = RED;', '  return newnode;', 'void insertion(int data) {', '  int dir[98], ht = 0, index;', '  ptr = root;', '  if (!root) {', '    root = createNode(data);', '    return;', '  stack[ht] = root;', '  dir[ht++] = 0;', '  while (ptr != NULL) {', '    if (ptr->data == data) {', '      return;', '    stack[ht] = ptr;', '    ptr = ptr->link[index];', '    dir[ht++] = index;', '    if (dir[ht - 2] == 0) {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        xPtr->color = RED;', '        yPtr->color = BLACK;', '        yPtr->link[1] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '    } else {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        yPtr->color = BLACK;', '        xPtr->color = RED;', '        yPtr->link[0] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '  root->color = BLACK;', 'void deletion(int data) {', '  enum nodeColor color;', '  if (!root) {', '    return;', '  ptr = root;', '  while (ptr != NULL) {', '      break;', '    stack[ht] = ptr;', '    dir[ht++] = diff;', '    ptr = ptr->link[diff];', '  if (ptr->link[1] == NULL) {', '      free(ptr);', '      root = NULL;', '    } else if (ptr == root) {', '      root = ptr->link[0];', '      free(ptr);', '    } else {', '  } else {', '    xPtr = ptr->link[1];', '      color = xPtr->color;', '      ptr->color = color;', '      if (ptr == root) {', '        root = xPtr;', '      } else {', '      dir[ht] = 1;', '      stack[ht++] = xPtr;', '    } else {', '      i = ht++;', '      while (1) {', '        dir[ht] = 0;', '        stack[ht++] = xPtr;', '        yPtr = xPtr->link[0];', '        if (!yPtr->link[0])', '          break;', '        xPtr = yPtr;', '      dir[i] = 1;', '      stack[i] = yPtr;', '      if (i > 0)', '      if (ptr == root) {', '        root = yPtr;', '      color = yPtr->color;', '      ptr->color = color;', '  if (ht < 1)', '    return;', '  if (ptr->color == BLACK) {', '    while (1) {', '        pPtr->color = BLACK;', '        break;', '      if (ht < 2)', '        break;', '      if (dir[ht - 2] == 0) {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 0;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      } else {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 1;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      ht--;', '  if (node) {', '  return;', 'int main() {', '  int ch, data;', '  while (1) {', '    scanf(""%d"", &ch);', '    switch (ch) {', '      case 1:', '        scanf(""%d"", &data);', '        insertion(data);', '        break;', '      case 2:', '        scanf(""%d"", &data);', '        deletion(data);', '        break;', '      case 3:', '        printf(""\\n"");', '        break;', '      case 4:', '        exit(0);', '      default:', '        break;', '    printf(""\\n"");', '  return 0;', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  Node *parent;', '  Node *left;', '  Node *right;', '  int color;', 'typedef Node *NodePtr;', 'class RedBlackTree {', '   private:', '  NodePtr root;', '  NodePtr TNULL;', '    node->data = 0;', '    node->parent = parent;', '    node->left = nullptr;', '    node->right = nullptr;', '    node->color = 0;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node->data) {', '  void deleteFix(NodePtr x) {', '    NodePtr s;', '        s = x->parent->right;', '        if (s->color == 1) {', '          s->color = 0;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            rightRotate(s);', '          }', '          s->right->color = 0;', '          x = root;', '        }', '      } else {', '        s = x->parent->left;', '        if (s->color == 1) {', '          s->color = 0;', '          s = x->parent->left;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            leftRotate(s);', '          }', '          s->left->color = 0;', '          x = root;', '        }', '    x->color = 0;', '      root = v;', '      u->parent->left = v;', '    } else {', '      u->parent->right = v;', '    v->parent = u->parent;', '    NodePtr z = TNULL;', '    NodePtr x, y;', '    while (node != TNULL) {', '      if (node->data == key) {', '        z = node;', '      if (node->data <= key) {', '        node = node->right;', '      } else {', '        node = node->left;', '    if (z == TNULL) {', '      return;', '    y = z;', '    if (z->left == TNULL) {', '      x = z->right;', '      x = z->left;', '    } else {', '      y = minimum(z->right);', '      x = y->right;', '      if (y->parent == z) {', '        x->parent = y;', '      } else {', '        y->right = z->right;', '        y->right->parent = y;', '      rbTransplant(z, y);', '      y->left = z->left;', '      y->left->parent = y;', '      y->color = z->color;', '    delete z;', '      deleteFix(x);', '  void insertFix(NodePtr k) {', '    NodePtr u;', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            rightRotate(k);', '          }', '        }', '      } else {', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            leftRotate(k);', '          }', '        }', '      if (k == root) {', '        break;', '    root->color = 0;', '    if (root != TNULL) {', '      cout << indent;', '      if (last) {', '        cout << ""R----"";', '        indent += ""   "";', '      } else {', '        cout << ""L----"";', '        indent += ""|  "";', '   public:', '  RedBlackTree() {', '    TNULL = new Node;', '    TNULL->color = 0;', '    TNULL->left = nullptr;', '    TNULL->right = nullptr;', '    root = TNULL;', '  void preorder() {', '  void inorder() {', '    inOrderHelper(this->root);', '  void postorder() {', '  NodePtr searchTree(int k) {', '      node = node->left;', '    return node;', '      node = node->right;', '    return node;', '    if (x->right != TNULL) {', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '    if (x->left != TNULL) {', '      return maximum(x->left);', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '  void leftRotate(NodePtr x) {', '    NodePtr y = x->right;', '    x->right = y->left;', '    if (y->left != TNULL) {', '      y->left->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->left = y;', '    } else {', '      x->parent->right = y;', '    y->left = x;', '    x->parent = y;', '    NodePtr y = x->left;', '    x->left = y->right;', '    if (y->right != TNULL) {', '      y->right->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->right = y;', '    } else {', '      x->parent->left = y;', '    y->right = x;', '    x->parent = y;', '  void insert(int key) {', '    NodePtr node = new Node;', '    node->parent = nullptr;', '    node->data = key;', '    node->left = TNULL;', '    node->right = TNULL;', '    node->color = 1;', '    NodePtr y = nullptr;', '    NodePtr x = this->root;', '    while (x != TNULL) {', '      y = x;', '        x = x->left;', '      } else {', '        x = x->right;', '    node->parent = y;', '    if (y == nullptr) {', '      root = node;', '      y->left = node;', '    } else {', '      y->right = node;', '      node->color = 0;', '      return;', '      return;', '    insertFix(node);', '  NodePtr getRoot() {', '    return this->root;', '  void deleteNode(int data) {', '  void printTree() {', '    if (root) {', 'int main() {', '  RedBlackTree bst;', '  bst.insert(55);', '  bst.insert(40);', '  bst.insert(65);', '  bst.insert(60);', '  bst.insert(75);', '  bst.insert(57);', '  bst.printTree();', '  cout << endl', '  bst.deleteNode(40);', '  bst.printTree();']","['# Implementing Red-Black Tree in Python', '    def pre_order_helper(self, node):', '            sys.stdout.write(node.item + "" "")', '            self.pre_order_helper(node.left)', '            self.pre_order_helper(node.right)', '    def in_order_helper(self, node):', '            self.in_order_helper(node.left)', '            sys.stdout.write(node.item + "" "")', '            self.in_order_helper(node.right)', '    def post_order_helper(self, node):', '            self.post_order_helper(node.left)', '            self.post_order_helper(node.right)', '            sys.stdout.write(node.item + "" "")', '    def search_tree_helper(self, node, key):', '        if node == TNULL or key == node.item:', '            return self.search_tree_helper(node.left, key)', '        return self.search_tree_helper(node.right, key)', '    # Balancing the tree after deletion', '        while x != self.root and x.color == 0:', '            if x == x.parent.left:', '                s = x.parent.right', '                if s.color == 1:', '                    x.parent.color = 1', '                    self.left_rotate(x.parent)', '                    s = x.parent.right', '                if s.left.color == 0 and s.right.color == 0:', '                    x = x.parent', '                    if s.right.color == 0:', '                        s.left.color = 0', '                        s.color = 1', '                        self.right_rotate(s)', '                        s = x.parent.right', '                    s.color = x.parent.color', '                    x.parent.color = 0', '                    s.right.color = 0', '                    self.left_rotate(x.parent)', '                    x = self.root', '                s = x.parent.left', '                if s.color == 1:', '                    x.parent.color = 1', '                    self.right_rotate(x.parent)', '                    s = x.parent.left', '                if s.right.color == 0 and s.right.color == 0:', '                    x = x.parent', '                    if s.left.color == 0:', '                        s.right.color = 0', '                        s.color = 1', '                        self.left_rotate(s)', '                        s = x.parent.left', '                    s.color = x.parent.color', '                    x.parent.color = 0', '                    s.left.color = 0', '                    self.right_rotate(x.parent)', '                    x = self.root', '    def __rb_transplant(self, u, v):', '        elif u == u.parent.left:', '    def delete_node_helper(self, node, key):', '        while node != self.TNULL:', '            if node.item == key:', '            if node.item <= key:', '                node = node.right', '                node = node.left', '            print(""Cannot find key in the tree"")', '        y_original_color = y.color', '        if z.left == self.TNULL:', '            self.__rb_transplant(z, z.right)', '        elif (z.right == self.TNULL):', '            self.__rb_transplant(z, z.left)', '            y = self.minimum(z.right)', '            y_original_color = y.color', '                self.__rb_transplant(y, y.right)', '                y.right = z.right', '                y.right.parent = y', '            self.__rb_transplant(z, y)', '        if y_original_color == 0:', '    # Balance the tree after insertion', '        while k.parent.color == 1:', '            if k.parent == k.parent.parent.right:', '                u = k.parent.parent.left', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.left:', '                        k = k.parent', '                        self.right_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.left_rotate(k.parent.parent)', '                u = k.parent.parent.right', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.right:', '                        k = k.parent', '                        self.left_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.right_rotate(k.parent.parent)', '    def __print_helper(self, node, indent, last):', '            sys.stdout.write(indent)', '                sys.stdout.write(""R----"")', '                indent += ""     ""', '                sys.stdout.write(""L----"")', '                indent += ""|    ""', '            s_color = ""RED"" if node.color == 1 else ""BLACK""', '            print(str(node.item) + ""("" + s_color + "")"")', '            self.__print_helper(node.left, indent, False)', '            self.__print_helper(node.right, indent, True)', '        self.pre_order_helper(self.root)', '        self.in_order_helper(self.root)', '        self.post_order_helper(self.root)', '        return self.search_tree_helper(self.root, k)', '        while node.left != self.TNULL:', '        while node.right != self.TNULL:', '        if x.right != self.TNULL:', '            return self.minimum(x.right)', '        while y != self.TNULL and x == y.right:', '        if (x.left != self.TNULL):', '            return self.maximum(x.left)', '        while y != self.TNULL and x == y.left:', '        if y.left != self.TNULL:', '        elif x == x.parent.left:', '        if y.right != self.TNULL:', '        elif x == x.parent.right:', '            if node.item < x.item:', '        elif node.item < y.item:', '        if node.parent.parent == None:', '    def delete_node(self, item):', '        self.delete_node_helper(self.root, item)', '        self.__print_helper(self.root, """", True)', '    print(""\\nAfter deleting an element"")', '  private void preOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      preOrderHelper(node.left);', '      preOrderHelper(node.right);', '  private void inOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      inOrderHelper(node.right);', '  private void postOrderHelper(Node node) {', '      postOrderHelper(node.left);', '      postOrderHelper(node.right);', '      System.out.print(node.data + "" "");', '  private Node searchTreeHelper(Node node, int key) {', '    if (node == TNULL || key == node.data) {', '      return searchTreeHelper(node.left, key);', '    return searchTreeHelper(node.right, key);', '  private void fixDelete(Node x) {', '    while (x != root && x.color == 0) {', '        if (s.left.color == 0 && s.right.color == 0) {', '          if (s.right.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '        if (s.right.color == 0 && s.right.color == 0) {', '          if (s.left.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '  private void rbTransplant(Node u, Node v) {', '    } else if (u == u.parent.left) {', '  private void deleteNodeHelper(Node node, int key) {', '      System.out.println(""Couldn\'t find key in the tree"");', '    int yOriginalColor = y.color;', '    } else if (z.right == TNULL) {', '        rbTransplant(y, y.right);', '  private void fixInsert(Node k) {', '    while (k.parent.color == 1) {', '      if (k.parent == k.parent.parent.right) {', '        u = k.parent.parent.left;', '          k.parent.parent.color = 1;', '          if (k == k.parent.left) {', '          k.parent.parent.color = 1;', '          leftRotate(k.parent.parent);', '        u = k.parent.parent.right;', '          k.parent.parent.color = 1;', '          if (k == k.parent.right) {', '          k.parent.parent.color = 1;', '          rightRotate(k.parent.parent);', '  private void printHelper(Node root, String indent, boolean last) {', '        System.out.print(""R----"");', '        System.out.print(""L----"");', '      String sColor = root.color == 1 ? ""RED"" : ""BLACK"";', '      System.out.println(root.data + ""("" + sColor + "")"");', '      printHelper(root.left, indent, false);', '      printHelper(root.right, indent, true);', '  public Node searchTree(int k) {', '    return searchTreeHelper(this.root, k);', '  public Node minimum(Node node) {', '    while (node.left != TNULL) {', '  public Node maximum(Node node) {', '    while (node.right != TNULL) {', '  public Node successor(Node x) {', '    while (y != TNULL && x == y.right) {', '  public Node predecessor(Node x) {', '    while (y != TNULL && x == y.left) {', '  public void leftRotate(Node x) {', '    } else if (x == x.parent.left) {', '  public void rightRotate(Node x) {', '    } else if (x == x.parent.right) {', '    } else if (node.data < y.data) {', '    if (node.parent.parent == null) {', '  public void deleteNode(int data) {', '    deleteNodeHelper(this.root, data);', '    printHelper(this.root, """", true);', '  public static void main(String[] args) {', '    RedBlackTree bst = new RedBlackTree();', '    System.out.println(""\\nAfter deleting:"");', 'struct rbNode *createNode(int data) {', '  newnode = (struct rbNode *)malloc(sizeof(struct rbNode));', '  newnode->link[0] = newnode->link[1] = NULL;', '  struct rbNode *stack[98], *ptr, *newnode, *xPtr, *yPtr;', '      printf(""Duplicates Not Allowed!!\\n"");', '    index = (data - ptr->data) > 0 ? 1 : 0;', '  stack[ht - 1]->link[index] = newnode = createNode(data);', '  while ((ht >= 3) && (stack[ht - 1]->color == RED)) {', '      yPtr = stack[ht - 2]->link[1];', '      if (yPtr != NULL && yPtr->color == RED) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[1] = yPtr->link[0];', '          stack[ht - 2]->link[0] = yPtr;', '        xPtr->link[0] = yPtr->link[1];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '      yPtr = stack[ht - 2]->link[0];', '      if ((yPtr != NULL) && (yPtr->color == RED)) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[0] = yPtr->link[1];', '          stack[ht - 2]->link[1] = yPtr;', '        xPtr->link[1] = yPtr->link[0];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '  struct rbNode *stack[98], *ptr, *xPtr, *yPtr;', '  struct rbNode *pPtr, *qPtr, *rPtr;', '    printf(""Tree not available\\n"");', '    if ((data - ptr->data) == 0)', '    diff = (data - ptr->data) > 0 ? 1 : 0;', '    if ((ptr == root) && (ptr->link[0] == NULL)) {', '      stack[ht - 1]->link[dir[ht - 1]] = ptr->link[0];', '    if (xPtr->link[0] == NULL) {', '      xPtr->link[0] = ptr->link[0];', '        stack[ht - 1]->link[dir[ht - 1]] = xPtr;', '        stack[i - 1]->link[dir[i - 1]] = yPtr;', '      yPtr->link[0] = ptr->link[0];', '      xPtr->link[0] = yPtr->link[1];', '      yPtr->link[1] = ptr->link[1];', '      pPtr = stack[ht - 1]->link[dir[ht - 1]];', '      if (pPtr && pPtr->color == RED) {', '        rPtr = stack[ht - 1]->link[1];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[1];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[1] || rPtr->link[1]->color == BLACK) {', '            qPtr = rPtr->link[0];', '            qPtr->color = BLACK;', '            rPtr->link[0] = qPtr->link[1];', '            qPtr->link[1] = rPtr;', '            rPtr = stack[ht - 1]->link[1] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[1]->color = BLACK;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '        rPtr = stack[ht - 1]->link[0];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[0];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[0] || rPtr->link[0]->color == BLACK) {', '            qPtr = rPtr->link[1];', '            qPtr->color = BLACK;', '            rPtr->link[1] = qPtr->link[0];', '            qPtr->link[0] = rPtr;', '            rPtr = stack[ht - 1]->link[0] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[0]->color = BLACK;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', 'void inorderTraversal(struct rbNode *node) {', '    inorderTraversal(node->link[0]);', '    inorderTraversal(node->link[1]);', '    printf(""1. Insertion\\t2. Deletion\\n"");', '    printf(""3. Traverse\\t4. Exit"");', '    printf(""\\nEnter your choice:"");', '        printf(""Enter the element to insert:"");', '        printf(""Enter the element to delete:"");', '        printf(""Not available\\n"");', '  void initializeNULLNode(NodePtr node, NodePtr parent) {', '  void preOrderHelper(NodePtr node) {', '      cout << node->data << "" "";', '      preOrderHelper(node->left);', '      preOrderHelper(node->right);', '  void inOrderHelper(NodePtr node) {', '      inOrderHelper(node->left);', '      cout << node->data << "" "";', '      inOrderHelper(node->right);', '  void postOrderHelper(NodePtr node) {', '      postOrderHelper(node->left);', '      postOrderHelper(node->right);', '      cout << node->data << "" "";', '  NodePtr searchTreeHelper(NodePtr node, int key) {', '    if (node == TNULL || key == node->data) {', '      return searchTreeHelper(node->left, key);', '    return searchTreeHelper(node->right, key);', '    while (x != root && x->color == 0) {', '      if (x == x->parent->left) {', '          leftRotate(x->parent);', '        if (s->left->color == 0 && s->right->color == 0) {', '          if (s->right->color == 0) {', '            s = x->parent->right;', '          s->color = x->parent->color;', '          leftRotate(x->parent);', '          rightRotate(x->parent);', '        if (s->right->color == 0 && s->right->color == 0) {', '          if (s->left->color == 0) {', '            s->right->color = 0;', '            s = x->parent->left;', '          s->color = x->parent->color;', '          rightRotate(x->parent);', '  void rbTransplant(NodePtr u, NodePtr v) {', '    } else if (u == u->parent->left) {', '  void deleteNodeHelper(NodePtr node, int key) {', '      cout << ""Key not found in the tree"" << endl;', '    int y_original_color = y->color;', '      rbTransplant(z, z->right);', '    } else if (z->right == TNULL) {', '      y_original_color = y->color;', '        rbTransplant(y, y->right);', '    if (y_original_color == 0) {', '    while (k->parent->color == 1) {', '      if (k->parent == k->parent->parent->right) {', '        u = k->parent->parent->left;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->left) {', '          k->parent->parent->color = 1;', '          leftRotate(k->parent->parent);', '        u = k->parent->parent->right;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->right) {', '          k->parent->parent->color = 1;', '          rightRotate(k->parent->parent);', '  void printHelper(NodePtr root, string indent, bool last) {', '      string sColor = root->color ? ""RED"" : ""BLACK"";', '      cout << root->data << ""("" << sColor << "")"" << endl;', '      printHelper(root->left, indent, false);', '      printHelper(root->right, indent, true);', '    postOrderHelper(this->root);', '    return searchTreeHelper(this->root, k);', '  NodePtr minimum(NodePtr node) {', '    while (node->left != TNULL) {', '  NodePtr maximum(NodePtr node) {', '    while (node->right != TNULL) {', '  NodePtr successor(NodePtr x) {', '    while (y != TNULL && x == y->right) {', '  NodePtr predecessor(NodePtr x) {', '    while (y != TNULL && x == y->left) {', '    } else if (x == x->parent->left) {', '    } else if (x == x->parent->right) {', '      if (node->data < x->data) {', '    } else if (node->data < y->data) {', '    if (node->parent == nullptr) {', '    if (node->parent->parent == nullptr) {', '    deleteNodeHelper(this->root, data);', '      printHelper(this->root, """", true);', '     << ""After deleting"" << endl;']",[],[],"['color|||key|||leftChild|||rightChild|||parent (except root node)|||&&&Red/Black Property: Every node is colored, either red or black.|||Root Property: The root is black.|||Leaf Property: Every leaf (NIL) is black.|||Red Property: If a red node has children then, the children are always black.|||Depth Property: For each node, any simple path from this node to any of its descendant leaf has the same black-depth (the number of black nodes).|||Let the initial tree be:|||Initial tree|||If y has a left subtree, assign x as the parent of the left subtree of y.|||Assign x as the parent of the left subtree of y|||If the parent of x is NULL, make y as the root of the tree.|||Else if x is the left child of p, make y as the left child of p.|||Else assign y as the right child of p.|||Change the parent of x to that of y|||Make y as the parent of x.|||Assign y as the parent of x.|||Let the initial tree be:|||Initial Tree|||If x has a right subtree, assign y as the parent of the right subtree of x.|||Assign y as the parent of the right subtree of x|||If the parent of y is NULL, make x as the root of the tree.|||Else if y is the right child of its parent p, make x as the right child of p.|||Else assign x as the left child of p.|||Assign the parent of y as the parent of x|||Make x as the parent of y.|||Assign x as the parent of y|||Do left rotation on x-y.|||Left rotate x-y|||Do right rotation on y-z.|||Right rotate z-y|||Do right rotation on x-y.|||Right rotate x-y|||Do left rotation on z-y.|||Left rotate z-y|||Recolor|||Rotation|||Let y be the leaf (ie. NIL) and x be the root of the tree.|||Check if the tree is empty (ie. whether x is NIL). If yes, insert newNode as a root node and color it black.|||Else, repeat steps following steps until leaf (NIL) is reached.|||Compare newKey with rootKey.|||If newKey is greater than rootKey, traverse through the right subtree.|||Else traverse through the left subtree.||||||Assign the parent of the leaf as a parent of newNode.|||If leafKey is greater than newKey, make newNode as rightChild.|||Else, make newNode as leftChild.|||Assign NULL to the left and rightChild of newNode.|||Assign RED color to newNode.|||Call InsertFix-algorithm to maintain the property of red-black tree if violated.|||Compare newKey with rootKey.|||If newKey is greater than rootKey, traverse through the right subtree.|||Else traverse through the left subtree.|||Do the following while the parent of newNode p is RED.|||If p is the left child of grandParent gP of z, do the following.Case-I:|||If the color of the right child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.Case-II:|||Else if newNode is the right child of p then, assign p to newNode.|||Left-Rotate newNode.Case-III:|||Set color of p as BLACK and color of gP as RED.|||Right-Rotate gP.||||||Else, do the following.|||If the color of the left child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.|||Else if newNode is the left child of p then, assign p to newNode and Right-Rotate newNode.|||Set color of p as BLACK and color of gP as RED.|||Left-Rotate gP.||||||Set the root of the tree as BLACK.|||If the color of the right child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.Case-II:|||Else if newNode is the right child of p then, assign p to newNode.|||Left-Rotate newNode.Case-III:|||Set color of p as BLACK and color of gP as RED.|||Right-Rotate gP.|||If the color of the left child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.|||Else if newNode is the left child of p then, assign p to newNode and Right-Rotate newNode.|||Set color of p as BLACK and color of gP as RED.|||Left-Rotate gP.|||Save the color of nodeToBeDeleted in origrinalColor.|||If the left child of nodeToBeDeleted is NULL|||Assign the right child of nodeToBeDeleted to x.|||Transplant nodeToBeDeleted with x.||||||Else if the right child of nodeToBeDeleted is NULL|||Assign the left child of nodeToBeDeleted into x.|||Transplant nodeToBeDeleted with x.||||||Else|||Assign the minimum of right subtree of noteToBeDeleted into y.|||Save the color of y in originalColor.|||Assign the rightChild of y into x.|||If y is a child of nodeToBeDeleted, then set the parent of x as y.|||Else, transplant y with rightChild of y.|||Transplant nodeToBeDeleted with y.|||Set the color of y with originalColor.||||||If the originalColor is BLACK, call DeleteFix(x).|||Assign the right child of nodeToBeDeleted to x.|||Transplant nodeToBeDeleted with x.|||Assign the left child of nodeToBeDeleted into x.|||Transplant nodeToBeDeleted with x.|||Assign the minimum of right subtree of noteToBeDeleted into y.|||Save the color of y in originalColor.|||Assign the rightChild of y into x.|||If y is a child of nodeToBeDeleted, then set the parent of x as y.|||Else, transplant y with rightChild of y.|||Transplant nodeToBeDeleted with y.|||Set the color of y with originalColor.|||It reaches the root node.|||If x points to a red-black node. In this case, x is colored black.|||Suitable rotations and recoloring are performed.|||Do the following until the x is not the root of the tree and the color of x is BLACK|||If x is the left child of its parent then,|||Assign w to the sibling of x.|||If the right child of parent of x is RED,Case-I:|||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Left-Rotate the parent of x.|||Assign the rightChild of the parent of x to w.||||||If the color of both the right and the leftChild of w is BLACK,Case-II:|||Set the color of w as RED|||Assign the parent of x to x.||||||Else if the color of the rightChild of w is BLACKCase-III:|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Right-Rotate w.|||Assign the rightChild of the parent of x to w.||||||If any of the above cases do not occur, then do the following.Case-IV:|||Set the color of w as the color of the parent of x.|||Set the color of the parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Left-Rotate the parent of x.|||Set x as the root of the tree.|||||||||Else the same as above with right changed to left and vice versa.|||Set the color of x as BLACK.|||Assign w to the sibling of x.|||If the right child of parent of x is RED,Case-I:|||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Left-Rotate the parent of x.|||Assign the rightChild of the parent of x to w.||||||If the color of both the right and the leftChild of w is BLACK,Case-II:|||Set the color of w as RED|||Assign the parent of x to x.||||||Else if the color of the rightChild of w is BLACKCase-III:|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Right-Rotate w.|||Assign the rightChild of the parent of x to w.||||||If any of the above cases do not occur, then do the following.Case-IV:|||Set the color of w as the color of the parent of x.|||Set the color of the parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Left-Rotate the parent of x.|||Set x as the root of the tree.||||||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Left-Rotate the parent of x.|||Assign the rightChild of the parent of x to w.|||Set the color of w as RED|||Assign the parent of x to x.|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Right-Rotate w.|||Assign the rightChild of the parent of x to w.|||Set the color of w as the color of the parent of x.|||Set the color of the parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Left-Rotate the parent of x.|||Set x as the root of the tree.|||To implement finite maps|||To implement Java packages: java.util.TreeMap and java.util.TreeSet|||To implement Standard Template Libraries (STL) in C++: multiset, map, multimap|||In Linux Kernel|||']"
35,['Insertion in a Red-Black Tree'],"['In this tutorial, you will learn how a new node can be inserted into a red-black tree is. Also, you will find working examples of insertions performed on a red-black tree in C, C++, Java and Python.']",[],[],"['Algorithm to Insert a New Node', 'Algorithm to Maintain Red-Black Property After Insertion', 'Python, Java and C/C++ Examples']",[],"['//cdn.programiz.com/sites/tutorial2program/files/newnode-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-1-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-2-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-3-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insert-4-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case1.1-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case1.2-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case2.1-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case-2.2-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case-3.1-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-case-3.2-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-laststep-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/insertfix-final-tree-red-black.png']","['Why newly inserted nodes are always red in a red-black tree?', 'The final tree look like this:']","['Before reading this article, please refer to the article on red-black tree.', 'Following steps are followed for inserting a new element into a red-black tree:', 'This is because inserting a red node does not violate the depth property of a red-black tree.', 'This algorithm is used for maintaining the property of a red-black tree if insertion of a newNode violates this property.']","['Red-Black tree is a self-balancing binary search tree in which each node contains an extra bit for denoting the color of the node, either red or black.', 'While inserting a new node, the new node is always inserted as a RED node. After insertion of a new node, if the tree is violating the properties of the red-black tree then, we do the following operations.', 'If you attach a red node to a red node, then the rule is violated but it is easier to fix this problem than the problem introduced by violating the depth property.']","['import sys', '# Node creation', 'class Node():', '    def __init__(self, item):', '        self.item = item', '        self.parent = None', '        self.left = None', '        self.right = None', '        self.color = 1', 'class RedBlackTree():', '    def __init__(self):', '        self.TNULL = Node(0)', '        self.TNULL.color = 0', '        self.TNULL.left = None', '        self.root = self.TNULL', '    # Preorder', '        if node != TNULL:', '    # Inorder', '        if node != TNULL:', '    # Postorder', '        if node != TNULL:', '    # Search the tree', '            return node', '        if key < node.item:', '    def fix_insert(self, k):', '                else:', '            else:', '                else:', '            if k == self.root:', '                break', '        self.root.color = 0', '    # Printing the tree', '        if node != self.TNULL:', '            if last:', '            else:', '    def preorder(self):', '    def inorder(self):', '    def postorder(self):', '    def searchTree(self, k):', '    def minimum(self, node):', '            node = node.left', '        return node', '    def maximum(self, node):', '            node = node.right', '        return node', '    def successor(self, x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def predecessor(self,  x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def left_rotate(self, x):', '        y = x.right', '        x.right = y.left', '            y.left.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.left = y', '        else:', '            x.parent.right = y', '        y.left = x', '        x.parent = y', '    def right_rotate(self, x):', '        y = x.left', '        x.left = y.right', '            y.right.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.right = y', '        else:', '            x.parent.left = y', '        y.right = x', '        x.parent = y', '    def insert(self, key):', '        node = Node(key)', '        node.parent = None', '        node.item = key', '        node.left = self.TNULL', '        node.color = 1', '        y = None', '        x = self.root', '        while x != self.TNULL:', '            y = x', '                x = x.left', '            else:', '                x = x.right', '        node.parent = y', '        if y == None:', '            self.root = node', '            y.left = node', '        else:', '            y.right = node', '            node.color = 0', '            return', '            return', '        self.fix_insert(node)', '    def get_root(self):', '        return self.root', '    def print_tree(self):', 'if __name__ == ""__main__"":', '    bst = RedBlackTree()', '    bst.insert(55)', '    bst.insert(40)', '    bst.insert(65)', '    bst.insert(60)', '    bst.insert(75)', '    bst.insert(57)', '    bst.print_tree()', 'class Node {', '  int data;', '  Node parent;', '  Node left;', '  Node right;', '  int color;', 'public class RedBlackTree {', '  private Node root;', '  private Node TNULL;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node.data) {', '    Node s;', '        s = x.parent.right;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.right;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.left.color = 0;', '            s.color = 1;', '            rightRotate(s);', '          }', '          x.parent.color = 0;', '          s.right.color = 0;', '          x = root;', '        }', '      } else {', '        s = x.parent.left;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.left;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.right.color = 0;', '            s.color = 1;', '            leftRotate(s);', '            s = x.parent.left;', '          }', '          x.parent.color = 0;', '          s.left.color = 0;', '          x = root;', '        }', '    x.color = 0;', '    if (u.parent == null) {', '      root = v;', '      u.parent.left = v;', '    } else {', '      u.parent.right = v;', '    v.parent = u.parent;', '    Node u;', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            rightRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      } else {', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            leftRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      if (k == root) {', '        break;', '    root.color = 0;', '    if (root != TNULL) {', '      if (last) {', '        indent += ""   "";', '      } else {', '        indent += ""|  "";', '  public RedBlackTree() {', '    TNULL = new Node();', '    TNULL.color = 0;', '    TNULL.left = null;', '    TNULL.right = null;', '    root = TNULL;', '  public void preorder() {', '    preOrderHelper(this.root);', '  public void inorder() {', '    inOrderHelper(this.root);', '  public void postorder() {', '      node = node.left;', '    return node;', '      node = node.right;', '    return node;', '    if (x.right != TNULL) {', '      return minimum(x.right);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    if (x.left != TNULL) {', '      return maximum(x.left);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    Node y = x.right;', '    x.right = y.left;', '    if (y.left != TNULL) {', '      y.left.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.left = y;', '    } else {', '      x.parent.right = y;', '    y.left = x;', '    x.parent = y;', '    Node y = x.left;', '    x.left = y.right;', '    if (y.right != TNULL) {', '      y.right.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.right = y;', '    } else {', '      x.parent.left = y;', '    y.right = x;', '    x.parent = y;', '    Node node = new Node();', '    node.parent = null;', '    node.data = key;', '    node.left = TNULL;', '    node.right = TNULL;', '    node.color = 1;', '    Node y = null;', '    Node x = this.root;', '    while (x != TNULL) {', '      y = x;', '        x = x.left;', '      } else {', '        x = x.right;', '    node.parent = y;', '    if (y == null) {', '      root = node;', '      y.left = node;', '    } else {', '      y.right = node;', '    if (node.parent == null) {', '      node.color = 0;', '      return;', '      return;', '    fixInsert(node);', '  public Node getRoot() {', '    return this.root;', '  public void printTree() {', '    bst.insert(55);', '    bst.insert(40);', '    bst.insert(65);', '    bst.insert(60);', '    bst.insert(75);', '    bst.insert(57);', '    bst.printTree();', '#include <stdio.h>', '#include <stdlib.h>', 'enum nodeColor {', 'struct rbNode {', '  int data, color;', '  struct rbNode *link[2];', 'struct rbNode *root = NULL;', '  struct rbNode *newnode;', '  newnode->data = data;', '  newnode->color = RED;', '  return newnode;', 'void insertion(int data) {', '  int dir[98], ht = 0, index;', '  ptr = root;', '  if (!root) {', '    root = createNode(data);', '    return;', '  stack[ht] = root;', '  dir[ht++] = 0;', '  while (ptr != NULL) {', '    if (ptr->data == data) {', '      return;', '    stack[ht] = ptr;', '    ptr = ptr->link[index];', '    dir[ht++] = index;', '    if (dir[ht - 2] == 0) {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        xPtr->color = RED;', '        yPtr->color = BLACK;', '        yPtr->link[1] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '    } else {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        yPtr->color = BLACK;', '        xPtr->color = RED;', '        yPtr->link[0] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '  root->color = BLACK;', 'void deletion(int data) {', '  enum nodeColor color;', '  if (!root) {', '    return;', '  ptr = root;', '  while (ptr != NULL) {', '      break;', '    stack[ht] = ptr;', '    dir[ht++] = diff;', '    ptr = ptr->link[diff];', '  if (ptr->link[1] == NULL) {', '      free(ptr);', '      root = NULL;', '    } else if (ptr == root) {', '      root = ptr->link[0];', '      free(ptr);', '    } else {', '  } else {', '    xPtr = ptr->link[1];', '      color = xPtr->color;', '      ptr->color = color;', '      if (ptr == root) {', '        root = xPtr;', '      } else {', '      dir[ht] = 1;', '      stack[ht++] = xPtr;', '    } else {', '      i = ht++;', '      while (1) {', '        dir[ht] = 0;', '        stack[ht++] = xPtr;', '        yPtr = xPtr->link[0];', '        if (!yPtr->link[0])', '          break;', '        xPtr = yPtr;', '      dir[i] = 1;', '      stack[i] = yPtr;', '      if (i > 0)', '      if (ptr == root) {', '        root = yPtr;', '      color = yPtr->color;', '      ptr->color = color;', '  if (ht < 1)', '    return;', '  if (ptr->color == BLACK) {', '    while (1) {', '        pPtr->color = BLACK;', '        break;', '      if (ht < 2)', '        break;', '      if (dir[ht - 2] == 0) {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 0;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      } else {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 1;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      ht--;', '  if (node) {', '  return;', 'int main() {', '  int ch, data;', '  while (1) {', '    scanf(""%d"", &ch);', '    switch (ch) {', '      case 1:', '        scanf(""%d"", &data);', '        insertion(data);', '        break;', '      case 2:', '        scanf(""%d"", &data);', '        deletion(data);', '        break;', '      case 3:', '        printf(""\\n"");', '        break;', '      case 4:', '        exit(0);', '      default:', '        break;', '    printf(""\\n"");', '  return 0;', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  Node *parent;', '  Node *left;', '  Node *right;', '  int color;', 'typedef Node *NodePtr;', 'class RedBlackTree {', '   private:', '  NodePtr root;', '  NodePtr TNULL;', '    node->data = 0;', '    node->parent = parent;', '    node->left = nullptr;', '    node->right = nullptr;', '    node->color = 0;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node->data) {', '  void deleteFix(NodePtr x) {', '    NodePtr s;', '        s = x->parent->right;', '        if (s->color == 1) {', '          s->color = 0;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            rightRotate(s);', '          }', '          s->right->color = 0;', '          x = root;', '        }', '      } else {', '        s = x->parent->left;', '        if (s->color == 1) {', '          s->color = 0;', '          s = x->parent->left;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            leftRotate(s);', '          }', '          s->left->color = 0;', '          x = root;', '        }', '    x->color = 0;', '      root = v;', '      u->parent->left = v;', '    } else {', '      u->parent->right = v;', '    v->parent = u->parent;', '    NodePtr z = TNULL;', '    NodePtr x, y;', '    while (node != TNULL) {', '      if (node->data == key) {', '        z = node;', '      if (node->data <= key) {', '        node = node->right;', '      } else {', '        node = node->left;', '    if (z == TNULL) {', '      return;', '    y = z;', '    if (z->left == TNULL) {', '      x = z->right;', '      x = z->left;', '    } else {', '      y = minimum(z->right);', '      x = y->right;', '      if (y->parent == z) {', '        x->parent = y;', '      } else {', '        y->right = z->right;', '        y->right->parent = y;', '      rbTransplant(z, y);', '      y->left = z->left;', '      y->left->parent = y;', '      y->color = z->color;', '    delete z;', '      deleteFix(x);', '  void insertFix(NodePtr k) {', '    NodePtr u;', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            rightRotate(k);', '          }', '        }', '      } else {', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            leftRotate(k);', '          }', '        }', '      if (k == root) {', '        break;', '    root->color = 0;', '    if (root != TNULL) {', '      cout << indent;', '      if (last) {', '        cout << ""R----"";', '        indent += ""   "";', '      } else {', '        cout << ""L----"";', '        indent += ""|  "";', '   public:', '  RedBlackTree() {', '    TNULL = new Node;', '    TNULL->color = 0;', '    TNULL->left = nullptr;', '    TNULL->right = nullptr;', '    root = TNULL;', '  void preorder() {', '  void inorder() {', '    inOrderHelper(this->root);', '  void postorder() {', '  NodePtr searchTree(int k) {', '      node = node->left;', '    return node;', '      node = node->right;', '    return node;', '    if (x->right != TNULL) {', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '    if (x->left != TNULL) {', '      return maximum(x->left);', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '  void leftRotate(NodePtr x) {', '    NodePtr y = x->right;', '    x->right = y->left;', '    if (y->left != TNULL) {', '      y->left->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->left = y;', '    } else {', '      x->parent->right = y;', '    y->left = x;', '    x->parent = y;', '    NodePtr y = x->left;', '    x->left = y->right;', '    if (y->right != TNULL) {', '      y->right->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->right = y;', '    } else {', '      x->parent->left = y;', '    y->right = x;', '    x->parent = y;', '  void insert(int key) {', '    NodePtr node = new Node;', '    node->parent = nullptr;', '    node->data = key;', '    node->left = TNULL;', '    node->right = TNULL;', '    node->color = 1;', '    NodePtr y = nullptr;', '    NodePtr x = this->root;', '    while (x != TNULL) {', '      y = x;', '        x = x->left;', '      } else {', '        x = x->right;', '    node->parent = y;', '    if (y == nullptr) {', '      root = node;', '      y->left = node;', '    } else {', '      y->right = node;', '      node->color = 0;', '      return;', '      return;', '    insertFix(node);', '  NodePtr getRoot() {', '    return this->root;', '  void deleteNode(int data) {', '  void printTree() {', '    if (root) {', 'int main() {', '  RedBlackTree bst;', '  bst.insert(55);', '  bst.insert(40);', '  bst.insert(65);', '  bst.insert(60);', '  bst.insert(75);', '  bst.insert(57);', '  bst.printTree();', '  cout << endl', '  bst.deleteNode(40);', '  bst.printTree();']","['# Implementing Red-Black Tree in Python', '    def pre_order_helper(self, node):', '            sys.stdout.write(node.item + "" "")', '            self.pre_order_helper(node.left)', '            self.pre_order_helper(node.right)', '    def in_order_helper(self, node):', '            self.in_order_helper(node.left)', '            sys.stdout.write(node.item + "" "")', '            self.in_order_helper(node.right)', '    def post_order_helper(self, node):', '            self.post_order_helper(node.left)', '            self.post_order_helper(node.right)', '            sys.stdout.write(node.item + "" "")', '    def search_tree_helper(self, node, key):', '        if node == TNULL or key == node.item:', '            return self.search_tree_helper(node.left, key)', '        return self.search_tree_helper(node.right, key)', '    # Balance the tree after insertion', '        while k.parent.color == 1:', '            if k.parent == k.parent.parent.right:', '                u = k.parent.parent.left', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.left:', '                        k = k.parent', '                        self.right_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.left_rotate(k.parent.parent)', '                u = k.parent.parent.right', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.right:', '                        k = k.parent', '                        self.left_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.right_rotate(k.parent.parent)', '    def __print_helper(self, node, indent, last):', '            sys.stdout.write(indent)', '                sys.stdout.write(""R----"")', '                indent += ""     ""', '                sys.stdout.write(""L----"")', '                indent += ""|    ""', '            s_color = ""RED"" if node.color == 1 else ""BLACK""', '            print(str(node.item) + ""("" + s_color + "")"")', '            self.__print_helper(node.left, indent, False)', '            self.__print_helper(node.right, indent, True)', '        self.pre_order_helper(self.root)', '        self.in_order_helper(self.root)', '        self.post_order_helper(self.root)', '        return self.search_tree_helper(self.root, k)', '        while node.left != self.TNULL:', '        while node.right != self.TNULL:', '        if x.right != self.TNULL:', '            return self.minimum(x.right)', '        while y != self.TNULL and x == y.right:', '        if (x.left != self.TNULL):', '            return self.maximum(x.left)', '        while y != self.TNULL and x == y.left:', '        if y.left != self.TNULL:', '        elif x == x.parent.left:', '        if y.right != self.TNULL:', '        elif x == x.parent.right:', '            if node.item < x.item:', '        elif node.item < y.item:', '        if node.parent.parent == None:', '        self.__print_helper(self.root, """", True)', '  private void preOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      preOrderHelper(node.left);', '      preOrderHelper(node.right);', '  private void inOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      inOrderHelper(node.right);', '  private void postOrderHelper(Node node) {', '      postOrderHelper(node.left);', '      postOrderHelper(node.right);', '      System.out.print(node.data + "" "");', '  private Node searchTreeHelper(Node node, int key) {', '    if (node == TNULL || key == node.data) {', '      return searchTreeHelper(node.left, key);', '    return searchTreeHelper(node.right, key);', '  private void fixDelete(Node x) {', '    while (x != root && x.color == 0) {', '        if (s.left.color == 0 && s.right.color == 0) {', '          if (s.right.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '        if (s.right.color == 0 && s.right.color == 0) {', '          if (s.left.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '  private void rbTransplant(Node u, Node v) {', '    } else if (u == u.parent.left) {', '  private void fixInsert(Node k) {', '    while (k.parent.color == 1) {', '      if (k.parent == k.parent.parent.right) {', '        u = k.parent.parent.left;', '          k.parent.parent.color = 1;', '          if (k == k.parent.left) {', '          k.parent.parent.color = 1;', '          leftRotate(k.parent.parent);', '        u = k.parent.parent.right;', '          k.parent.parent.color = 1;', '          if (k == k.parent.right) {', '          k.parent.parent.color = 1;', '          rightRotate(k.parent.parent);', '  private void printHelper(Node root, String indent, boolean last) {', '        System.out.print(""R----"");', '        System.out.print(""L----"");', '      String sColor = root.color == 1 ? ""RED"" : ""BLACK"";', '      System.out.println(root.data + ""("" + sColor + "")"");', '      printHelper(root.left, indent, false);', '      printHelper(root.right, indent, true);', '  public Node searchTree(int k) {', '    return searchTreeHelper(this.root, k);', '  public Node minimum(Node node) {', '    while (node.left != TNULL) {', '  public Node maximum(Node node) {', '    while (node.right != TNULL) {', '  public Node successor(Node x) {', '    while (y != TNULL && x == y.right) {', '  public Node predecessor(Node x) {', '    while (y != TNULL && x == y.left) {', '  public void leftRotate(Node x) {', '    } else if (x == x.parent.left) {', '  public void rightRotate(Node x) {', '    } else if (x == x.parent.right) {', '    } else if (node.data < y.data) {', '    if (node.parent.parent == null) {', '    printHelper(this.root, """", true);', '  public static void main(String[] args) {', '    RedBlackTree bst = new RedBlackTree();', 'struct rbNode *createNode(int data) {', '  newnode = (struct rbNode *)malloc(sizeof(struct rbNode));', '  newnode->link[0] = newnode->link[1] = NULL;', '  struct rbNode *stack[98], *ptr, *newnode, *xPtr, *yPtr;', '      printf(""Duplicates Not Allowed!!\\n"");', '    index = (data - ptr->data) > 0 ? 1 : 0;', '  stack[ht - 1]->link[index] = newnode = createNode(data);', '  while ((ht >= 3) && (stack[ht - 1]->color == RED)) {', '      yPtr = stack[ht - 2]->link[1];', '      if (yPtr != NULL && yPtr->color == RED) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[1] = yPtr->link[0];', '          stack[ht - 2]->link[0] = yPtr;', '        xPtr->link[0] = yPtr->link[1];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '      yPtr = stack[ht - 2]->link[0];', '      if ((yPtr != NULL) && (yPtr->color == RED)) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[0] = yPtr->link[1];', '          stack[ht - 2]->link[1] = yPtr;', '        xPtr->link[1] = yPtr->link[0];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '  struct rbNode *stack[98], *ptr, *xPtr, *yPtr;', '  struct rbNode *pPtr, *qPtr, *rPtr;', '    printf(""Tree not available\\n"");', '    if ((data - ptr->data) == 0)', '    diff = (data - ptr->data) > 0 ? 1 : 0;', '    if ((ptr == root) && (ptr->link[0] == NULL)) {', '      stack[ht - 1]->link[dir[ht - 1]] = ptr->link[0];', '    if (xPtr->link[0] == NULL) {', '      xPtr->link[0] = ptr->link[0];', '        stack[ht - 1]->link[dir[ht - 1]] = xPtr;', '        stack[i - 1]->link[dir[i - 1]] = yPtr;', '      yPtr->link[0] = ptr->link[0];', '      xPtr->link[0] = yPtr->link[1];', '      yPtr->link[1] = ptr->link[1];', '      pPtr = stack[ht - 1]->link[dir[ht - 1]];', '      if (pPtr && pPtr->color == RED) {', '        rPtr = stack[ht - 1]->link[1];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[1];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[1] || rPtr->link[1]->color == BLACK) {', '            qPtr = rPtr->link[0];', '            qPtr->color = BLACK;', '            rPtr->link[0] = qPtr->link[1];', '            qPtr->link[1] = rPtr;', '            rPtr = stack[ht - 1]->link[1] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[1]->color = BLACK;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '        rPtr = stack[ht - 1]->link[0];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[0];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[0] || rPtr->link[0]->color == BLACK) {', '            qPtr = rPtr->link[1];', '            qPtr->color = BLACK;', '            rPtr->link[1] = qPtr->link[0];', '            qPtr->link[0] = rPtr;', '            rPtr = stack[ht - 1]->link[0] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[0]->color = BLACK;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', 'void inorderTraversal(struct rbNode *node) {', '    inorderTraversal(node->link[0]);', '    inorderTraversal(node->link[1]);', '    printf(""1. Insertion\\t2. Deletion\\n"");', '    printf(""3. Traverse\\t4. Exit"");', '    printf(""\\nEnter your choice:"");', '        printf(""Enter the element to insert:"");', '        printf(""Enter the element to delete:"");', '        printf(""Not available\\n"");', '  void initializeNULLNode(NodePtr node, NodePtr parent) {', '  void preOrderHelper(NodePtr node) {', '      cout << node->data << "" "";', '      preOrderHelper(node->left);', '      preOrderHelper(node->right);', '  void inOrderHelper(NodePtr node) {', '      inOrderHelper(node->left);', '      cout << node->data << "" "";', '      inOrderHelper(node->right);', '  void postOrderHelper(NodePtr node) {', '      postOrderHelper(node->left);', '      postOrderHelper(node->right);', '      cout << node->data << "" "";', '  NodePtr searchTreeHelper(NodePtr node, int key) {', '    if (node == TNULL || key == node->data) {', '      return searchTreeHelper(node->left, key);', '    return searchTreeHelper(node->right, key);', '    while (x != root && x->color == 0) {', '      if (x == x->parent->left) {', '          leftRotate(x->parent);', '        if (s->left->color == 0 && s->right->color == 0) {', '          if (s->right->color == 0) {', '            s = x->parent->right;', '          s->color = x->parent->color;', '          leftRotate(x->parent);', '          rightRotate(x->parent);', '        if (s->right->color == 0 && s->right->color == 0) {', '          if (s->left->color == 0) {', '            s->right->color = 0;', '            s = x->parent->left;', '          s->color = x->parent->color;', '          rightRotate(x->parent);', '  void rbTransplant(NodePtr u, NodePtr v) {', '    } else if (u == u->parent->left) {', '  void deleteNodeHelper(NodePtr node, int key) {', '      cout << ""Key not found in the tree"" << endl;', '    int y_original_color = y->color;', '      rbTransplant(z, z->right);', '    } else if (z->right == TNULL) {', '      y_original_color = y->color;', '        rbTransplant(y, y->right);', '    if (y_original_color == 0) {', '    while (k->parent->color == 1) {', '      if (k->parent == k->parent->parent->right) {', '        u = k->parent->parent->left;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->left) {', '          k->parent->parent->color = 1;', '          leftRotate(k->parent->parent);', '        u = k->parent->parent->right;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->right) {', '          k->parent->parent->color = 1;', '          rightRotate(k->parent->parent);', '  void printHelper(NodePtr root, string indent, bool last) {', '      string sColor = root->color ? ""RED"" : ""BLACK"";', '      cout << root->data << ""("" << sColor << "")"" << endl;', '      printHelper(root->left, indent, false);', '      printHelper(root->right, indent, true);', '    postOrderHelper(this->root);', '    return searchTreeHelper(this->root, k);', '  NodePtr minimum(NodePtr node) {', '    while (node->left != TNULL) {', '  NodePtr maximum(NodePtr node) {', '    while (node->right != TNULL) {', '  NodePtr successor(NodePtr x) {', '    while (y != TNULL && x == y->right) {', '  NodePtr predecessor(NodePtr x) {', '    while (y != TNULL && x == y->left) {', '    } else if (x == x->parent->left) {', '    } else if (x == x->parent->right) {', '      if (node->data < x->data) {', '    } else if (node->data < y->data) {', '    if (node->parent == nullptr) {', '    if (node->parent->parent == nullptr) {', '    deleteNodeHelper(this->root, data);', '      printHelper(this->root, """", true);', '     << ""After deleting"" << endl;']",[],[],"[""Recolor|||Rotation|||The newNode be:||||||New node|||Let y be the leaf (ie. NIL) and x be the root of the tree. The new node is inserted in the following tree.|||Initial tree|||Check if the tree is empty (ie. whether x is NIL). If yes, insert newNode as a root node and color it black.|||Else, repeat steps following steps until leaf (NIL) is reached.|||Compare newKey with rootKey.|||If newKey is greater than rootKey, traverse through the right subtree.|||Else traverse through the left subtree.|||Path leading to the node where newNode is to be inserted||||||Assign the parent of the leaf as parent of newNode.|||If leafKey is greater than newKey, make newNode as rightChild.|||Else, make newNode as leftChild.|||New node inserted|||Assign NULL to the left and rightChild of newNode.|||Assign RED color to newNode.|||Set the color of the newNode red and assign null to the children|||Call InsertFix-algorithm to maintain the property of red-black tree if violated.|||Compare newKey with rootKey.|||If newKey is greater than rootKey, traverse through the right subtree.|||Else traverse through the left subtree.|||Path leading to the node where newNode is to be inserted|||Do the following until the parent of newNode p is RED.|||If p is the left child of grandParent gP of newNode, do the following.Case-I:|||If the color of the right child of gP of newNode is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Color change|||Assign gP to newNode.|||Reassigning newNodeCase-II:|||(Before moving on to this step, while loop is checked. If conditions are not satisfied, it the loop is broken.)|||Else if newNode is the right child of p then, assign p to newNode.|||Assigning parent of newNode as newNode|||Left-Rotate newNode.|||Left RotateCase-III:|||(Before moving on to this step, while loop is checked. If conditions are not satisfied, it the loop is broken.)|||Set color of p as BLACK and color of gP as RED.|||Color change|||Right-Rotate gP.|||Right Rotate||||||Else, do the following.|||If the color of the left child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.|||Else if newNode is the left child of p then, assign p to newNode and Right-Rotate newNode.|||Set color of p as BLACK and color of gP as RED.|||Left-Rotate gP.||||||(This step is performed after coming out of the while loop.)|||Set the root of the tree as BLACK.|||Set root's color black|||If the color of the right child of gP of newNode is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Color change|||Assign gP to newNode.|||Reassigning newNodeCase-II:|||(Before moving on to this step, while loop is checked. If conditions are not satisfied, it the loop is broken.)|||Else if newNode is the right child of p then, assign p to newNode.|||Assigning parent of newNode as newNode|||Left-Rotate newNode.|||Left RotateCase-III:|||(Before moving on to this step, while loop is checked. If conditions are not satisfied, it the loop is broken.)|||Set color of p as BLACK and color of gP as RED.|||Color change|||Right-Rotate gP.|||Right Rotate|||If the color of the left child of gP of z is RED, set the color of both the children of gP as BLACK and the color of gP as RED.|||Assign gP to newNode.|||Else if newNode is the left child of p then, assign p to newNode and Right-Rotate newNode.|||Set color of p as BLACK and color of gP as RED.|||Left-Rotate gP.|||""]"
36,['Deletion From a Red-Black Tree'],"['In this tutorial, you will learn how a node is deleted from a red-black tree is. Also, you will find working examples of deletions performed on a red-black tree in C, C++, Java and Python.']",[],[],"['Deleting an element from a Red-Black Tree', 'Algorithm to maintain Red-Black property after deletion', 'Python, Java and C/C++ Examples']",[],"['//cdn.programiz.com/sites/tutorial2program/files/delete-1-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/color-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-2-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-3-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-4-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-5-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-6-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-7-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-8-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-9-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-10-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-11-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-12-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/delete-13-red-black.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-red-black.png']","['The extra black can be removed if', 'Following algorithm retains the properties of a red-black tree.']","['Before reading this article, please refer to the article on red-black tree.', 'This operation removes a node from the tree. After deleting a node, the red-black property is maintained again.', 'This algorithm is implemented when a black node is deleted because it violates the black depth property of the red-black tree.', ""However, the color attribute of x is not changed rather the extra black is represented in x's pointing to the node."", 'The workflow of the above cases can be understood with the help of the flowchart below.']","['Red-Black tree is a self-balancing binary search tree in which each node contains an extra bit for denoting the color of the node, either red or black.', 'Deleting a node may or may not disrupt the red-black properties of a red-black tree. If this action violates the red-black properties, then a fixing algorithm is used to regain the red-black properties.', ""This violation is corrected by assuming that node x (which is occupying y's original position) has an extra black. This makes node x neither red nor black. It is either doubly black or black-and-red. This violates the red-black properties.""]","['import sys', '# Node creation', 'class Node():', '    def __init__(self, item):', '        self.item = item', '        self.parent = None', '        self.left = None', '        self.right = None', '        self.color = 1', 'class RedBlackTree():', '    def __init__(self):', '        self.TNULL = Node(0)', '        self.TNULL.color = 0', '        self.TNULL.left = None', '        self.root = self.TNULL', '    # Preorder', '        if node != TNULL:', '    # Inorder', '        if node != TNULL:', '    # Postorder', '        if node != TNULL:', '    # Search the tree', '            return node', '        if key < node.item:', '    def delete_fix(self, x):', '                else:', '            else:', '                else:', '        x.color = 0', '        if u.parent == None:', '            self.root = v', '            u.parent.left = v', '        else:', '            u.parent.right = v', '        v.parent = u.parent', '    # Node deletion', '        z = self.TNULL', '                z = node', '            else:', '        if z == self.TNULL:', '            return', '        y = z', '            x = z.right', '            x = z.left', '        else:', '            x = y.right', '            if y.parent == z:', '                x.parent = y', '            else:', '            y.left = z.left', '            y.left.parent = y', '            y.color = z.color', '            self.delete_fix(x)', '    def fix_insert(self, k):', '                else:', '            else:', '                else:', '            if k == self.root:', '                break', '        self.root.color = 0', '    # Printing the tree', '        if node != self.TNULL:', '            if last:', '            else:', '    def preorder(self):', '    def inorder(self):', '    def postorder(self):', '    def searchTree(self, k):', '    def minimum(self, node):', '            node = node.left', '        return node', '    def maximum(self, node):', '            node = node.right', '        return node', '    def successor(self, x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def predecessor(self,  x):', '        y = x.parent', '            x = y', '            y = y.parent', '        return y', '    def left_rotate(self, x):', '        y = x.right', '        x.right = y.left', '            y.left.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.left = y', '        else:', '            x.parent.right = y', '        y.left = x', '        x.parent = y', '    def right_rotate(self, x):', '        y = x.left', '        x.left = y.right', '            y.right.parent = x', '        y.parent = x.parent', '        if x.parent == None:', '            self.root = y', '            x.parent.right = y', '        else:', '            x.parent.left = y', '        y.right = x', '        x.parent = y', '    def insert(self, key):', '        node = Node(key)', '        node.parent = None', '        node.item = key', '        node.left = self.TNULL', '        node.color = 1', '        y = None', '        x = self.root', '        while x != self.TNULL:', '            y = x', '                x = x.left', '            else:', '                x = x.right', '        node.parent = y', '        if y == None:', '            self.root = node', '            y.left = node', '        else:', '            y.right = node', '            node.color = 0', '            return', '            return', '        self.fix_insert(node)', '    def get_root(self):', '        return self.root', '    def print_tree(self):', 'if __name__ == ""__main__"":', '    bst = RedBlackTree()', '    bst.insert(55)', '    bst.insert(40)', '    bst.insert(65)', '    bst.insert(60)', '    bst.insert(75)', '    bst.insert(57)', '    bst.print_tree()', '    bst.delete_node(40)', '    bst.print_tree()', 'class Node {', '  int data;', '  Node parent;', '  Node left;', '  Node right;', '  int color;', 'public class RedBlackTree {', '  private Node root;', '  private Node TNULL;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node.data) {', '    Node s;', '        s = x.parent.right;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.right;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.left.color = 0;', '            s.color = 1;', '            rightRotate(s);', '          }', '          x.parent.color = 0;', '          s.right.color = 0;', '          x = root;', '        }', '      } else {', '        s = x.parent.left;', '        if (s.color == 1) {', '          s.color = 0;', '          x.parent.color = 1;', '          s = x.parent.left;', '        }', '          s.color = 1;', '          x = x.parent;', '        } else {', '            s.right.color = 0;', '            s.color = 1;', '            leftRotate(s);', '            s = x.parent.left;', '          }', '          x.parent.color = 0;', '          s.left.color = 0;', '          x = root;', '        }', '    x.color = 0;', '    if (u.parent == null) {', '      root = v;', '      u.parent.left = v;', '    } else {', '      u.parent.right = v;', '    v.parent = u.parent;', '    Node z = TNULL;', '    Node x, y;', '    while (node != TNULL) {', '      if (node.data == key) {', '        z = node;', '      if (node.data <= key) {', '        node = node.right;', '      } else {', '        node = node.left;', '    if (z == TNULL) {', '      return;', '    y = z;', '    if (z.left == TNULL) {', '      x = z.right;', '      x = z.left;', '      rbTransplant(z, z.left);', '    } else {', '      y = minimum(z.right);', '      x = y.right;', '      if (y.parent == z) {', '        x.parent = y;', '      } else {', '        y.right = z.right;', '        y.right.parent = y;', '      rbTransplant(z, y);', '      y.left = z.left;', '      y.left.parent = y;', '      y.color = z.color;', '    if (yOriginalColor == 0) {', '      fixDelete(x);', '    Node u;', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            rightRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      } else {', '        if (u.color == 1) {', '          u.color = 0;', '          k.parent.color = 0;', '          k = k.parent.parent;', '        } else {', '            k = k.parent;', '            leftRotate(k);', '          }', '          k.parent.color = 0;', '        }', '      if (k == root) {', '        break;', '    root.color = 0;', '    if (root != TNULL) {', '      if (last) {', '        indent += ""   "";', '      } else {', '        indent += ""|  "";', '  public RedBlackTree() {', '    TNULL = new Node();', '    TNULL.color = 0;', '    TNULL.left = null;', '    TNULL.right = null;', '    root = TNULL;', '  public void preorder() {', '    preOrderHelper(this.root);', '  public void inorder() {', '    inOrderHelper(this.root);', '  public void postorder() {', '      node = node.left;', '    return node;', '      node = node.right;', '    return node;', '    if (x.right != TNULL) {', '      return minimum(x.right);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    if (x.left != TNULL) {', '      return maximum(x.left);', '    Node y = x.parent;', '      x = y;', '      y = y.parent;', '    return y;', '    Node y = x.right;', '    x.right = y.left;', '    if (y.left != TNULL) {', '      y.left.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.left = y;', '    } else {', '      x.parent.right = y;', '    y.left = x;', '    x.parent = y;', '    Node y = x.left;', '    x.left = y.right;', '    if (y.right != TNULL) {', '      y.right.parent = x;', '    y.parent = x.parent;', '    if (x.parent == null) {', '      this.root = y;', '      x.parent.right = y;', '    } else {', '      x.parent.left = y;', '    y.right = x;', '    x.parent = y;', '    Node node = new Node();', '    node.parent = null;', '    node.data = key;', '    node.left = TNULL;', '    node.right = TNULL;', '    node.color = 1;', '    Node y = null;', '    Node x = this.root;', '    while (x != TNULL) {', '      y = x;', '        x = x.left;', '      } else {', '        x = x.right;', '    node.parent = y;', '    if (y == null) {', '      root = node;', '      y.left = node;', '    } else {', '      y.right = node;', '    if (node.parent == null) {', '      node.color = 0;', '      return;', '      return;', '    fixInsert(node);', '  public Node getRoot() {', '    return this.root;', '  public void printTree() {', '    bst.insert(55);', '    bst.insert(40);', '    bst.insert(65);', '    bst.insert(60);', '    bst.insert(75);', '    bst.insert(57);', '    bst.printTree();', '    bst.deleteNode(40);', '    bst.printTree();', '#include <stdio.h>', '#include <stdlib.h>', 'enum nodeColor {', 'struct rbNode {', '  int data, color;', '  struct rbNode *link[2];', 'struct rbNode *root = NULL;', '  struct rbNode *newnode;', '  newnode->data = data;', '  newnode->color = RED;', '  return newnode;', 'void insertion(int data) {', '  int dir[98], ht = 0, index;', '  ptr = root;', '  if (!root) {', '    root = createNode(data);', '    return;', '  stack[ht] = root;', '  dir[ht++] = 0;', '  while (ptr != NULL) {', '    if (ptr->data == data) {', '      return;', '    stack[ht] = ptr;', '    ptr = ptr->link[index];', '    dir[ht++] = index;', '    if (dir[ht - 2] == 0) {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        xPtr->color = RED;', '        yPtr->color = BLACK;', '        yPtr->link[1] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '    } else {', '        ht = ht - 2;', '      } else {', '        } else {', '        }', '        xPtr = stack[ht - 2];', '        yPtr->color = BLACK;', '        xPtr->color = RED;', '        yPtr->link[0] = xPtr;', '        if (xPtr == root) {', '          root = yPtr;', '        } else {', '        }', '        break;', '  root->color = BLACK;', 'void deletion(int data) {', '  enum nodeColor color;', '  if (!root) {', '    return;', '  ptr = root;', '  while (ptr != NULL) {', '      break;', '    stack[ht] = ptr;', '    dir[ht++] = diff;', '    ptr = ptr->link[diff];', '  if (ptr->link[1] == NULL) {', '      free(ptr);', '      root = NULL;', '    } else if (ptr == root) {', '      root = ptr->link[0];', '      free(ptr);', '    } else {', '  } else {', '    xPtr = ptr->link[1];', '      color = xPtr->color;', '      ptr->color = color;', '      if (ptr == root) {', '        root = xPtr;', '      } else {', '      dir[ht] = 1;', '      stack[ht++] = xPtr;', '    } else {', '      i = ht++;', '      while (1) {', '        dir[ht] = 0;', '        stack[ht++] = xPtr;', '        yPtr = xPtr->link[0];', '        if (!yPtr->link[0])', '          break;', '        xPtr = yPtr;', '      dir[i] = 1;', '      stack[i] = yPtr;', '      if (i > 0)', '      if (ptr == root) {', '        root = yPtr;', '      color = yPtr->color;', '      ptr->color = color;', '  if (ht < 1)', '    return;', '  if (ptr->color == BLACK) {', '    while (1) {', '        pPtr->color = BLACK;', '        break;', '      if (ht < 2)', '        break;', '      if (dir[ht - 2] == 0) {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 0;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      } else {', '        if (!rPtr)', '          break;', '          rPtr->color = BLACK;', '            root = rPtr;', '          } else {', '          }', '          dir[ht] = 1;', '          ht++;', '        }', '          rPtr->color = RED;', '        } else {', '            rPtr->color = RED;', '          }', '            root = rPtr;', '          } else {', '          }', '          break;', '        }', '      ht--;', '  if (node) {', '  return;', 'int main() {', '  int ch, data;', '  while (1) {', '    scanf(""%d"", &ch);', '    switch (ch) {', '      case 1:', '        scanf(""%d"", &data);', '        insertion(data);', '        break;', '      case 2:', '        scanf(""%d"", &data);', '        deletion(data);', '        break;', '      case 3:', '        printf(""\\n"");', '        break;', '      case 4:', '        exit(0);', '      default:', '        break;', '    printf(""\\n"");', '  return 0;', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  Node *parent;', '  Node *left;', '  Node *right;', '  int color;', 'typedef Node *NodePtr;', 'class RedBlackTree {', '   private:', '  NodePtr root;', '  NodePtr TNULL;', '    node->data = 0;', '    node->parent = parent;', '    node->left = nullptr;', '    node->right = nullptr;', '    node->color = 0;', '    if (node != TNULL) {', '    if (node != TNULL) {', '    if (node != TNULL) {', '      return node;', '    if (key < node->data) {', '  void deleteFix(NodePtr x) {', '    NodePtr s;', '        s = x->parent->right;', '        if (s->color == 1) {', '          s->color = 0;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            rightRotate(s);', '          }', '          s->right->color = 0;', '          x = root;', '        }', '      } else {', '        s = x->parent->left;', '        if (s->color == 1) {', '          s->color = 0;', '          s = x->parent->left;', '        }', '          s->color = 1;', '          x = x->parent;', '        } else {', '            s->color = 1;', '            leftRotate(s);', '          }', '          s->left->color = 0;', '          x = root;', '        }', '    x->color = 0;', '      root = v;', '      u->parent->left = v;', '    } else {', '      u->parent->right = v;', '    v->parent = u->parent;', '    NodePtr z = TNULL;', '    NodePtr x, y;', '    while (node != TNULL) {', '      if (node->data == key) {', '        z = node;', '      if (node->data <= key) {', '        node = node->right;', '      } else {', '        node = node->left;', '    if (z == TNULL) {', '      return;', '    y = z;', '    if (z->left == TNULL) {', '      x = z->right;', '      x = z->left;', '    } else {', '      y = minimum(z->right);', '      x = y->right;', '      if (y->parent == z) {', '        x->parent = y;', '      } else {', '        y->right = z->right;', '        y->right->parent = y;', '      rbTransplant(z, y);', '      y->left = z->left;', '      y->left->parent = y;', '      y->color = z->color;', '    delete z;', '      deleteFix(x);', '  void insertFix(NodePtr k) {', '    NodePtr u;', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            rightRotate(k);', '          }', '        }', '      } else {', '        if (u->color == 1) {', '          u->color = 0;', '        } else {', '            k = k->parent;', '            leftRotate(k);', '          }', '        }', '      if (k == root) {', '        break;', '    root->color = 0;', '    if (root != TNULL) {', '      cout << indent;', '      if (last) {', '        cout << ""R----"";', '        indent += ""   "";', '      } else {', '        cout << ""L----"";', '        indent += ""|  "";', '   public:', '  RedBlackTree() {', '    TNULL = new Node;', '    TNULL->color = 0;', '    TNULL->left = nullptr;', '    TNULL->right = nullptr;', '    root = TNULL;', '  void preorder() {', '  void inorder() {', '    inOrderHelper(this->root);', '  void postorder() {', '  NodePtr searchTree(int k) {', '      node = node->left;', '    return node;', '      node = node->right;', '    return node;', '    if (x->right != TNULL) {', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '    if (x->left != TNULL) {', '      return maximum(x->left);', '    NodePtr y = x->parent;', '      x = y;', '      y = y->parent;', '    return y;', '  void leftRotate(NodePtr x) {', '    NodePtr y = x->right;', '    x->right = y->left;', '    if (y->left != TNULL) {', '      y->left->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->left = y;', '    } else {', '      x->parent->right = y;', '    y->left = x;', '    x->parent = y;', '    NodePtr y = x->left;', '    x->left = y->right;', '    if (y->right != TNULL) {', '      y->right->parent = x;', '    y->parent = x->parent;', '      this->root = y;', '      x->parent->right = y;', '    } else {', '      x->parent->left = y;', '    y->right = x;', '    x->parent = y;', '  void insert(int key) {', '    NodePtr node = new Node;', '    node->parent = nullptr;', '    node->data = key;', '    node->left = TNULL;', '    node->right = TNULL;', '    node->color = 1;', '    NodePtr y = nullptr;', '    NodePtr x = this->root;', '    while (x != TNULL) {', '      y = x;', '        x = x->left;', '      } else {', '        x = x->right;', '    node->parent = y;', '    if (y == nullptr) {', '      root = node;', '      y->left = node;', '    } else {', '      y->right = node;', '      node->color = 0;', '      return;', '      return;', '    insertFix(node);', '  NodePtr getRoot() {', '    return this->root;', '  void deleteNode(int data) {', '  void printTree() {', '    if (root) {', 'int main() {', '  RedBlackTree bst;', '  bst.insert(55);', '  bst.insert(40);', '  bst.insert(65);', '  bst.insert(60);', '  bst.insert(75);', '  bst.insert(57);', '  bst.printTree();', '  cout << endl', '  bst.deleteNode(40);', '  bst.printTree();']","['# Implementing Red-Black Tree in Python', '    def pre_order_helper(self, node):', '            sys.stdout.write(node.item + "" "")', '            self.pre_order_helper(node.left)', '            self.pre_order_helper(node.right)', '    def in_order_helper(self, node):', '            self.in_order_helper(node.left)', '            sys.stdout.write(node.item + "" "")', '            self.in_order_helper(node.right)', '    def post_order_helper(self, node):', '            self.post_order_helper(node.left)', '            self.post_order_helper(node.right)', '            sys.stdout.write(node.item + "" "")', '    def search_tree_helper(self, node, key):', '        if node == TNULL or key == node.item:', '            return self.search_tree_helper(node.left, key)', '        return self.search_tree_helper(node.right, key)', '    # Balancing the tree after deletion', '        while x != self.root and x.color == 0:', '            if x == x.parent.left:', '                s = x.parent.right', '                if s.color == 1:', '                    x.parent.color = 1', '                    self.left_rotate(x.parent)', '                    s = x.parent.right', '                if s.left.color == 0 and s.right.color == 0:', '                    x = x.parent', '                    if s.right.color == 0:', '                        s.left.color = 0', '                        s.color = 1', '                        self.right_rotate(s)', '                        s = x.parent.right', '                    s.color = x.parent.color', '                    x.parent.color = 0', '                    s.right.color = 0', '                    self.left_rotate(x.parent)', '                    x = self.root', '                s = x.parent.left', '                if s.color == 1:', '                    x.parent.color = 1', '                    self.right_rotate(x.parent)', '                    s = x.parent.left', '                if s.right.color == 0 and s.left.color == 0:', '                    x = x.parent', '                    if s.left.color == 0:', '                        s.right.color = 0', '                        s.color = 1', '                        self.left_rotate(s)', '                        s = x.parent.left', '                    s.color = x.parent.color', '                    x.parent.color = 0', '                    s.left.color = 0', '                    self.right_rotate(x.parent)', '                    x = self.root', '    def __rb_transplant(self, u, v):', '        elif u == u.parent.left:', '    def delete_node_helper(self, node, key):', '        while node != self.TNULL:', '            if node.item == key:', '            if node.item <= key:', '                node = node.right', '                node = node.left', '            print(""Cannot find key in the tree"")', '        y_original_color = y.color', '        if z.left == self.TNULL:', '            self.__rb_transplant(z, z.right)', '        elif (z.right == self.TNULL):', '            self.__rb_transplant(z, z.left)', '            y = self.minimum(z.right)', '            y_original_color = y.color', '                self.__rb_transplant(y, y.right)', '                y.right = z.right', '                y.right.parent = y', '            self.__rb_transplant(z, y)', '        if y_original_color == 0:', '    # Balance the tree after insertion', '        while k.parent.color == 1:', '            if k.parent == k.parent.parent.right:', '                u = k.parent.parent.left', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.left:', '                        k = k.parent', '                        self.right_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.left_rotate(k.parent.parent)', '                u = k.parent.parent.right', '                if u.color == 1:', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    k = k.parent.parent', '                    if k == k.parent.right:', '                        k = k.parent', '                        self.left_rotate(k)', '                    k.parent.color = 0', '                    k.parent.parent.color = 1', '                    self.right_rotate(k.parent.parent)', '    def __print_helper(self, node, indent, last):', '            sys.stdout.write(indent)', '                sys.stdout.write(""R----"")', '                indent += ""     ""', '                sys.stdout.write(""L----"")', '                indent += ""|    ""', '            s_color = ""RED"" if node.color == 1 else ""BLACK""', '            print(str(node.item) + ""("" + s_color + "")"")', '            self.__print_helper(node.left, indent, False)', '            self.__print_helper(node.right, indent, True)', '        self.pre_order_helper(self.root)', '        self.in_order_helper(self.root)', '        self.post_order_helper(self.root)', '        return self.search_tree_helper(self.root, k)', '        while node.left != self.TNULL:', '        while node.right != self.TNULL:', '        if x.right != self.TNULL:', '            return self.minimum(x.right)', '        while y != self.TNULL and x == y.right:', '        if (x.left != self.TNULL):', '            return self.maximum(x.left)', '        while y != self.TNULL and x == y.left:', '        if y.left != self.TNULL:', '        elif x == x.parent.left:', '        if y.right != self.TNULL:', '        elif x == x.parent.right:', '            if node.item < x.item:', '        elif node.item < y.item:', '        if node.parent.parent == None:', '    def delete_node(self, item):', '        self.delete_node_helper(self.root, item)', '        self.__print_helper(self.root, """", True)', '    print(""\\nAfter deleting an element"")', '  private void preOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      preOrderHelper(node.left);', '      preOrderHelper(node.right);', '  private void inOrderHelper(Node node) {', '      System.out.print(node.data + "" "");', '      inOrderHelper(node.right);', '  private void postOrderHelper(Node node) {', '      postOrderHelper(node.left);', '      postOrderHelper(node.right);', '      System.out.print(node.data + "" "");', '  private Node searchTreeHelper(Node node, int key) {', '    if (node == TNULL || key == node.data) {', '      return searchTreeHelper(node.left, key);', '    return searchTreeHelper(node.right, key);', '  private void fixDelete(Node x) {', '    while (x != root && x.color == 0) {', '        if (s.left.color == 0 && s.right.color == 0) {', '          if (s.right.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '        if (s.right.color == 0 && s.right.color == 0) {', '          if (s.left.color == 0) {', '          s.color = x.parent.color;', '          rightRotate(x.parent);', '  private void rbTransplant(Node u, Node v) {', '    } else if (u == u.parent.left) {', '  private void deleteNodeHelper(Node node, int key) {', '      System.out.println(""Couldn\'t find key in the tree"");', '    int yOriginalColor = y.color;', '    } else if (z.right == TNULL) {', '        rbTransplant(y, y.right);', '  private void fixInsert(Node k) {', '    while (k.parent.color == 1) {', '      if (k.parent == k.parent.parent.right) {', '        u = k.parent.parent.left;', '          k.parent.parent.color = 1;', '          if (k == k.parent.left) {', '          k.parent.parent.color = 1;', '          leftRotate(k.parent.parent);', '        u = k.parent.parent.right;', '          k.parent.parent.color = 1;', '          if (k == k.parent.right) {', '          k.parent.parent.color = 1;', '          rightRotate(k.parent.parent);', '  private void printHelper(Node root, String indent, boolean last) {', '        System.out.print(""R----"");', '        System.out.print(""L----"");', '      String sColor = root.color == 1 ? ""RED"" : ""BLACK"";', '      System.out.println(root.data + ""("" + sColor + "")"");', '      printHelper(root.left, indent, false);', '      printHelper(root.right, indent, true);', '  public Node searchTree(int k) {', '    return searchTreeHelper(this.root, k);', '  public Node minimum(Node node) {', '    while (node.left != TNULL) {', '  public Node maximum(Node node) {', '    while (node.right != TNULL) {', '  public Node successor(Node x) {', '    while (y != TNULL && x == y.right) {', '  public Node predecessor(Node x) {', '    while (y != TNULL && x == y.left) {', '  public void leftRotate(Node x) {', '    } else if (x == x.parent.left) {', '  public void rightRotate(Node x) {', '    } else if (x == x.parent.right) {', '    } else if (node.data < y.data) {', '    if (node.parent.parent == null) {', '  public void deleteNode(int data) {', '    deleteNodeHelper(this.root, data);', '    printHelper(this.root, """", true);', '  public static void main(String[] args) {', '    RedBlackTree bst = new RedBlackTree();', '    System.out.println(""\\nAfter deleting:"");', 'struct rbNode *createNode(int data) {', '  newnode = (struct rbNode *)malloc(sizeof(struct rbNode));', '  newnode->link[0] = newnode->link[1] = NULL;', '  struct rbNode *stack[98], *ptr, *newnode, *xPtr, *yPtr;', '      printf(""Duplicates Not Allowed!!\\n"");', '    index = (data - ptr->data) > 0 ? 1 : 0;', '  stack[ht - 1]->link[index] = newnode = createNode(data);', '  while ((ht >= 3) && (stack[ht - 1]->color == RED)) {', '      yPtr = stack[ht - 2]->link[1];', '      if (yPtr != NULL && yPtr->color == RED) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[1] = yPtr->link[0];', '          stack[ht - 2]->link[0] = yPtr;', '        xPtr->link[0] = yPtr->link[1];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '      yPtr = stack[ht - 2]->link[0];', '      if ((yPtr != NULL) && (yPtr->color == RED)) {', '        stack[ht - 2]->color = RED;', '        stack[ht - 1]->color = yPtr->color = BLACK;', '          xPtr->link[0] = yPtr->link[1];', '          stack[ht - 2]->link[1] = yPtr;', '        xPtr->link[1] = yPtr->link[0];', '          stack[ht - 3]->link[dir[ht - 3]] = yPtr;', '  struct rbNode *stack[98], *ptr, *xPtr, *yPtr;', '  struct rbNode *pPtr, *qPtr, *rPtr;', '    printf(""Tree not available\\n"");', '    if ((data - ptr->data) == 0)', '    diff = (data - ptr->data) > 0 ? 1 : 0;', '    if ((ptr == root) && (ptr->link[0] == NULL)) {', '      stack[ht - 1]->link[dir[ht - 1]] = ptr->link[0];', '    if (xPtr->link[0] == NULL) {', '      xPtr->link[0] = ptr->link[0];', '        stack[ht - 1]->link[dir[ht - 1]] = xPtr;', '        stack[i - 1]->link[dir[i - 1]] = yPtr;', '      yPtr->link[0] = ptr->link[0];', '      xPtr->link[0] = yPtr->link[1];', '      yPtr->link[1] = ptr->link[1];', '      pPtr = stack[ht - 1]->link[dir[ht - 1]];', '      if (pPtr && pPtr->color == RED) {', '        rPtr = stack[ht - 1]->link[1];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[1];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[1] || rPtr->link[1]->color == BLACK) {', '            qPtr = rPtr->link[0];', '            qPtr->color = BLACK;', '            rPtr->link[0] = qPtr->link[1];', '            qPtr->link[1] = rPtr;', '            rPtr = stack[ht - 1]->link[1] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[1]->color = BLACK;', '          stack[ht - 1]->link[1] = rPtr->link[0];', '          rPtr->link[0] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '        rPtr = stack[ht - 1]->link[0];', '        if (rPtr->color == RED) {', '          stack[ht - 1]->color = RED;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', '          stack[ht] = stack[ht - 1];', '          rPtr = stack[ht - 1]->link[0];', '        if ((!rPtr->link[0] || rPtr->link[0]->color == BLACK) &&', '          (!rPtr->link[1] || rPtr->link[1]->color == BLACK)) {', '          if (!rPtr->link[0] || rPtr->link[0]->color == BLACK) {', '            qPtr = rPtr->link[1];', '            qPtr->color = BLACK;', '            rPtr->link[1] = qPtr->link[0];', '            qPtr->link[0] = rPtr;', '            rPtr = stack[ht - 1]->link[0] = qPtr;', '          rPtr->color = stack[ht - 1]->color;', '          stack[ht - 1]->color = BLACK;', '          rPtr->link[0]->color = BLACK;', '          stack[ht - 1]->link[0] = rPtr->link[1];', '          rPtr->link[1] = stack[ht - 1];', '          if (stack[ht - 1] == root) {', '            stack[ht - 2]->link[dir[ht - 2]] = rPtr;', 'void inorderTraversal(struct rbNode *node) {', '    inorderTraversal(node->link[0]);', '    inorderTraversal(node->link[1]);', '    printf(""1. Insertion\\t2. Deletion\\n"");', '    printf(""3. Traverse\\t4. Exit"");', '    printf(""\\nEnter your choice:"");', '        printf(""Enter the element to insert:"");', '        printf(""Enter the element to delete:"");', '        printf(""Not available\\n"");', '  void initializeNULLNode(NodePtr node, NodePtr parent) {', '  void preOrderHelper(NodePtr node) {', '      cout << node->data << "" "";', '      preOrderHelper(node->left);', '      preOrderHelper(node->right);', '  void inOrderHelper(NodePtr node) {', '      inOrderHelper(node->left);', '      cout << node->data << "" "";', '      inOrderHelper(node->right);', '  void postOrderHelper(NodePtr node) {', '      postOrderHelper(node->left);', '      postOrderHelper(node->right);', '      cout << node->data << "" "";', '  NodePtr searchTreeHelper(NodePtr node, int key) {', '    if (node == TNULL || key == node->data) {', '      return searchTreeHelper(node->left, key);', '    return searchTreeHelper(node->right, key);', '    while (x != root && x->color == 0) {', '      if (x == x->parent->left) {', '          leftRotate(x->parent);', '        if (s->left->color == 0 && s->right->color == 0) {', '          if (s->right->color == 0) {', '            s = x->parent->right;', '          s->color = x->parent->color;', '          leftRotate(x->parent);', '          rightRotate(x->parent);', '        if (s->right->color == 0 && s->right->color == 0) {', '          if (s->left->color == 0) {', '            s->right->color = 0;', '            s = x->parent->left;', '          s->color = x->parent->color;', '          rightRotate(x->parent);', '  void rbTransplant(NodePtr u, NodePtr v) {', '    } else if (u == u->parent->left) {', '  void deleteNodeHelper(NodePtr node, int key) {', '      cout << ""Key not found in the tree"" << endl;', '    int y_original_color = y->color;', '      rbTransplant(z, z->right);', '    } else if (z->right == TNULL) {', '      y_original_color = y->color;', '        rbTransplant(y, y->right);', '    if (y_original_color == 0) {', '    while (k->parent->color == 1) {', '      if (k->parent == k->parent->parent->right) {', '        u = k->parent->parent->left;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->left) {', '          k->parent->parent->color = 1;', '          leftRotate(k->parent->parent);', '        u = k->parent->parent->right;', '          k->parent->parent->color = 1;', '          k = k->parent->parent;', '          if (k == k->parent->right) {', '          k->parent->parent->color = 1;', '          rightRotate(k->parent->parent);', '  void printHelper(NodePtr root, string indent, bool last) {', '      string sColor = root->color ? ""RED"" : ""BLACK"";', '      cout << root->data << ""("" << sColor << "")"" << endl;', '      printHelper(root->left, indent, false);', '      printHelper(root->right, indent, true);', '    postOrderHelper(this->root);', '    return searchTreeHelper(this->root, k);', '  NodePtr minimum(NodePtr node) {', '    while (node->left != TNULL) {', '  NodePtr maximum(NodePtr node) {', '    while (node->right != TNULL) {', '  NodePtr successor(NodePtr x) {', '    while (y != TNULL && x == y->right) {', '  NodePtr predecessor(NodePtr x) {', '    while (y != TNULL && x == y->left) {', '    } else if (x == x->parent->left) {', '    } else if (x == x->parent->right) {', '      if (node->data < x->data) {', '    } else if (node->data < y->data) {', '    if (node->parent == nullptr) {', '    if (node->parent->parent == nullptr) {', '    deleteNodeHelper(this->root, data);', '      printHelper(this->root, """", true);', '     << ""After deleting"" << endl;']",[],[],"['Let the nodeToBeDeleted be:||||||Node to be deleted|||Save the color of nodeToBeDeleted in origrinalColor.|||Saving original color|||If the left child of nodeToBeDeleted is NULL|||Assign the right child of nodeToBeDeleted to x.|||Assign x to the rightChild|||Transplant nodeToBeDeleted with x.|||Transplant nodeToBeDeleted with x||||||Else if the right child of nodeToBeDeleted is NULL|||Assign the left child of nodeToBeDeleted into x.|||Transplant nodeToBeDeleted with x.||||||Else|||Assign the minimum of right subtree of noteToBeDeleted into y.|||Save the color of y in originalColor.|||Assign the rightChild of y into x.|||If y is a child of nodeToBeDeleted, then set the parent of x as y.|||Else, transplant y with rightChild of y.|||Transplant nodeToBeDeleted with y.|||Set the color of y with originalColor.||||||If the originalColor is BLACK, call DeleteFix(x).|||Assign the right child of nodeToBeDeleted to x.|||Assign x to the rightChild|||Transplant nodeToBeDeleted with x.|||Transplant nodeToBeDeleted with x|||Assign the left child of nodeToBeDeleted into x.|||Transplant nodeToBeDeleted with x.|||Assign the minimum of right subtree of noteToBeDeleted into y.|||Save the color of y in originalColor.|||Assign the rightChild of y into x.|||If y is a child of nodeToBeDeleted, then set the parent of x as y.|||Else, transplant y with rightChild of y.|||Transplant nodeToBeDeleted with y.|||Set the color of y with originalColor.|||It reaches the root node.|||If x points to a red-black node. In this case, x is colored black.|||Suitable rotations and recolorings are performed.|||Do the following until the x is not the root of the tree and the color of x is BLACK|||If x is the left child of its parent then,|||Assign w to the sibling of x.|||Assigning w|||If the sibling of x is RED,Case-I:|||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Assign the rightChild of the parent of x to w.|||Reassign w||||||If the color of both the right and the leftChild of w is BLACK,Case-II:|||Set the color of w as RED|||Assign the parent of x to x.||||||Else if the color of the rightChild of w is BLACKCase-III:|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Color change|||Right-Rotate w.|||Right rotate|||Assign the rightChild of the parent of x to w.|||Reassign w||||||If any of the above cases do not occur, then do the following.Case-IV:|||Set the color of w as the color of the parent of x.|||Set the color of the parent of parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Set x as the root of the tree.|||Set x as root|||||||||Else same as above with right changed to left and vice versa.|||Set the color of x as BLACK.|||Assign w to the sibling of x.|||Assigning w|||If the sibling of x is RED,Case-I:|||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Assign the rightChild of the parent of x to w.|||Reassign w||||||If the color of both the right and the leftChild of w is BLACK,Case-II:|||Set the color of w as RED|||Assign the parent of x to x.||||||Else if the color of the rightChild of w is BLACKCase-III:|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Color change|||Right-Rotate w.|||Right rotate|||Assign the rightChild of the parent of x to w.|||Reassign w||||||If any of the above cases do not occur, then do the following.Case-IV:|||Set the color of w as the color of the parent of x.|||Set the color of the parent of parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Set x as the root of the tree.|||Set x as root||||||Set the color of the right child of the parent of x as BLACK.|||Set the color of the parent of x as RED.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Assign the rightChild of the parent of x to w.|||Reassign w|||Set the color of w as RED|||Assign the parent of x to x.|||Set the color of the leftChild of w as BLACK|||Set the color of w as RED|||Color change|||Right-Rotate w.|||Right rotate|||Assign the rightChild of the parent of x to w.|||Reassign w|||Set the color of w as the color of the parent of x.|||Set the color of the parent of parent of x as BLACK.|||Set the color of the right child of w as BLACK.|||Color change|||Left-Rotate the parent of x.|||Left-rotate|||Set x as the root of the tree.|||Set x as root|||']"
37,['Graph Data Stucture'],"['In this tutorial, you will learn what a Graph Data Structure is. Also, you will find representations of a graph.']",[],[],"['Graph Terminology', 'Graph Representation', 'Graph Operations']","['1. Adjacency Matrix', '2. Adjacency List']","['//cdn.programiz.com/sites/tutorial2program/files/facebook-graph.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-vertices-edges_0.png', '//cdn.programiz.com/sites/tutorial2program/files/adjacency-matrix_1.png', '//cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png']","['In the graph,', 'Graphs are commonly represented in two ways:', 'The adjacency matrix for the graph we created above is', 'An adjacency list represents a graph as an array of linked lists.', 'The most common graph operations are:']","['A graph data structure is a collection of nodes that have data and are connected to other nodes.', 'More precisely, a graph is a data structure (V, E) that consists of', 'An adjacency matrix is a 2D array of V x V vertices. Each row and column represent a vertex.', 'If the value of any element a[i][j] is 1, it represents that there is an edge connecting vertex i and vertex j.', 'The adjacency list for the graph we made in the first example is as follows:']","[""Let's try to understand this through an example. On facebook, everything is a node. That includes User, Photo, Album, Event, Group, Page, Comment, Story, Video, Link, Note...anything that has data is a node."", 'Every relationship is an edge from one node to another. Whether you post a photo, join a group, like a page, etc., a new edge is created for that relationship.', 'All of facebook is then a collection of these nodes and edges. This is because facebook uses a graph data structure to store its data.', 'Since it is an undirected graph, for edge (0,2), we also need to mark edge (2,0); making the adjacency matrix symmetric about the diagonal.', 'Edge lookup(checking if an edge exists between vertex A and vertex B) is extremely fast in adjacency matrix representation but we have to reserve space for every possible link between all vertices(V x V), so it requires more space.', 'The index of the array represents a vertex and each element in its linked list represents the other vertices that form an edge with the vertex.', 'An adjacency list is efficient in terms of storage because we only need to store the values for the edges. For a graph with millions of vertices, this can mean a lot of saved space.']",[],[],"['V = {0, 1, 2, 3}', 'E = {(0,1), (0,2), (0,3), (1,2)}', 'G = {V, E}']",[],"[""A collection of vertices V|||A collection of edges E, represented as ordered pairs of vertices (u,v)|||Adjacency: A vertex is said to be adjacent to another vertex if there is an edge connecting them. Vertices 2 and 3 are not adjacent because there is no edge between them.|||Path: A sequence of edges that allows you to go from vertex A to vertex B is called a path. 0-1, 1-2 and 0-2 are paths from vertex 0 to vertex 2.|||Directed Graph: A graph in which an edge (u,v) doesn't necessarily mean that there is an edge (v, u) as well. The edges in such a graph are represented by arrows to show the direction of the edge.|||Check if the element is present in the graph|||Graph Traversal|||Add elements(vertex, edges) to graph|||Finding the path from one vertex to another|||""]"
38,['Spanning Tree and Minimum Spanning Tree'],"['In this tutorial, you will learn about spanning tree and minimum spanning tree with help of examples and figures.']",[],[],"['Spanning tree', 'Example of a Spanning Tree', 'Minimum Spanning Tree', 'Example of a Spanning Tree', 'Spanning Tree Applications', 'Minimum Spanning tree Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/undirected-graph.png', '//cdn.programiz.com/sites/tutorial2program/files/connected-graph.png', '//cdn.programiz.com/sites/tutorial2program/files/initial-tree_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-1_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-3_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-4_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-5_0.png', '//cdn.programiz.com/sites/tutorial2program/files/spanning-tree-6_0.png', '//cdn.programiz.com/sites/tutorial2program/files/initial-tree-mst_0_1.png', '//cdn.programiz.com/sites/tutorial2program/files/mst-1_0_1.png', '//cdn.programiz.com/sites/tutorial2program/files/mst-3_0_1.png', '//cdn.programiz.com/sites/tutorial2program/files/mst-4_0_1.png', '//cdn.programiz.com/sites/tutorial2program/files/mst_0_1.png', '//cdn.programiz.com/sites/tutorial2program/files/mst_1_1.png']","['The edges may or may not have weights assigned to them.', ""Let's understand the spanning tree with examples below:"", 'Let the original graph be:', 'The initial graph is:', 'The possible spanning trees from the above graph are:', 'The minimum spanning tree from the above spanning trees is:']","['Before we learn about spanning trees, we need to understand two graphs: undirected graphs and connected graphs.', 'An undirected graph is a graph in which the edges do not point in any direction (ie. the edges are bidirectional).', 'A connected graph is a graph in which there is always a path from a vertex to any other vertex.', 'The total number of spanning trees with n vertices that can be created from a complete graph is equal to n(n-2).', 'Some of the possible spanning trees that can be created from the above graph are:', 'A minimum spanning tree is a spanning tree in which the sum of the weight of the edges is as minimum as possible.', ""Let's understand the above definition with the help of the example below."", 'The minimum spanning tree from a graph is found using the following algorithms:']","['A spanning tree is a sub-graph of an undirected connected graph, which includes all the vertices of the graph with a minimum possible number of edges. If a vertex is missed, then it is not a spanning tree.', 'If we have n = 4, the maximum number of possible spanning trees is equal to 44-2 = 16. Thus, 16 spanning trees can be formed from a complete graph with 4 vertices.']",[],[],[],[],"[""Computer Network Routing Protocol|||Cluster Analysis|||Civil Network Planning|||To find paths in the map|||To design networks like telecommunication networks, water supply networks, and electrical grids.|||&&&Prim's Algorithm|||Kruskal's Algorithm|||""]"
39,['Strongly Connected Components'],"[""In this tutorial, you will learn how strongly connected components are formed. Also, you will find working examples of Kosaraju's algorithm in C, C++, Java and Python.""]",[],[],"[""Kosaraju's Algorithm"", 'Python, Java, C++ examples', ""Kosaraju's Algorithm Complexity"", 'Strongly Connected Components Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/scc-initial-graph.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-strongly-connected-components.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-step-1.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-step-2.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-step-3.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-step-4.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-reversed-graph.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-reversed-step-1.png', '//cdn.programiz.com/sites/tutorial2program/files/reversed%20step-2_0.png', '//cdn.programiz.com/sites/tutorial2program/files/reversed%20step-3_0.png', '//cdn.programiz.com/sites/tutorial2program/files/scc-final-graph.png']","['For example:', 'Let us take the graph below.', 'The strongly connected components of the above graph are:', ""These components can be found using Kosaraju's Algorithm."", 'Three steps are involved.', ""Kosaraju's algorithm runs in linear time i.e. O(V+E).""]","[""Kosaraju's Algorithm is based on the depth-first search algorithm implemented twice.""]","['A strongly connected component is the portion of a directed graph in which there is a path from each vertex to another vertex. It is applicable only on a directed graph.', 'You can observe that in the first strongly connected component, every vertex can reach the other vertex through the directed path.']","['class Graph:', '        self.V = vertex', '    # Add edge into the graph', '    def add_edge(self, s, d):', '    # dfs', ""        print(d, end='')"", '    # transpose the matrix', '    def transpose(self):', '        g = Graph(self.V)', '        for i in self.graph:', '        return g', '    def print_scc(self):', '        stack = []', '        gr = self.transpose()', '        while stack:', '            i = stack.pop()', '                print("""")', 'g = Graph(8)', 'g.add_edge(0, 1)', 'g.add_edge(1, 2)', 'g.add_edge(2, 3)', 'g.add_edge(2, 4)', 'g.add_edge(3, 0)', 'g.add_edge(4, 5)', 'g.add_edge(5, 6)', 'g.add_edge(6, 4)', 'g.add_edge(6, 7)', 'g.print_scc()', 'import java.util.*;', 'import java.util.LinkedList;', 'class Graph {', '\tprivate int V;', '\tGraph(int s) {', '\t\tV = s;', '\t\tadj = new LinkedList[s];', '\t\tfor (int i = 0; i < s; ++i)', '\t\t\tadj[i] = new LinkedList();', '\tvoid addEdge(int s, int d) {', '\t\tadj[s].add(d);', '\t\tvisitedVertices[s] = true;', '\t\tSystem.out.print(s + "" "");', '\t\tint n;', '\t\twhile (i.hasNext()) {', '\t\t\tn = i.next();', '\t\t\tif (!visitedVertices[n])', '\tGraph Transpose() {', '\t\tGraph g = new Graph(V);', '\t\t\twhile (i.hasNext())', '\t\t\t\tg.adj[i.next()].add(s);', '\t\treturn g;', '\t\tvisitedVertices[s] = true;', '\t\twhile (i.hasNext()) {', '\t\t\tint n = i.next();', '\t\t\tif (!visitedVertices[n])', '\t\tstack.push(new Integer(s));', '\tvoid printSCC() {', '\t\tStack stack = new Stack();', '\t\tfor (int i = 0; i < V; i++)', '\t\t\tvisitedVertices[i] = false;', '\t\tfor (int i = 0; i < V; i++)', '\t\tGraph gr = Transpose();', '\t\tfor (int i = 0; i < V; i++)', '\t\t\tvisitedVertices[i] = false;', '\t\t\tint s = (int) stack.pop();', '\t\t\t\tSystem.out.println();', '\t\tGraph g = new Graph(8);', '\t\tg.addEdge(0, 1);', '\t\tg.addEdge(1, 2);', '\t\tg.addEdge(2, 3);', '\t\tg.addEdge(2, 4);', '\t\tg.addEdge(3, 0);', '\t\tg.addEdge(4, 5);', '\t\tg.addEdge(5, 6);', '\t\tg.addEdge(6, 4);', '\t\tg.addEdge(6, 7);', '\t\tg.printSCC();', '#include <iostream>', '#include <list>', '#include <stack>', 'using namespace std;', 'class Graph {', '  int V;', '  list<int> *adj;', '   public:', '  Graph(int V);', '  void addEdge(int s, int d);', '  void printSCC();', '  Graph transpose();', 'Graph::Graph(int V) {', '  this->V = V;', '  adj = new list<int>[V];', '  visitedV[s] = true;', '  cout << s << "" "";', '  list<int>::iterator i;', '    if (!visitedV[*i])', '      DFS(*i, visitedV);', 'Graph Graph::transpose() {', '  Graph g(V);', '    list<int>::iterator i;', '      g.adj[*i].push_back(s);', '  return g;', '  adj[s].push_back(d);', '  visitedV[s] = true;', '  list<int>::iterator i;', '    if (!visitedV[*i])', '  Stack.push(s);', 'void Graph::printSCC() {', '  stack<int> Stack;', '  for (int i = 0; i < V; i++)', '    visitedV[i] = false;', '  for (int i = 0; i < V; i++)', '    if (visitedV[i] == false)', '  Graph gr = transpose();', '  for (int i = 0; i < V; i++)', '    visitedV[i] = false;', '    int s = Stack.top();', '    Stack.pop();', '      gr.DFS(s, visitedV);', '      cout << endl;', 'int main() {', '  Graph g(8);', '  g.addEdge(0, 1);', '  g.addEdge(1, 2);', '  g.addEdge(2, 3);', '  g.addEdge(2, 4);', '  g.addEdge(3, 0);', '  g.addEdge(4, 5);', '  g.addEdge(5, 6);', '  g.addEdge(6, 4);', '  g.addEdge(6, 7);', '  g.printSCC();']","[""# Kosaraju's algorithm to find strongly connected components in Python"", 'from collections import defaultdict', '        self.graph = defaultdict(list)', '    def dfs(self, d, visited_vertex):', '        visited_vertex[d] = True', '            if not visited_vertex[i]:', '                self.dfs(i, visited_vertex)', '    def fill_order(self, d, visited_vertex, stack):', '        visited_vertex[d] = True', '            if not visited_vertex[i]:', '                self.fill_order(i, visited_vertex, stack)', '            for j in self.graph[i]:', '                g.add_edge(j, i)', '    # Print stongly connected components', '        visited_vertex = [False] * (self.V)', '            if not visited_vertex[i]:', '                self.fill_order(i, visited_vertex, stack)', '        visited_vertex = [False] * (self.V)', '            if not visited_vertex[i]:', '                gr.dfs(i, visited_vertex)', 'print(""Strongly Connected Components:"")', '\tprivate LinkedList<Integer> adj[];', '\tvoid DFSUtil(int s, boolean visitedVertices[]) {', '\t\tIterator<Integer> i = adj[s].iterator();', '\t\t\t\tDFSUtil(n, visitedVertices);', '\t\t\tIterator<Integer> i = adj[s].listIterator();', '\tvoid fillOrder(int s, boolean visitedVertices[], Stack stack) {', '\t\tIterator<Integer> i = adj[s].iterator();', '\t\t\t\tfillOrder(n, visitedVertices, stack);', '\t\tboolean visitedVertices[] = new boolean[V];', '\t\t\tif (visitedVertices[i] == false)', '\t\t\t\tfillOrder(i, visitedVertices, stack);', '\t\twhile (stack.empty() == false) {', '\t\t\tif (visitedVertices[s] == false) {', '\t\t\t\tgr.DFSUtil(s, visitedVertices);', '\tpublic static void main(String args[]) {', '\t\tSystem.out.println(""Strongly Connected Components:"");', '  void fillOrder(int s, bool visitedV[], stack<int> &Stack);', '  void DFS(int s, bool visitedV[]);', 'void Graph::DFS(int s, bool visitedV[]) {', '  for (i = adj[s].begin(); i != adj[s].end(); ++i)', '    for (i = adj[s].begin(); i != adj[s].end(); ++i) {', 'void Graph::addEdge(int s, int d) {', 'void Graph::fillOrder(int s, bool visitedV[], stack<int> &Stack) {', '  for (i = adj[s].begin(); i != adj[s].end(); ++i)', '      fillOrder(*i, visitedV, Stack);', '      fillOrder(i, visitedV, Stack);', '  while (Stack.empty() == false) {', '  cout << ""Strongly Connected Components:\\n"";']",[],[],"['Vehicle routing applications|||Maps|||Model-checking in formal verification|||&&&Perform a depth first search on the whole graph.|||Let us start from vertex-0, visit all of its child vertices, and mark the visited vertices as done. If a vertex leads to an already visited vertex, then push this vertex to the stack.|||For example: Starting from vertex-0, go to vertex-1, vertex-2, and then to vertex-3. Vertex-3 leads to already visited vertex-0, so push the source vertex (ie. vertex-3) into the stack.|||DFS on the graph|||Go to the previous vertex (vertex-2) and visit its child vertices i.e. vertex-4, vertex-5, vertex-6 and vertex-7 sequentially. Since there is nowhere to go from vertex-7, push it into the stack.|||DFS on the graph|||Go to the previous vertex (vertex-6) and visit its child vertices. But, all of its child vertices are visited, so push it into the stack.|||Stacking|||Similarly, a final stack is created.|||Final Stack|||Reverse the original graph.|||DFS on reversed graph|||Perform depth-first search on the reversed graph.|||Start from the top vertex of the stack. Traverse through all of its child vertices. Once the already visited vertex is reached, one strongly connected component is formed.|||For example: Pop vertex-0 from the stack. Starting from vertex-0, traverse through its child vertices (vertex-0, vertex-1, vertex-2, vertex-3 in sequence) and mark them as visited. The child of vertex-3 is already visited, so these visited vertices form one strongly connected component.|||Start from the top and traverse through all the vertices|||Go to the stack and pop the top vertex if already visited. Otherwise, choose the top vertex from the stack and traverse through its child vertices as presented above.|||Pop the top vertex if already visited|||\xa0||||||Strongly connected component|||Thus, the strongly connected components are:|||All strongly connected components|||']"
40,['Adjacency Matrix'],"['In this tutorial, you will learn what an adjacency matrix is. Also, you will find working examples of adjacency matrix in C, C++, Java and Python.']",[],[],"['Pros of Adjacency Matrix', 'Cons of Adjacency Matrix', 'Adjacency Matrix Code in Python, Java, and C/C++', 'Adjacency Matrix Applications']",[],"['//cdn.programiz.com/cdn/farfuture/D4ZDkt48bFeDTUG5iItf5AsHiZqU7YNCZnUBupDy3ns/mtime:1625029498/sites/tutorial2program/files/adjacency-matrix-graph.png', '//cdn.programiz.com/cdn/farfuture/SqnxMX0jM7bHMa6iXsjpbr5i3I0GSGDPHHtP2MnB9tg/mtime:1625113914/sites/tutorial2program/files/adjacency-matrix-representation_1.png']","['For example, we have a graph below.', 'We can represent this graph in matrix form like below.']","['If you know how to create two-dimensional arrays, you also know how to create an adjacency matrix.']","[""An adjacency matrix is a way of representing a graph as a matrix of booleans (0's and 1's). A finite graph can be represented in the form of a square matrix on a computer, where the boolean value of the matrix indicates if there is a direct path between two vertices."", 'Each cell in the above table/matrix is represented as Aij, where i and j are vertices. The value of Aij is either 1 or 0 depending on whether there is an edge from vertex i to vertex j.', 'If there is a path from i to j, then the value of Aij is 1 otherwise its 0. For instance, there is a path from vertex 1 to vertex 2, so A12 is 1 and there is no path from vertex 1 to 3, so A13 is 0.', 'In case of undirected graphs, the matrix is symmetric about the diagonal because of every edge (i,j), there is also an edge (j,i).']","['class Graph(object):', '    # Initialize the matrix', '    def __init__(self, size):', '        self.adjMatrix = []', '        for i in range(size):', '        self.size = size', '    # Add edges', '        if v1 == v2:', '    # Remove edges', '            return', '    def __len__(self):', '        return self.size', '    # Print the matrix', '    def print_matrix(self):', '            for val in row:', '            print', 'def main():', '    g = Graph(5)', '    g.add_edge(0, 1)', '    g.add_edge(0, 2)', '    g.add_edge(1, 2)', '    g.add_edge(2, 0)', '    g.add_edge(2, 3)', '    g.print_matrix()', ""if __name__ == '__main__':"", '    main()', 'public class Graph {', '  private int numVertices;', '    adjMatrix[i][j] = true;', '    adjMatrix[j][i] = true;', '    adjMatrix[i][j] = false;', '    adjMatrix[j][i] = false;', '  public String toString() {', '      s.append(i + "": "");', '      s.append(""\\n"");', '    return s.toString();', '    Graph g = new Graph(4);', '    g.addEdge(0, 1);', '    g.addEdge(0, 2);', '    g.addEdge(1, 2);', '    g.addEdge(2, 0);', '    g.addEdge(2, 3);', '#include <stdio.h>', '#define V 4', 'void init(int arr[][V]) {', '  int i, j;', '  for (i = 0; i < V; i++)', '    for (j = 0; j < V; j++)', '      arr[i][j] = 0;', '  arr[i][j] = 1;', '  arr[j][i] = 1;', '  int i, j;', '  for (i = 0; i < V; i++) {', '    printf(""%d: "", i);', '    for (j = 0; j < V; j++) {', '    printf(""\\n"");', 'int main() {', '  int adjMatrix[V][V];', '  init(adjMatrix);', '  addEdge(adjMatrix, 0, 1);', '  addEdge(adjMatrix, 0, 2);', '  addEdge(adjMatrix, 1, 2);', '  addEdge(adjMatrix, 2, 0);', '  addEdge(adjMatrix, 2, 3);', '  printAdjMatrix(adjMatrix);', '  return 0;', '#include <iostream>', 'using namespace std;', 'class Graph {', '   private:', '  bool** adjMatrix;', '  int numVertices;', '   public:', '  Graph(int numVertices) {', '  void addEdge(int i, int j) {', '    adjMatrix[i][j] = true;', '    adjMatrix[j][i] = true;', '    adjMatrix[i][j] = false;', '    adjMatrix[j][i] = false;', '  void toString() {', '      cout << i << "" : "";', '      cout << ""\\n"";', '  ~Graph() {', '      delete[] adjMatrix[i];', '    delete[] adjMatrix;', 'int main() {', '  Graph g(4);', '  g.addEdge(0, 1);', '  g.addEdge(0, 2);', '  g.addEdge(1, 2);', '  g.addEdge(2, 0);', '  g.addEdge(2, 3);', '  g.toString();']","['# Adjacency Matrix representation in Python', '            self.adjMatrix.append([0 for i in range(size)])', '            print(""Same vertex %d and %d"" % (v1, v2))', '        self.adjMatrix[v1][v2] = 1', '        self.adjMatrix[v2][v1] = 1', '    def remove_edge(self, v1, v2):', '        if self.adjMatrix[v1][v2] == 0:', '            print(""No edge between %d and %d"" % (v1, v2))', '        self.adjMatrix[v1][v2] = 0', '        self.adjMatrix[v2][v1] = 0', '        for row in self.adjMatrix:', ""                print('{:4}'.format(val)),"", '  private boolean adjMatrix[][];', '  public Graph(int numVertices) {', '    this.numVertices = numVertices;', '    adjMatrix = new boolean[numVertices][numVertices];', '  public void addEdge(int i, int j) {', '  public void removeEdge(int i, int j) {', '    StringBuilder s = new StringBuilder();', '    for (int i = 0; i < numVertices; i++) {', '      for (boolean j : adjMatrix[i]) {', '        s.append((j ? 1 : 0) + "" "");', '  public static void main(String args[]) {', '    System.out.print(g.toString());', 'void addEdge(int arr[][V], int i, int j) {', 'void printAdjMatrix(int arr[][V]) {', '    this->numVertices = numVertices;', '    adjMatrix = new bool*[numVertices];', '    for (int i = 0; i < numVertices; i++) {', '      adjMatrix[i] = new bool[numVertices];', '      for (int j = 0; j < numVertices; j++)', '        adjMatrix[i][j] = false;', '  void removeEdge(int i, int j) {', '    for (int i = 0; i < numVertices; i++) {', '      for (int j = 0; j < numVertices; j++)', '        cout << adjMatrix[i][j] << "" "";', '    for (int i = 0; i < numVertices; i++)']",[],[],"[""The basic operations like adding an edge, removing an edge, and checking whether there is an edge from vertex i to vertex j are extremely time efficient, constant time operations.|||If the graph is dense and the number of edges is large, an adjacency matrix should be the first choice. Even if the graph and the adjacency matrix is sparse, we can represent it using data structures for sparse matrices.|||The biggest advantage, however, comes from the use of matrices. The recent advances in hardware enable us to perform even expensive matrix operations on the GPU.|||By performing operations on the adjacent matrix, we can get important insights into the nature of the graph and the relationship between its vertices.|||The VxV space requirement of the adjacency matrix makes it a memory hog. Graphs out in the wild usually don't have too many connections and this is the major reason why adjacency lists are the better choice for most tasks.|||While basic operations are easy, operations like inEdges and outEdges are expensive when using the adjacency matrix representation.|||Creating routing table in networks|||Navigation tasks|||""]"
41,['Adjacency List'],"['In this tutorial, you will learn what an adjacency list is. Also, you will find working examples of adjacency list in C, C++, Java and Python.']",[],[],"['Pros of Adjacency List', 'Cons of Adjacency List', 'Adjacency List Structure', 'Adjacency List C++', 'Adjacency List Java', 'Adjacency List Python', 'Adjacency List Code in Python, Java, and C/C++', 'Applications of Adjacency List']",[],"['//cdn.programiz.com/cdn/farfuture/-p4ka0P4riQvs-VRZHACdhlc48nVN1iOYdZmkk8F2FA/mtime:1625029631/sites/tutorial2program/files/adjacency-list-graph.png', '//cdn.programiz.com/cdn/farfuture/h2DRie2qoBNmd2liy8DRj5TDcmODcVDBUZOyoPQ5AVM/mtime:1625029639/sites/tutorial2program/files/adjacency-list-representation.png']","['For example, we have a graph below.', ""Let's dig into the data structures at play here."", ""Don't let the struct node** adjLists overwhelm you."", 'We use Java Collections to store the Array of Linked Lists.']","['We can represent this graph in the form of a linked list on a computer as shown below.', 'The simplest adjacency list needs a node data structure to store a vertex and a graph data structure to organize the nodes.']","['An adjacency list represents a graph as an array of linked lists. The index of the array represents a vertex and each element in its linked list represents the other vertices that form an edge with the vertex.', 'Here, 0, 1, 2, 3 are the vertices and each of them forms a linked list with all of its adjacent vertices. For instance, vertex 1 has two adjacent vertices 0 and 2. Therefore, 1 is linked with 0 and 2 in the figure above.', 'We stay close to the basic definition of a graph - a collection of vertices and edges {V, E}. For simplicity, we use an unlabeled graph as opposed to a labeled one i.e. the vertices are identified by their indices 0,1,2,3.', ""All we are saying is we want to store a pointer to struct node*. This is because we don't know how many vertices the graph will have and so we cannot create an array of Linked Lists at compile time."", 'It is the same structure but by using the in-built list STL data structures of C++, we make the structure a bit cleaner. We are also able to abstract the details of the implementation.', 'The type of LinkedList is determined by what data you want to store in it. For a labeled graph, you could store a dictionary instead of an Integer', 'There is a reason Python gets so much love. A simple dictionary of vertices and its edges is a sufficient representation of a graph. You can make the vertex itself as complex as you want.']","['struct node{', '    int vertex;', '    struct node* next;', 'struct Graph{', '    int numVertices;', '    struct node** adjLists;', 'class Graph{', '    int numVertices;', '    list<int> *adjLists;', '  public:', '    Graph(int V);', 'class Graph{', '    private int numVertices;', ""graph = {'A': set(['B', 'C']),"", ""         'C': set(['A', 'F']),"", ""         'D': set(['B']),"", ""         'E': set(['B', 'F']),"", ""         'F': set(['C', 'E'])}"", 'class AdjNode:', '    def __init__(self, value):', '        self.vertex = value', '        self.next = None', 'class Graph:', '    def __init__(self, num):', '        self.V = num', '    # Add edges', '    def add_edge(self, s, d):', '        node = AdjNode(d)', '        self.graph[s] = node', '        node = AdjNode(s)', '        self.graph[d] = node', '    # Print the graph', '    def print_agraph(self):', '            while temp:', '            print("" \\n"")', 'if __name__ == ""__main__"":', '    V = 5', '    # Create graph and edges', '    graph = Graph(V)', '    graph.add_edge(0, 1)', '    graph.add_edge(0, 2)', '    graph.add_edge(0, 3)', '    graph.add_edge(1, 2)', '    graph.print_agraph()', 'import java.util.*;', 'class Graph {', '    am.get(s).add(d);', '    am.get(d).add(s);', '    int V = 5;', '    addEdge(am, 0, 1);', '    addEdge(am, 0, 2);', '    addEdge(am, 0, 3);', '    addEdge(am, 1, 2);', '    printGraph(am);', '      System.out.println();', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int vertex;', '  struct node* next;', 'struct node* createNode(int);', 'struct Graph {', '  int numVertices;', '  struct node** adjLists;', '  newNode->vertex = v;', '  newNode->next = NULL;', '  return newNode;', '  int i;', '    graph->adjLists[i] = NULL;', '  return graph;', '  newNode = createNode(s);', '  int v;', '    while (temp) {', '      temp = temp->next;', '    printf(""\\n"");', 'int main() {', '  addEdge(graph, 0, 1);', '  addEdge(graph, 0, 2);', '  addEdge(graph, 0, 3);', '  addEdge(graph, 1, 2);', '  printGraph(graph);', '  return 0;', '#include <bits/stdc++.h>', 'using namespace std;', '  adj[s].push_back(d);', '  adj[d].push_back(s);', '    cout << ""\\n Vertex ""', '       << d << "":"";', '    for (auto x : adj[d])', '      cout << ""-> "" << x;', '    printf(""\\n"");', 'int main() {', '  int V = 5;', '  vector<int> adj[V];', '  addEdge(adj, 0, 1);', '  addEdge(adj, 0, 2);', '  addEdge(adj, 0, 3);', '  addEdge(adj, 1, 2);', '  printGraph(adj, V);']","['    void addEdge(int src, int dest);', '    private LinkedList<integer> adjLists[];', ""         'B': set(['A', 'D', 'E']),"", '# Adjascency List representation in Python', '        self.graph = [None] * self.V', '        node.next = self.graph[s]', '        node.next = self.graph[d]', '            print(""Vertex "" + str(i) + "":"", end="""")', '            temp = self.graph[i]', '                print("" -> {}"".format(temp.vertex), end="""")', '                temp = temp.next', '  static void addEdge(ArrayList<ArrayList<Integer>> am, int s, int d) {', '  public static void main(String[] args) {', '    ArrayList<ArrayList<Integer>> am = new ArrayList<ArrayList<Integer>>(V);', '      am.add(new ArrayList<Integer>());', '  static void printGraph(ArrayList<ArrayList<Integer>> am) {', '    for (int i = 0; i < am.size(); i++) {', '      System.out.println(""\\nVertex "" + i + "":"");', '      for (int j = 0; j < am.get(i).size(); j++) {', '        System.out.print("" -> "" + am.get(i).get(j));', 'struct node* createNode(int v) {', '  struct node* newNode = malloc(sizeof(struct node));', 'struct Graph* createAGraph(int vertices) {', '  struct Graph* graph = malloc(sizeof(struct Graph));', '  graph->numVertices = vertices;', '  graph->adjLists = malloc(vertices * sizeof(struct node*));', '  for (i = 0; i < vertices; i++)', 'void addEdge(struct Graph* graph, int s, int d) {', '  struct node* newNode = createNode(d);', '  newNode->next = graph->adjLists[s];', '  newNode->next = graph->adjLists[d];', 'void printGraph(struct Graph* graph) {', '  for (v = 0; v < graph->numVertices; v++) {', '    struct node* temp = graph->adjLists[v];', '    printf(""\\n Vertex %d\\n: "", v);', '      printf(""%d -> "", temp->vertex);', '  struct Graph* graph = createAGraph(4);', 'void addEdge(vector<int> adj[], int s, int d) {', 'void printGraph(vector<int> adj[], int V) {']",[],[],"['An adjacency list is efficient in terms of storage because we only need to store the values for the edges. For a sparse graph with millions of vertices and edges, this can mean a lot of saved space.|||It also helps to find all the vertices adjacent to a vertex easily.|||Finding the adjacent list is not quicker than the adjacency matrix because all the connected nodes must be first explored to find them.|||It is faster to use adjacency lists for graphs having less number of edges.|||']"
42,['Depth First Search (DFS)'],"['In this tutorial, you will learn about depth first search algorithm with examples and pseudocode. Also, you will learn to implement DFS in C, Java, Python, and C++.']",[],[],"['Depth First Search Algorithm', 'Depth First Search Example', 'DFS Pseudocode (recursive implementation)', 'DFS Implementation in Python, Java and C/C++', 'Complexity of Depth First Search', 'Application of DFS Algorithm']",[],"['//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-0.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-1.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-2.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-3.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-4.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-5.png']","['The DFS algorithm works as follows:', 'The space complexity of the algorithm is O(V).']","['A standard DFS implementation puts each vertex of the graph into one of two categories:', 'The purpose of the algorithm is to mark each vertex as visited while avoiding cycles.', ""Let's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices."", 'Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.']","['Depth first Search or Depth first traversal is a recursive algorithm for searching all the vertices of a graph or tree data structure. Traversal means visiting all the nodes of a graph.', 'We start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.', 'Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.', ""After we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph."", 'The pseudocode for DFS is shown below. In the init() function, notice that we run the DFS function on every node. This is because the graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the DFS algorithm on every node.', 'The code for the Depth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.', 'The time complexity of the DFS algorithm is represented in the form of O(V + E), where V is the number of nodes and E is the number of edges.']","['# DFS algorithm in Python', '# DFS algorithm', '    if visited is None:', '        visited = set()', '    visited.add(start)', '    print(start)', '    return visited', ""graph = {'0': set(['1', '2']),"", ""         '2': set(['0']),"", ""         '3': set(['1']),"", ""         '4': set(['2', '3'])}"", ""dfs(graph, '0')"", 'import java.util.*;', 'class Graph {', '  private boolean visited[];', '  Graph(int vertices) {', '    adjLists[src].add(dest);', '  void DFS(int vertex) {', '    visited[vertex] = true;', '    while (ite.hasNext()) {', '      int adj = ite.next();', '      if (!visited[adj])', '        DFS(adj);', '    Graph g = new Graph(4);', '    g.addEdge(0, 1);', '    g.addEdge(0, 2);', '    g.addEdge(1, 2);', '    g.addEdge(2, 3);', '    g.DFS(2);', '#include <stdio.h>', '#include <stdlib.h>', 'struct node {', '  int vertex;', '  struct node* next;', 'struct Graph {', '  int numVertices;', '  int* visited;', '  struct node** adjLists;', '  struct node* temp = adjList;', '  graph->visited[vertex] = 1;', '  while (temp != NULL) {', '    temp = temp->next;', '  newNode->vertex = v;', '  newNode->next = NULL;', '  return newNode;', '  int i;', '    graph->adjLists[i] = NULL;', '    graph->visited[i] = 0;', '  return graph;', '  newNode = createNode(src);', '  int v;', '    while (temp) {', '      temp = temp->next;', '    printf(""\\n"");', 'int main() {', '  addEdge(graph, 0, 1);', '  addEdge(graph, 0, 2);', '  addEdge(graph, 1, 2);', '  addEdge(graph, 2, 3);', '  printGraph(graph);', '  DFS(graph, 2);', '  return 0;', '#include <iostream>', '#include <list>', 'using namespace std;', 'class Graph {', '  int numVertices;', '  list<int> *adjLists;', '  bool *visited;', '   public:', '  Graph(int V);', '  void DFS(int vertex);', 'Graph::Graph(int vertices) {', '  numVertices = vertices;', 'void Graph::DFS(int vertex) {', '  visited[vertex] = true;', '  cout << vertex << "" "";', '  list<int>::iterator i;', '    if (!visited[*i])', '      DFS(*i);', 'int main() {', '  Graph g(4);', '  g.addEdge(0, 1);', '  g.addEdge(0, 2);', '  g.addEdge(1, 2);', '  g.addEdge(2, 3);', '  g.DFS(2);', '  return 0;']","['def dfs(graph, start, visited=None):', '    for next in graph[start] - visited:', '        dfs(graph, next, visited)', ""         '1': set(['0', '3', '4']),"", '  private LinkedList<Integer> adjLists[];', '    adjLists = new LinkedList[vertices];', '    visited = new boolean[vertices];', '    for (int i = 0; i < vertices; i++)', '      adjLists[i] = new LinkedList<Integer>();', '  void addEdge(int src, int dest) {', '    System.out.print(vertex + "" "");', '    Iterator<Integer> ite = adjLists[vertex].listIterator();', '  public static void main(String args[]) {', '    System.out.println(""Following is Depth First Traversal"");', 'void DFS(struct Graph* graph, int vertex) {', '  struct node* adjList = graph->adjLists[vertex];', '  printf(""Visited %d \\n"", vertex);', '    int connectedVertex = temp->vertex;', '    if (graph->visited[connectedVertex] == 0) {', '      DFS(graph, connectedVertex);', 'struct node* createNode(int v) {', '  struct node* newNode = malloc(sizeof(struct node));', 'struct Graph* createGraph(int vertices) {', '  struct Graph* graph = malloc(sizeof(struct Graph));', '  graph->numVertices = vertices;', '  graph->adjLists = malloc(vertices * sizeof(struct node*));', '  graph->visited = malloc(vertices * sizeof(int));', '  for (i = 0; i < vertices; i++) {', 'void addEdge(struct Graph* graph, int src, int dest) {', '  struct node* newNode = createNode(dest);', '  newNode->next = graph->adjLists[src];', '  graph->adjLists[src] = newNode;', '  newNode->next = graph->adjLists[dest];', '  graph->adjLists[dest] = newNode;', 'void printGraph(struct Graph* graph) {', '  for (v = 0; v < graph->numVertices; v++) {', '    struct node* temp = graph->adjLists[v];', '    printf(""\\n Adjacency list of vertex %d\\n "", v);', '      printf(""%d -> "", temp->vertex);', '  struct Graph* graph = createGraph(4);', '  void addEdge(int src, int dest);', '  adjLists = new list<int>[vertices];', 'void Graph::addEdge(int src, int dest) {', '  adjLists[src].push_front(dest);', '  list<int> adjList = adjLists[vertex];', '  for (i = adjList.begin(); i != adjList.end(); ++i)']","['DFS(G, u)', '    u.visited = true', '    for each v ∈ G.Adj[u]', '        if v.visited == false', '            DFS(G,v)', '     ', 'init() {', '    For each u ∈ G', '        u.visited = false', '     For each u ∈ G', '       DFS(G, u)', '}']",[],"[""Visited|||Not Visited|||Start by putting any one of the graph's vertices on top of a stack.|||Take the top item of the stack and add it to the visited list.|||Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.|||Keep repeating steps 2 and 3 until the stack is empty.|||For finding the path|||To test if the graph is bipartite|||For finding the strongly connected components of a graph|||For detecting cycles in a graph|||""]"
43,['Breadth first search'],"['In this tutorial, you will learn about breadth first search algorithm. Also, you will find working examples of bfs algorithm in C, C++, Java and Python.']",[],[],"['BFS algorithm', 'BFS example', 'BFS pseudocode', 'Python, Java and C/C++ Examples', 'BFS Algorithm Complexity', 'BFS Algorithm Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-0.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-1.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-2_2.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-3.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-4.png', '//cdn.programiz.com/sites/tutorial2program/files/graph-bfs-step-5.png']","['The algorithm works as follows:', 'The space complexity of the algorithm is O(V).']","['A standard BFS implementation puts each vertex of the graph into one of two categories:', 'The purpose of the algorithm is to mark each vertex as visited while avoiding cycles.', ""Let's see how the Breadth First Search algorithm works with an example. We use an undirected graph with 5 vertices."", 'Only 4 remains in the queue since the only adjacent node of 3 i.e. 0 is already visited. We visit it.', 'Since the queue is empty, we have completed the Breadth First Traversal of the graph.']","['Traversal means visiting all the nodes of a graph. Breadth First Traversal or Breadth First Search is a recursive algorithm for searching all the vertices of a graph or tree data structure.', 'The graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the BFS algorithm on every node', 'We start from vertex 0, the BFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.', 'Next, we visit the element at the front of queue i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.', 'Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the back of the queue and visit 3, which is at the front of the queue.', 'The code for the Breadth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.', 'The time complexity of the BFS algorithm is represented in the form of O(V + E), where V is the number of nodes and E is the number of edges.']","['# BFS algorithm in Python', 'import collections', '# BFS algorithm', 'def bfs(graph, root):', '    visited.add(root)', '    while queue:', '        # enqueue it', ""if __name__ == '__main__':"", '    bfs(graph, 0)', 'import java.util.*;', 'public class Graph {', '  private int V;', '  Graph(int v) {', '    V = v;', '    adj = new LinkedList[v];', '  void addEdge(int v, int w) {', '    adj[v].add(w);', '  void BFS(int s) {', '    visited[s] = true;', '    queue.add(s);', '      s = queue.poll();', '      while (i.hasNext()) {', '        int n = i.next();', '        if (!visited[n]) {', '          visited[n] = true;', '          queue.add(n);', '        }', '    Graph g = new Graph(4);', '    g.addEdge(0, 1);', '    g.addEdge(0, 2);', '    g.addEdge(1, 2);', '    g.addEdge(2, 0);', '    g.addEdge(2, 3);', '    g.addEdge(3, 3);', '    g.BFS(2);', '#include <stdio.h>', '#include <stdlib.h>', '#define SIZE 40', 'struct queue {', '  int items[SIZE];', '  int front;', '  int rear;', 'struct queue* createQueue();', 'int dequeue(struct queue* q);', 'void display(struct queue* q);', 'int isEmpty(struct queue* q);', 'struct node {', '  int vertex;', '  struct node* next;', 'struct node* createNode(int);', 'struct Graph {', '  int numVertices;', '  struct node** adjLists;', '  int* visited;', '  enqueue(q, startVertex);', '  while (!isEmpty(q)) {', '    printQueue(q);', '    while (temp) {', '        enqueue(q, adjVertex);', '      temp = temp->next;', '  newNode->vertex = v;', '  newNode->next = NULL;', '  return newNode;', '  int i;', '    graph->adjLists[i] = NULL;', '    graph->visited[i] = 0;', '  return graph;', '  newNode = createNode(src);', 'struct queue* createQueue() {', '  q->front = -1;', '  q->rear = -1;', '  return q;', 'int isEmpty(struct queue* q) {', '  if (q->rear == -1)', '    return 1;', '    return 0;', '  if (q->rear == SIZE - 1)', '  else {', '    if (q->front == -1)', '      q->front = 0;', '    q->rear++;', '    q->items[q->rear] = value;', 'int dequeue(struct queue* q) {', '  int item;', '  if (isEmpty(q)) {', '    printf(""Queue is empty"");', '    item = -1;', '  } else {', '    item = q->items[q->front];', '    q->front++;', '    if (q->front > q->rear) {', '      q->front = q->rear = -1;', '  return item;', '  int i = q->front;', '  if (isEmpty(q)) {', '    printf(""Queue is empty"");', '  } else {', 'int main() {', '  addEdge(graph, 0, 1);', '  addEdge(graph, 0, 2);', '  addEdge(graph, 1, 2);', '  addEdge(graph, 1, 4);', '  addEdge(graph, 1, 3);', '  addEdge(graph, 2, 4);', '  addEdge(graph, 3, 4);', '  bfs(graph, 0);', '  return 0;', '#include <iostream>', '#include <list>', 'using namespace std;', 'class Graph {', '  int numVertices;', '  list<int>* adjLists;', '  bool* visited;', '   public:', '  Graph(int vertices);', '  void BFS(int startVertex);', 'Graph::Graph(int vertices) {', '  numVertices = vertices;', '    visited[i] = false;', '  list<int> queue;', '  visited[startVertex] = true;', '  list<int>::iterator i;', '  while (!queue.empty()) {', '    queue.pop_front();', '      int adjVertex = *i;', 'int main() {', '  Graph g(4);', '  g.addEdge(0, 1);', '  g.addEdge(0, 2);', '  g.addEdge(1, 2);', '  g.addEdge(2, 0);', '  g.addEdge(2, 3);', '  g.addEdge(3, 3);', '  g.BFS(2);', '  return 0;']","['    visited, queue = set(), collections.deque([root])', '        # Dequeue a vertex from queue', '        vertex = queue.popleft()', '        print(str(vertex) + "" "", end="""")', '        # If not visited, mark it as visited, and', '        for neighbour in graph[vertex]:', '            if neighbour not in visited:', '                visited.add(neighbour)', '                queue.append(neighbour)', '    graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}', '    print(""Following is Breadth First Traversal: "")', '  private LinkedList<Integer> adj[];', '      adj[i] = new LinkedList();', '    boolean visited[] = new boolean[V];', '    LinkedList<Integer> queue = new LinkedList();', '      System.out.print(s + "" "");', '      Iterator<Integer> i = adj[s].listIterator();', '  public static void main(String args[]) {', '    System.out.println(""Following is Breadth First Traversal "" + ""(starting from vertex 2)"");', 'void enqueue(struct queue* q, int);', 'void printQueue(struct queue* q);', 'void bfs(struct Graph* graph, int startVertex) {', '  struct queue* q = createQueue();', '  graph->visited[startVertex] = 1;', '    int currentVertex = dequeue(q);', '    printf(""Visited %d\\n"", currentVertex);', '    struct node* temp = graph->adjLists[currentVertex];', '      int adjVertex = temp->vertex;', '      if (graph->visited[adjVertex] == 0) {', '        graph->visited[adjVertex] = 1;', 'struct node* createNode(int v) {', '  struct node* newNode = malloc(sizeof(struct node));', 'struct Graph* createGraph(int vertices) {', '  struct Graph* graph = malloc(sizeof(struct Graph));', '  graph->numVertices = vertices;', '  graph->adjLists = malloc(vertices * sizeof(struct node*));', '  graph->visited = malloc(vertices * sizeof(int));', '  for (i = 0; i < vertices; i++) {', 'void addEdge(struct Graph* graph, int src, int dest) {', '  struct node* newNode = createNode(dest);', '  newNode->next = graph->adjLists[src];', '  graph->adjLists[src] = newNode;', '  newNode->next = graph->adjLists[dest];', '  graph->adjLists[dest] = newNode;', '  struct queue* q = malloc(sizeof(struct queue));', 'void enqueue(struct queue* q, int value) {', '    printf(""\\nQueue is Full!!"");', '      printf(""Resetting queue "");', 'void printQueue(struct queue* q) {', '    printf(""\\nQueue contains \\n"");', '    for (i = q->front; i < q->rear + 1; i++) {', '      printf(""%d "", q->items[i]);', '  struct Graph* graph = createGraph(6);', '  void addEdge(int src, int dest);', '  adjLists = new list<int>[vertices];', 'void Graph::addEdge(int src, int dest) {', '  adjLists[src].push_back(dest);', '  adjLists[dest].push_back(src);', 'void Graph::BFS(int startVertex) {', '  visited = new bool[numVertices];', '  for (int i = 0; i < numVertices; i++)', '    int currVertex = queue.front();', '    cout << ""Visited "" << currVertex << "" "";', '    for (i = adjLists[currVertex].begin(); i != adjLists[currVertex].end(); ++i) {', '      if (!visited[adjVertex]) {', '        visited[adjVertex] = true;', '        queue.push_back(adjVertex);']","['create a queue Q ', 'mark v as visited and put v into Q ', 'while Q is non-empty ', '    remove the head u of Q ', '    mark and enqueue all (unvisited) neighbours of u']",[],"[""Visited|||Not Visited|||Start by putting any one of the graph's vertices at the back of a queue.|||Take the front item of the queue and add it to the visited list.|||Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the back of the queue.|||Keep repeating steps 2 and 3 until the queue is empty.|||To build\xa0index by search index|||For GPS navigation|||Path finding algorithms|||In Ford-Fulkerson algorithm to find maximum flow in a network|||Cycle detection in an undirected graph|||In minimum spanning tree|||""]"
44,"[""Bellman Ford's Algorithm""]",['Bellman Ford algorithm helps us find the shortest path from a vertex to all other vertices of a weighted graph.'],[],[],"['Why would one ever have edges with negative weights in real life?', 'Why do we need to be careful with negative weights?', ""How Bellman Ford's algorithm works"", 'Bellman Ford Pseudocode', 'Bellman Ford vs Dijkstra', 'Python, Java and C/C++ Examples', ""Bellman Ford's Complexity"", ""Bellman Ford's Algorithm Applications""]","['Time Complexity', 'Space Complexity']","['//cdn.programiz.com/sites/tutorial2program/files/negative-weight-cycle_1.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-1.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-2.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-3.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-4.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-5.png', '//cdn.programiz.com/sites/tutorial2program/files/Bellman-Ford-Algorithm-6.png', '//cdn.programiz.com/sites/tutorial2program/files/bellman-ford-vs-dijkstra.jpg']","['And, the space complexity is O(V).']","[""It is similar to Dijkstra's algorithm but it can work with graphs in which edges can have negative weights."", 'By doing this repeatedly for all vertices, we can guarantee that the result is optimized.', 'Once the algorithm is over, we can backtrack from the destination vertex to the source vertex to find the path.']","['Negative weight edges might seem useless at first but they can explain a lot of phenomena like cashflow, the heat released/absorbed in a chemical reaction, etc.', 'For instance, if there are different ways to reach from one chemical A to another chemical B, each method will have sub-reactions involving both heat dissipation and absorption.', 'If we want to find the set of reactions where minimum energy is required, then we will need to be able to factor in the heat absorption as negative weights and heat dissipation as positive weights.', 'Negative weight edges can create negative weight cycles i.e. a cycle that will reduce the total path distance by coming back to the same point.', ""Shortest path algorithms like Dijkstra's Algorithm that aren't able to detect such a cycle can give an incorrect result because they can go through a negative weight cycle and reduce the path length."", 'Bellman Ford algorithm works by overestimating the length of the path from the starting vertex to all other vertices. Then it iteratively relaxes those estimates by finding new paths that are shorter than the previously overestimated paths.', 'We need to maintain the path distance of every vertex. We can store that in an array of size v, where v is the number of vertices.', 'We also want to be able to get the shortest path, not only know the length of the shortest path. For this, we map each vertex to the vertex that last updated its path length.', ""Bellman Ford's algorithm and Dijkstra's algorithm are very similar in structure. While Dijkstra looks only to the immediate neighbors of a vertex, Bellman goes through each edge in every iteration.""]","['class Graph:', '    # Add edges', '    # Print the solution', '        dist[src] = 0', '                return', 'g = Graph(5)', 'g.add_edge(0, 1, 5)', 'g.add_edge(0, 2, 4)', 'g.add_edge(1, 3, 3)', 'g.add_edge(2, 1, 6)', 'g.add_edge(3, 2, 2)', 'g.bellman_ford(0)', 'class CreateGraph {', '  class CreateEdge {', '    int s, d, w;', '    CreateEdge() {', '      s = d = w = 0;', '  int V, E;', '  CreateEdge edge[];', '  CreateGraph(int v, int e) {', '    V = v;', '    E = e;', '    edge = new CreateEdge[e];', '    int dist[] = new int[V];', '    dist[s] = 0;', '      int u = graph.edge[j].s;', '      int v = graph.edge[j].d;', '      int w = graph.edge[j].w;', '        return;', '    printSolution(dist, V);', '    int E = 8; // Total Edges', '    graph.edge[0].s = 0;', '    graph.edge[0].d = 1;', '    graph.edge[0].w = 5;', '    graph.edge[1].s = 0;', '    graph.edge[1].d = 2;', '    graph.edge[1].w = 4;', '    graph.edge[2].s = 1;', '    graph.edge[2].d = 3;', '    graph.edge[2].w = 3;', '    graph.edge[3].s = 2;', '    graph.edge[3].d = 1;', '    graph.edge[3].w = 6;', '    graph.edge[4].s = 3;', '    graph.edge[4].d = 2;', '    graph.edge[4].w = 2;', '#include <stdio.h>', '#include <stdlib.h>', '#define INFINITY 99999', 'struct Edge {', 'struct Graph {', 'int main(void) {', '  g->V = 4;  //total vertices', '  g->E = 5;  //total edges', '\t\tedge(u, v)', '  g->edge[0].u = 0;', '  g->edge[0].v = 1;', '  g->edge[0].w = 5;', '  g->edge[1].u = 0;', '  g->edge[1].v = 2;', '  g->edge[1].w = 4;', '  g->edge[2].u = 1;', '  g->edge[2].v = 3;', '  g->edge[2].w = 3;', '  g->edge[3].u = 2;', '  g->edge[3].v = 1;', '  g->edge[3].w = 6;', '  g->edge[4].u = 3;', '  g->edge[4].v = 2;', '  g->edge[4].w = 2;', '  return 0;', '  int i, j, u, v, w;', '  int tV = g->V;', '  int tE = g->E;', '  int d[tV];', '  int p[tV];', '  for (i = 0; i < tV; i++) {', '    d[i] = INFINITY;', '    p[i] = 0;', '  d[source] = 0;', '    for (j = 0; j < tE; j++) {', '      u = g->edge[j].u;', '      v = g->edge[j].v;', '      w = g->edge[j].w;', '        d[v] = d[u] + w;', '        p[v] = u;', '  for (i = 0; i < tE; i++) {', '    u = g->edge[i].u;', '    v = g->edge[i].v;', '    w = g->edge[i].w;', '      return;', '  printf(""Distance array: "");', '  display(d, tV);', '  display(p, tV);', '  int i;', '  for (i = 0; i < size; i++) {', '    printf(""%d "", arr[i]);', '  printf(""\\n"");', '#include <bits/stdc++.h>', 'struct Edge {', 'struct Graph {', '  graph->edge = new Edge[E];', '  return graph;', '  int i;', '  for (i = 0; i < size; i++) {', '    printf(""%d "", arr[i]);', '  printf(""\\n"");', '  int V = graph->V;', '  int E = graph->E;', '  int dist[V];', '  for (int i = 0; i < V; i++)', '    dist[i] = INT_MAX;', '  dist[u] = 0;', '        dist[v] = dist[u] + w;', '    int u = graph->edge[i].u;', '    int v = graph->edge[i].v;', '    int w = graph->edge[i].w;', '      return;', '  printArr(dist, V);', '  return;', 'int main() {', '  int E = 8;  // Total edges', '\t\tedge(u, v)', '  graph->edge[0].u = 0;', '  graph->edge[0].v = 1;', '  graph->edge[0].w = 5;', '  graph->edge[1].u = 0;', '  graph->edge[1].v = 2;', '  graph->edge[1].w = 4;', '  graph->edge[2].u = 1;', '  graph->edge[2].v = 3;', '  graph->edge[2].w = 3;', '  graph->edge[3].u = 2;', '  graph->edge[3].v = 1;', '  graph->edge[3].w = 6;', '  graph->edge[4].u = 3;', '  graph->edge[4].v = 2;', '  graph->edge[4].w = 2;', '  return 0;']","['# Bellman Ford Algorithm in Python', '    def __init__(self, vertices):', '        self.V = vertices   # Total number of vertices in the graph', '        self.graph = []     # Array of edges', '    def add_edge(self, s, d, w):', '        self.graph.append([s, d, w])', '    def print_solution(self, dist):', '        print(""Vertex Distance from Source"")', '            print(""{0}\\t\\t{1}"".format(i, dist[i]))', '    def bellman_ford(self, src):', '        # Step 1: fill the distance array and predecessor array', '        dist = [float(""Inf"")] * self.V', '        # Mark the source vertex', '        # Step 2: relax edges |V| - 1 times', '        for _ in range(self.V - 1):', '            for s, d, w in self.graph:', '                if dist[s] != float(""Inf"") and dist[s] + w < dist[d]:', '                    dist[d] = dist[s] + w', '        # Step 3: detect negative cycle', '        # if value changes then we have a negative cycle in the graph', '        # and we cannot find the shortest distances', '        for s, d, w in self.graph:', '            if dist[s] != float(""Inf"") and dist[s] + w < dist[d]:', '                print(""Graph contains negative weight cycle"")', '        # No negative weight cycle found!', '        # Print the distance and predecessor array', '        self.print_solution(dist)', '      edge[i] = new CreateEdge();', '  void BellmanFord(CreateGraph graph, int s) {', '    int V = graph.V, E = graph.E;', '      dist[i] = Integer.MAX_VALUE;', '    for (int i = 1; i < V; ++i) {', '      for (int j = 0; j < E; ++j) {', '        int u = graph.edge[j].s;', '        int v = graph.edge[j].d;', '        int w = graph.edge[j].w;', '        if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v])', '          dist[v] = dist[u] + w;', '    for (int j = 0; j < E; ++j) {', '      if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {', '        System.out.println(""CreateGraph contains negative w cycle"");', '  void printSolution(int dist[], int V) {', '    System.out.println(""Vertex Distance from Source"");', '      System.out.println(i + ""\\t\\t"" + dist[i]);', '  public static void main(String[] args) {', '    int V = 5; // Total vertices', '    CreateGraph graph = new CreateGraph(V, E);', '    graph.BellmanFord(graph, 0); // 0 is the source vertex', '  int u;  //start vertex of the edge', '  int v;  //end vertex of the edge', '  int w;  //weight of the edge (u,v)', '  int V;        //total number of vertices in the graph', '  int E;        //total number of edges in the graph', '  struct Edge *edge;  //array of edges', 'void bellmanford(struct Graph *g, int source);', 'void display(int arr[], int size);', '  struct Graph *g = (struct Graph *)malloc(sizeof(struct Graph));', '  g->edge = (struct Edge *)malloc(g->E * sizeof(struct Edge));', '\t\twhere \tu = start vertex of the edge (u,v)', '\t\t\t\tv = end vertex of the edge (u,v)', '\t\tw is the weight of the edge (u,v)', '  bellmanford(g, 0);  //0 is the source vertex', 'void bellmanford(struct Graph *g, int source) {', '  for (i = 1; i <= tV - 1; i++) {', '      if (d[u] != INFINITY && d[v] > d[u] + w) {', '    if (d[u] != INFINITY && d[v] > d[u] + w) {', '      printf(""Negative weight cycle detected!\\n"");', '  printf(""Predecessor array: "");', 'void display(int arr[], int size) {', '  int u;  //start vertex of the edge', '  int v;  //end vertex of the edge', '  int V;        // Total number of vertices in the graph', '  int E;        // Total number of edges in the graph', '  struct Edge* edge;  // Array of edges', 'struct Graph* createGraph(int V, int E) {', '  struct Graph* graph = new Graph;', '  graph->V = V;  // Total Vertices', 'void printArr(int arr[], int size) {', 'void BellmanFord(struct Graph* graph, int u) {', '  for (int i = 1; i <= V - 1; i++) {', '    for (int j = 0; j < E; j++) {', '      if (dist[u] != INT_MAX && dist[u] + w < dist[v])', '    if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {', '      printf(""Graph contains negative w cycle"");', '  struct Graph* graph = createGraph(V, E);', '\t\twhere \tu = start vertex of the edge (u,v)', '\t\t\t\tv = end vertex of the edge (u,v)', '\t\tw is the weight of the edge (u,v)', '  BellmanFord(graph, 0);  //0 is the source vertex']","['function bellmanFord(G, S)', '  for each vertex V in G', '    distance[V] <- infinite', '      previous[V] <- NULL', '  distance[S] <- 0', '  for each vertex V in G\t\t\t\t', '    for each edge (U,V) in G', '      tempDistance <- distance[U] + edge_weight(U, V)', '      if tempDistance < distance[V]', '        distance[V] <- tempDistance', '        previous[V] <- U', '  for each edge (U,V) in G', '    If distance[U] + edge_weight(U, V) < distance[V}', '      Error: Negative Cycle Exists', '  return distance[], previous[]']",['est Case Complexity|||O(E)&&&verage Case Complexity|||O(VE)&&&orst Case Complexity|||O(VE)'],['For calculating shortest paths in routing algorithms|||For finding the shortest path|||']
45,['Bubble Sort'],"['In this tutorial, you will learn about the bubble sort algorithm and its implementation in Python, Java,  C, and C++.']",[],[],"['Working of Bubble Sort', 'Bubble Sort Algorithm', 'Bubble Sort Code in Python, Java and C/C++', 'Optimized Bubble Sort Algorithm', 'Optimized Bubble Sort in Python, Java, and C/C++', 'Bubble Sort Complexity', 'Bubble Sort Applications', 'Similar Sorting Algorithms']","['Complexity in Detail', '1. Time Complexities', '2. Space Complexity']","['//cdn.programiz.com/cdn/farfuture/kn1zM7ZGIj60jcTe3mv8gAtbrvFHqxgqfQ7F9MdjPuA/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-0.png', '//cdn.programiz.com/cdn/farfuture/LzbPYkOXS-DjqwLqtIrixMZCD1XLdU-JWWedrL1YIpw/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-1.png', '//cdn.programiz.com/cdn/farfuture/-C5A9EpPrCAwR2TFQlZhG0uy5aSKmq-ewMaWyXp8_a8/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-2.png', '//cdn.programiz.com/cdn/farfuture/NnXQeMGuMJnIH0qzC1C5n7r4FOynP9vu3cWEdCK5Qjk/mtime:1582112622/sites/tutorial2program/files/Bubble-sort-3.png']","['Suppose we are trying to sort the elements in ascending order.', '1. First Iteration (Compare and Swap)', '2. Remaining Iteration', 'The same process goes on for the remaining iterations.', 'This increases the execution time.', 'Algorithm for optimized bubble sort is', 'Bubble Sort compares the adjacent elements.', 'Hence, the number of comparisons is', 'nearly equals to n2', 'Hence, Complexity: O(n2)', 'Bubble sort is used if']","['After each iteration, the largest element among the unsorted elements is placed at the end.', 'In each iteration, the comparison takes place up to the last unsorted element.', 'The array is sorted when all the unsorted elements are placed at their correct positions.', 'In the above algorithm, all the comparisons are made even if the array is already sorted.', 'This will reduce the execution time and helps to optimize the bubble sort.', 'Also, if we\xa0observe the code, bubble sort requires two loops. Hence, the complexity is n*n = n2']","['Just like the movement of air bubbles in the water that rise up to the surface, each element of the array move to the end in each iteration. Therefore, it is called a bubble sort.', 'To solve this, we can introduce an extra variable swapped. The value of swapped is set true if there occurs swapping of elements. Otherwise, it is set false.', 'After an iteration, if there is no swapping, the value of swapped will be false. This means elements are already sorted and there is no need to perform further iterations.']","['bubbleSort(array)', 'end bubbleSort', '# Bubble sort in Python', 'def bubbleSort(array):', '  for i in range(len(array)):', '        temp = array[j]', '        array[j] = array[j+1]', '        array[j+1] = temp', 'data = [-2, 45, 0, 11, -9]', 'bubbleSort(data)', 'print(data)', 'import java.util.Arrays;', 'class Main {', '    int size = array.length;', '          int temp = array[j];', '          array[j + 1] = temp;', '        }', '    Main.bubbleSort(data);', '#include <stdio.h>', '        ', '        int temp = array[i];', '        array[i + 1] = temp;', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  bubbleSort(data, size);', '  printArray(data, size);', '#include <iostream>', 'using namespace std;', '        int temp = array[i];', '        array[i + 1] = temp;', '    cout << ""  "" << array[i];', '  cout << ""\\n"";', 'int main() {', '  bubbleSort(data, size);', '  printArray(data, size);', 'bubbleSort(array)', '  swapped <- false', '      swapped <- true', 'end bubbleSort', 'def bubbleSort(array):', '  for i in range(len(array)):', '        ', '    # keep track of swapping', '    swapped = False', '        temp = array[j]', '        array[j] = array[j+1]', '        array[j+1] = temp', '        swapped = True', '          ', '    if not swapped:', '      break', 'data = [-2, 45, 0, 11, -9]', 'bubbleSort(data)', 'print(data)', 'import java.util.Arrays;', 'class Main {', '    int size = array.length;', '      boolean swapped = false;', '          int temp = array[j];', '          array[j + 1] = temp;', '          ', '          swapped = true;', '        }', '      if (!swapped)', '        break;', '    Main.bubbleSort(data);', '#include ', '    int swapped = 0;', '        ', '        int temp = array[i];', '        array[i + 1] = temp;', '        ', '        swapped = 1;', '    if (swapped == 0) {', '      break;', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  bubbleSort(data, size);', '  printArray(data, size);', '#include ', 'using namespace std;', '    int swapped = 0;', '        ', '        int temp = array[i];', '        array[i + 1] = temp;', '        ', '        swapped = 1;', '    if (swapped == 0)', '      break;', '    cout << ""  "" << array[i];', '  cout << ""\\n"";', 'int main() {', '  bubbleSort(data, size);', '  printArray(data, size);']","['  for i <- 1 to indexOfLastUnsortedElement-1', '    if leftElement > rightElement', '      swap leftElement and rightElement', '  # loop to access each array element', '    # loop to compare array elements', '    for j in range(0, len(array) - i - 1):', '      # compare two adjacent elements', '      # change > to < to sort in descending order', '      if array[j] > array[j + 1]:', '        # swapping elements if elements', '        # are not in the intended order', ""print('Sorted Array in Ascending Order:')"", '  static void bubbleSort(int array[]) {', '    for (int i = 0; i < size - 1; i++)', '      for (int j = 0; j < size - i - 1; j++)', '        if (array[j] > array[j + 1]) {', '          array[j] = array[j + 1];', '  public static void main(String args[]) {', '    int[] data = { -2, 45, 0, 11, -9 };', '    System.out.println(""Sorted Array in Ascending Order:"");', '    System.out.println(Arrays.toString(data));', 'void bubbleSort(int array[], int size) {', '  for (int step = 0; step < size - 1; ++step) {', '    for (int i = 0; i < size - step - 1; ++i) {', '      if (array[i] > array[i + 1]) {', '        array[i] = array[i + 1];', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {-2, 45, 0, 11, -9};', '  int size = sizeof(data) / sizeof(data[0]);', '  printf(""Sorted Array in Ascending Order:\\n"");', 'void bubbleSort(int array[], int size) {', '  for (int step = 0; step < size; ++step) {', '    for (int i = 0; i < size - step; ++i) {', '      if (array[i] > array[i + 1]) {', '        array[i] = array[i + 1];', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {-2, 45, 0, 11, -9};', '  int size = sizeof(data) / sizeof(data[0]);', '  cout << ""Sorted Array in Ascending Order:\\n"";  ', '  for i <- 1 to indexOfLastUnsortedElement-1', '    if leftElement > rightElement', '      swap leftElement and rightElement', '# Optimized Bubble sort in Python', '  # loop through each element of array', '    # loop to compare array elements', '    for j in range(0, len(array) - i - 1):', '      # compare two adjacent elements', '      # change > to < to sort in descending order', '      if array[j] > array[j + 1]:', '        # swapping occurs if elements', '        # are not in the intended order', '    # no swapping means the array is already sorted', '    # so no need for further comparison', ""print('Sorted Array in Ascending Order:')"", '  static void bubbleSort(int array[]) {', '    for (int i = 0; i < (size-1); i++) {', '      for (int j = 0; j < (size-i-1); j++) {', '        if (array[j] > array[j + 1]) {', '          array[j] = array[j + 1];', '  public static void main(String args[]) {', '    int[] data = { -2, 45, 0, 11, -9 };', '    System.out.println(""Sorted Array in Ascending Order:"");', '    System.out.println(Arrays.toString(data));', 'void bubbleSort(int array[], int size) {', '  for (int step = 0; step < size - 1; ++step) {', '    for (int i = 0; i < size - step - 1; ++i) {', '      if (array[i] > array[i + 1]) {', '        array[i] = array[i + 1];', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {-2, 45, 0, 11, -9};', '  int size = sizeof(data) / sizeof(data[0]);', '  printf(""Sorted Array in Ascending Order:\\n"");', 'void bubbleSort(int array[], int size) {', '  for (int step = 0; step < (size-1); ++step) {', '    for (int i = 0; i < (size-step-1); ++i) {', '      if (array[i] > array[i + 1]) {', '        array[i] = array[i + 1];', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {-2, 45, 0, 11, -9};', '  int size = sizeof(data) / sizeof(data[0]);', '  cout << ""Sorted Array in Ascending Order:\\n"";', '(n-1) + (n-2) + (n-3) +.....+ 1 = n(n-1)/2']",[],"['ime Complexity|||\xa0&&&est|||O(n)&&&orst|||O(n2)&&&verage|||O(n2)&&&pace Complexity|||O(1)&&&tability|||Yes', 'ycle|||Number of Comparisons&&&st|||(n-1)&&&nd|||(n-2)&&&rd|||(n-3)&&&......|||......&&&ast|||1']","['Worst Case Complexity: O(n2)|||If we want to sort in ascending order and the array is in descending order then\xa0the worst case occurs.|||Best Case Complexity: O(n)|||If the array is already sorted, then there is no need for sorting.|||Average Case Complexity: O(n2)|||It occurs when the elements of the array are in jumbled order (neither ascending nor descending).|||Space complexity is O(1) because an extra variable is used for swapping.|||In the optimized bubble sort algorithm, two extra variables are used. Hence, the space complexity will be O(2).|||complexity does not matter|||short and simple code is preferred|||Quicksort|||Insertion Sort|||Merge Sort|||Selection Sort|||&&&Starting from the first index, compare the first and the second elements.|||If the first element is greater than the second element, they are swapped.|||Now, compare the second and the third elements. Swap them if they are not in order.|||The above process goes on until the last element.|||Compare the Adjacent Elements|||']"
46,['Selection Sort Algorithm'],"['In this tutorial, you will learn about the selection sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Selection Sort', 'Selection Sort Algorithm', 'Selection Sort Code in Python, Java, and C/C++', 'Selection Sort Complexity', 'Selection Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/w1ZKsO2Obaw1WV03_lamX22SVyapwhbiKoLkT5Raiiw/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-initial-array.png', '//cdn.programiz.com/cdn/farfuture/9jjqXX0fGtJE2ul2Mga20fvf_GkNlFAFsDMwrrwFzbQ/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-comparision.png', '//cdn.programiz.com/cdn/farfuture/6o-qergdHNq6D7eBxBi87yIuCLc7MJy2BHR4QHeNxxQ/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0-swapping.png', '//cdn.programiz.com/cdn/farfuture/VPGtdVYag2vfHBotOaFEiYLqvWAD_Jwfnwur_AtKQHo/mtime:1582112622/sites/tutorial2program/files/Selection-sort-0.png', '//cdn.programiz.com/cdn/farfuture/hgxXpCSrHui7tbyJUQNnh8N5l8MPbdbL6dlstS4-G3M/mtime:1582112622/sites/tutorial2program/files/Selection-sort-1.png', '//cdn.programiz.com/cdn/farfuture/mDT4W_wUoS9eYT1JoUWjZuh4XBVXGDuiV9cr4Rylggk/mtime:1582112622/sites/tutorial2program/files/Selection-sort-2.png', '//cdn.programiz.com/cdn/farfuture/dsZIa58W_SRP0yB21QmrWGQvrmob8yAVa94iCtIPWoo/mtime:1582112622/sites/tutorial2program/files/Selection-sort-3_1.png']","['Complexity = O(n2)', 'Time Complexities:', 'Space Complexity:', 'Space complexity is O(1) because an extra variable temp is used.', 'The selection sort is used when']","['Number of comparisons: (n - 1) + (n - 2) + (n - 3) + ..... + 1 = n(n - 1) / 2 nearly equals to n2.', 'Also, we can analyze the complexity by simply observing the number of loops. There are 2 loops so the complexity is n*n = n2.']","['Selection sort is a sorting algorithm that selects the smallest element from an unsorted list in each iteration and places that element at the beginning of the unsorted list.', 'The time complexity of the selection sort is the same in all cases. At every step, you have to find the minimum element and put it in the right place. The minimum element is not known until the end of the array is not reached.']","['selectionSort(array, size)', '  repeat (size - 1) times', 'end selectionSort', '# Selection sort in Python', '    for step in range(size):', '        min_idx = step', '         ', '                min_idx = i', '         ', 'data = [-2, 45, 0, 11, -9]', 'size = len(data)', 'selectionSort(data, size)', 'print(data)', 'import java.util.Arrays;', 'class SelectionSort {', '    int size = array.length;', '      int min_idx = step;', '          min_idx = i;', '        }', '      int temp = array[step];', '      array[min_idx] = temp;', '    ss.selectionSort(data);', '#include <stdio.h>', 'void swap(int *a, int *b) {', '  int temp = *a;', '  *a = *b;', '  *b = temp;', '    int min_idx = step;', '        min_idx = i;', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  selectionSort(data, size);', '  printArray(data, size);', '#include <iostream>', 'using namespace std;', 'void swap(int *a, int *b) {', '  int temp = *a;', '  *a = *b;', '  *b = temp;', '    cout << array[i] << "" "";', '  cout << endl;', '    int min_idx = step;', '        min_idx = i;', 'int main() {', '  selectionSort(data, size);', '  printArray(data, size);']","['  set the first unsorted element as the minimum', '  for each of the unsorted elements', '      set element as new minimum', '  swap minimum with first unsorted position', '        for i in range(step + 1, size):', '            # to sort in descending order, change > to < in this line', '            # select the minimum element in each loop', '            if array[i] < array[min_idx]:', '        # put min at the correct position', '        (array[step], array[min_idx]) = (array[min_idx], array[step])', ""print('Sorted Array in Ascending Order:')"", '  void selectionSort(int array[]) {', '    for (int step = 0; step < size - 1; step++) {', '      for (int i = step + 1; i < size; i++) {', '        if (array[i] < array[min_idx]) {', '      array[step] = array[min_idx];', '  public static void main(String args[]) {', '    int[] data = { 20, 12, 10, 15, 2 };', '    SelectionSort ss = new SelectionSort();', '    System.out.println(""Sorted Array in Ascending Order: "");', '    System.out.println(Arrays.toString(data));', 'void selectionSort(int array[], int size) {', '  for (int step = 0; step < size - 1; step++) {', '    for (int i = step + 1; i < size; i++) {', '      if (array[i] < array[min_idx])', '    swap(&array[min_idx], &array[step]);', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {20, 12, 10, 15, 2};', '  int size = sizeof(data) / sizeof(data[0]);', '  printf(""Sorted array in Acsending Order:\\n"");', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; i++) {', 'void selectionSort(int array[], int size) {', '  for (int step = 0; step < size - 1; step++) {', '    for (int i = step + 1; i < size; i++) {', '      if (array[i] < array[min_idx])', '    swap(&array[min_idx], &array[step]);', '  int data[] = {20, 12, 10, 15, 2};', '  int size = sizeof(data) / sizeof(data[0]);', '  cout << ""Sorted array in Acsending Order:\\n"";']",[],"['ime Complexity|||\xa0&&&est|||O(n2)&&&orst|||O(n2)&&&verage|||O(n2)&&&pace Complexity|||O(1)&&&tability|||No', 'ycle|||Number of Comparison&&&st|||(n-1)&&&nd|||(n-2)&&&rd|||(n-3)&&&..|||...&&&ast|||1']","['Worst Case Complexity: O(n2)|||If we want to sort in ascending order and the array is in descending order then, the worst case occurs.|||Best Case Complexity: O(n2)|||It occurs when the array is already sorted|||Average Case Complexity: O(n2)|||It occurs when the elements of the array are in jumbled order (neither ascending nor descending).|||a small list is to be sorted|||cost of swapping does not matter|||checking of all the elements is compulsory|||cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)|||&&&Set the first element as minimum.||||||Select first element as minimum|||Compare minimum with the second element. If the second element is smaller than minimum, assign the second element as minimum.|||Compare minimum with the third element. Again, if the third element is smaller, then assign minimum to the third element otherwise do nothing. The process goes on until the last element.|||Compare minimum with the remaining elements|||After each iteration, minimum is placed in the front of the unsorted list.|||Swap the first with minimum|||For each iteration, indexing starts from the first unsorted element. Step 1 to 3 are repeated until all the elements are placed at their correct positions.|||The first iterationThe second iterationThe third iterationThe fourth iteration|||Bubble Sort|||Quicksort|||Insertion Sort|||Merge Sort|||']"
47,['Insertion Sort Algorithm'],"['In this tutorial, you will learn about insertion sort algorithm and its implementation in C, C++, Java and Python. ']",[],[],"['Working of Insertion Sort', 'Insertion Sort Algorithm', 'Insertion Sort in Python, Java, and C/C++', 'Insertion Sort Complexity', 'Insertion Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/K-kSm72ww4_afH0mQJDuR3Y-fPZYgBYo_Pclx7WlYUo/mtime:1582112622/sites/tutorial2program/files/Frame%204_0.png', '//cdn.programiz.com/cdn/farfuture/l-X2VCkF2rp4i0X8mZX6BGJL_FQW9EL8PkKhBswQfpc/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-0_1.png', '//cdn.programiz.com/cdn/farfuture/MqcrLAaQHEhcuJTmF_m712GG_wMemTY9AID0J9w4T6E/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-1_1.png', '//cdn.programiz.com/cdn/farfuture/hWFdFWWU0lZD2xWGz0CoMDESnjYa9Wg1HwpH99jTTH0/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-2_2.png', '//cdn.programiz.com/cdn/farfuture/TxAcrgHKfahw_BPEIKwCWB9BY2GNiI91yzWeetMfG9Q/mtime:1582112622/sites/tutorial2program/files/Insertion-sort-3_2.png']","['A similar approach is used by insertion sort.', 'Suppose we need to sort the following array.', 'Time Complexities', 'Space Complexity', 'Space complexity is O(1) because an extra variable key is used.', 'The insertion sort is used when:']","['Insertion sort is a sorting algorithm that places an unsorted element at its suitable place in each iteration.', 'Insertion sort works similarly as we sort cards in our hand in a card game.']","['We assume that the first card is already sorted then, we select an unsorted card. If the unsorted card is greater than the card in hand, it is placed on the right otherwise, to the left. In the same way, other unsorted cards are taken and put in their right place.']","['insertionSort(array)', '  mark first element as sorted', '  for each unsorted element X', ""    'extract' the element X"", '      if current element j > X', 'end insertionSort', '# Insertion sort in Python', 'def insertionSort(array):', '        key = array[step]', '        j = step - 1', '        ', '            j = j - 1', '        ', '        array[j + 1] = key', 'data = [9, 5, 1, 4, 3]', 'insertionSort(data)', 'print(data)', 'import java.util.Arrays;', 'class InsertionSort {', '    int size = array.length;', '      int key = array[step];', '      int j = step - 1;', '        --j;', '      array[j + 1] = key;', '    is.insertionSort(data);', '#include <stdio.h>', '    printf(""%d "", array[i]);', '  printf(""\\n"");', '    int key = array[step];', '    int j = step - 1;', '      array[j + 1] = array[j];', '      --j;', '    array[j + 1] = key;', 'int main() {', '  insertionSort(data, size);', '  printArray(data, size);', '#include <iostream>', 'using namespace std;', '    cout << array[i] << "" "";', '  cout << endl;', '    int key = array[step];', '    int j = step - 1;', '      array[j + 1] = array[j];', '      --j;', '    array[j + 1] = key;', 'int main() {', '  insertionSort(data, size);', '  printArray(data, size);']","['    for j <- lastSortedIndex down to 0', '        move sorted element to the right by 1', '    break loop and insert X here', '    for step in range(1, len(array)):', '        # Compare key with each element on the left of it until an element smaller than it is found', '        # For descending order, change key<array[j] to key>array[j].        ', '        while j >= 0 and key < array[j]:', '            array[j + 1] = array[j]', '        # Place key at after the element just smaller than it.', ""print('Sorted Array in Ascending Order:')"", '  void insertionSort(int array[]) {', '    for (int step = 1; step < size; step++) {', '      while (j >= 0 && key < array[j]) {', '        array[j + 1] = array[j];', '  public static void main(String args[]) {', '    int[] data = { 9, 5, 1, 4, 3 };', '    InsertionSort is = new InsertionSort();', '    System.out.println(""Sorted Array in Ascending Order: "");', '    System.out.println(Arrays.toString(data));', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; i++) {', 'void insertionSort(int array[], int size) {', '  for (int step = 1; step < size; step++) {', '    while (key < array[j] && j >= 0) {', '  int size = sizeof(data) / sizeof(data[0]);', '  printf(""Sorted array in ascending order:\\n"");', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; i++) {', 'void insertionSort(int array[], int size) {', '  for (int step = 1; step < size; step++) {', '    while (key < array[j] && j >= 0) {', '  int size = sizeof(data) / sizeof(data[0]);', '  cout << ""Sorted array in ascending order:\\n"";']",[],['ime Complexity|||\xa0&&&est|||O(n)&&&orst|||O(n2)&&&verage|||O(n2)&&&pace Complexity|||O(1)&&&tability|||Yes'],"['Worst Case Complexity: O(n2)|||Suppose, an array is in ascending order, and you want to sort it in descending order. In this case, worst case complexity occurs.|||Each element has to be compared with each of the other elements so, for every nth element, (n-1) number of comparisons are made.|||Thus, the total number of comparisons = n*(n-1) ~ n2|||Best Case Complexity: O(n)|||When the array is already sorted, the outer loop runs for n number of times whereas the inner loop does not run at all. So, there are only n number of comparisons. Thus, complexity is linear.|||Average Case Complexity: O(n2)|||It occurs when the elements of an array are in jumbled order (neither ascending nor descending).|||the array is has a small number of elements|||there are only a few elements left to be sorted|||&&&The first element in the array is assumed to be sorted. Take the second element and store it separately in key.|||Compare key with the first element. If the first element is greater than key, then key is placed in front of the first element.||||||If the first element is greater than key, then key is placed in front of the first element.|||Now, the first two elements are sorted.|||Take the third element and compare it with the elements on the left of it. Placed it just behind the element smaller than it. If there is no element smaller than it, then place it at the beginning of the array.|||Place 1 at the beginning|||Similarly, place every unsorted element at its correct position.|||Place 4 behind 1Place 3 behind 1 and the array is sorted|||Bubble Sort|||Quicksort|||Merge Sort|||Selection Sort|||']"
48,['Merge Sort Algorithm'],"['In this tutorial, you will learn about merge sort algorithm and its implementation in C, C++, Java and Python. ']",[],[],"['Divide and Conquer Strategy', 'MergeSort Algorithm', 'Writing the Code for Merge Algorithm', 'Merge( ) Function Explained Step-By-Step', 'Merge Sort Code in Python, Java, and C/C++', 'Merge Sort Complexity', 'Merge Sort Applications', 'Similar Sorting Algorithms']","['The merge Step of Merge Sort', 'Step 1: Create duplicate copies of sub-arrays to be sorted', 'Step 2: Maintain current index of sub-arrays and main array', 'Step 3: Until we reach the end of either L or M, pick larger among elements L and M and place them in the correct position at A[p..r]', 'Step 4: When we run out of elements in either L or M, pick up the remaining elements and put in A[p..r]', 'Time Complexity', 'Space Complexity']","['//cdn.programiz.com/cdn/farfuture/PRTu8e23Uz212XPrrzN_uqXkVZVY_E0Ta8GZp61-zvw/mtime:1586425911/sites/tutorial2program/files/merge-sort-example_0.png', '//cdn.programiz.com/cdn/farfuture/m8XujxD0B6qF81Hq-q30SP4nmJlMuaHdYNkKIyNt-hk/mtime:1586425921/sites/tutorial2program/files/merge-sort-in-action---merge-step-simple.png', '//cdn.programiz.com/cdn/farfuture/QgWYSTEJPw6dD8z1dlTcZI-SBWqa8UhVJWvleCsiFA0/mtime:1586425928/sites/tutorial2program/files/merge-two-sorted-arrays.png', '//cdn.programiz.com/cdn/farfuture/kXewSRUZ6FJFSxRlqIgzU1q4v7gwBeGjBVnjqrl67i8/mtime:1586425877/sites/tutorial2program/files/merge-sort-demo-step-1.png', '//cdn.programiz.com/cdn/farfuture/GewJqbEPU18Ix2UGMEfw-TrggcWZZBnQYWHDnbWAtzo/mtime:1586425882/sites/tutorial2program/files/merge-sort-demo-step-2.png', '//cdn.programiz.com/cdn/farfuture/A4EkJ4LFFCD4QQeuamAcDh2V7Ko0HbLAXBN_yCQ2tB0/mtime:1586425887/sites/tutorial2program/files/merge-sort-demo-step-3.png', '//cdn.programiz.com/cdn/farfuture/OVe2itOAZKEW6YQhWTZWPjnps6YKxKlaaFreWWvAHJQ/mtime:1586425894/sites/tutorial2program/files/merge-sort-demo-step-4.png', '//cdn.programiz.com/cdn/farfuture/vkS3IZSKFmOBIqiD7Wt_L6TDZuYjn2_NgTHo0hARKFo/mtime:1586425898/sites/tutorial2program/files/merge-sort-demo-step-5.png', '//cdn.programiz.com/cdn/farfuture/28oEp7dhguhe3eVE5yOHQG-soiB4qr-61hOpw7H8yfk/mtime:1586425903/sites/tutorial2program/files/merge-sort-demo-step-6.png']","['Divide', 'Conquer', 'Combine', 'The merge function works as follows:', 'In code, this would look like:', 'As usual, a picture speaks a thousand words.', 'At the end of the merge function, the subarray A[p..r] is sorted.', 'Best Case Complexity: O(n*log n)', 'Worst Case Complexity: O(n*log n)', 'Average Case Complexity: O(n*log n)', 'The space complexity of merge sort is O(n).']","['Merge Sort is one of the most popular sorting algorithms that is based on the principle of Divide and Conquer Algorithm.', 'If q is the half-way point between p and r, then we can split the subarray A[p..r] into two arrays A[p..q] and A[q+1, r].', 'To sort an entire array, we need to call MergeSort(A, 0, length(A)-1).', ""A lot is happening in this function, so let's take an example to see how this would work."", 'This step would have been needed if the size of M was greater than L.']","['Here, a problem is divided into multiple sub-problems. Each sub-problem is solved individually. Finally, sub-problems are combined to form the final solution.', ""Using the Divide and Conquer technique, we divide a problem into subproblems. When the solution to each subproblem is ready, we 'combine' the results from the subproblems to solve the main problem."", 'Suppose we had to sort an array A. A subproblem would be to sort a sub-section of this array starting at index p and ending at index r, denoted as A[p..r].', ""In the conquer step, we try to sort both the subarrays A[p..q] and A[q+1, r]. If we haven't yet reached the base case, we again divide both these subarrays and try to sort them."", 'When the conquer step reaches the base step and we get two sorted subarrays A[p..q] and A[q+1, r] for array A[p..r], we combine the results by creating a sorted array A[p..r] from two sorted subarrays A[p..q] and A[q+1, r].', 'The MergeSort function repeatedly divides the array into two halves until we reach a stage where we try to perform MergeSort on a subarray of size 1 i.e. p == r.', 'After that, the merge function comes into play and combines the sorted arrays into larger arrays until the whole array is merged.', 'As shown in the image below, the merge sort algorithm recursively divides the array into halves until we reach the base case of array with 1 element. After that, the merge function picks up the sorted sub-arrays and merges them to gradually sort the entire array.', 'Every recursive algorithm is dependent on a base case and the ability to combine the results from base cases. Merge sort is no different. The most important part of the merge sort algorithm is, you guessed it, merge step.', 'The algorithm maintains three pointers, one for each of the two arrays and one for maintaining the current index of the final sorted array.', 'A noticeable difference between the merging step we described above and the one we use for merge sort is that we only perform the merge function on consecutive sub-arrays.', 'This is why we only need the array, the first position, the last index of the first subarray(we can calculate the first index of the second subarray) and the last index of the second subarray.', 'Our task is to merge two subarrays A[p..q] and A[q+1..r] to create a sorted array A[p..r]. So the inputs to the function are A, p, q and r', 'The array A[0..5] contains two sorted subarrays A[0..3] and A[4..5]. Let us see how the merge function will merge the two arrays.']","['    int n1 = q - p + 1;', '    int n2 = r - q;', '    int L[n1], M[n2];', '        L[i] = arr[p + i];', '        M[j] = arr[q + 1 + j];', '    int i, j, k;', '    i = 0;', '    j = 0;', '    k = p;', '    while (i < n1 && j < n2) {', '        if (L[i] <= M[j]) {', '            arr[k] = L[i];', '            i++;', '        } else {', '            arr[k] = M[j];', '            j++;', '        }', '        k++;', '    while (i < n1) {', '        arr[k] = L[i];', '        i++;', '        k++;', '    while (j < n2) {', '        arr[k] = M[j];', '        j++;', '        k++;', '    int L[4], M[2];', '        L[i] = arr[p + i];', '        M[j] = arr[q + 1 + j];', '    int i, j, k;', '    i = 0; ', '    j = 0; ', '    k = p; ', '        if (L[i] <= M[j]) { ', '        } ', '        else { ', '            arr[k] = M[j]; ', '            j++; ', '        } ', '        k++; ', '    while (i < n1)', '        arr[k] = L[i];', '        i++;', '        k++;', '    while (j < n2)', '        arr[k] = M[j];', '        j++;', '        k++;', '# MergeSort in Python', 'def mergeSort(array):', '    if len(array) > 1:', '        r = len(array)//2', '        L = array[:r]', '        M = array[r:]', '        # Sort the two halves', '        mergeSort(L)', '        mergeSort(M)', '        i = j = k = 0', '            if L[i] < M[j]:', '                i += 1', '            else:', '                j += 1', '            k += 1', '        while i < len(L):', '            array[k] = L[i]', '            i += 1', '            k += 1', '        while j < len(M):', '            array[k] = M[j]', '            j += 1', '            k += 1', '# Print the array', 'def printList(array):', '    print()', '# Driver program', ""if __name__ == '__main__':"", '    mergeSort(array)', '    print(""Sorted array is: "")', '    printList(array)', 'class MergeSort {', '    int n1 = q - p + 1;', '    int n2 = r - q;', '    int L[] = new int[n1];', '    int M[] = new int[n2];', '      L[i] = arr[p + i];', '      M[j] = arr[q + 1 + j];', '    int i, j, k;', '    i = 0;', '    j = 0;', '    k = p;', '    while (i < n1 && j < n2) {', '      if (L[i] <= M[j]) {', '        arr[k] = L[i];', '        i++;', '      } else {', '        arr[k] = M[j];', '        j++;', '      k++;', '    while (i < n1) {', '      arr[k] = L[i];', '      i++;', '      k++;', '    while (j < n2) {', '      arr[k] = M[j];', '      j++;', '      k++;', '    if (l < r) {', '      int m = (l + r) / 2;', '      mergeSort(arr, l, m);', '      merge(arr, l, m, r);', '    int n = arr.length;', '    System.out.println();', '    printArray(arr);', '#include <stdio.h>', '  int n1 = q - p + 1;', '  int n2 = r - q;', '  int L[n1], M[n2];', '  for (int i = 0; i < n1; i++)', '    L[i] = arr[p + i];', '  for (int j = 0; j < n2; j++)', '    M[j] = arr[q + 1 + j];', '  int i, j, k;', '  i = 0;', '  j = 0;', '  k = p;', '  while (i < n1 && j < n2) {', '    if (L[i] <= M[j]) {', '      arr[k] = L[i];', '      i++;', '    } else {', '      arr[k] = M[j];', '      j++;', '    k++;', '  while (i < n1) {', '    arr[k] = L[i];', '    i++;', '    k++;', '  while (j < n2) {', '    arr[k] = M[j];', '    j++;', '    k++;', '  if (l < r) {', '    int m = l + (r - l) / 2;', '    mergeSort(arr, l, m);', '    mergeSort(arr, m + 1, r);', '    merge(arr, l, m, r);', '    printf(""%d "", arr[i]);', '  printf(""\\n"");', 'int main() {', '  mergeSort(arr, 0, size - 1);', '  printf(""Sorted array: \\n"");', '  printArray(arr, size);', '#include <iostream>', 'using namespace std;', '  int n1 = q - p + 1;', '  int n2 = r - q;', '  int L[n1], M[n2];', '  for (int i = 0; i < n1; i++)', '    L[i] = arr[p + i];', '  for (int j = 0; j < n2; j++)', '    M[j] = arr[q + 1 + j];', '  int i, j, k;', '  i = 0;', '  j = 0;', '  k = p;', '  while (i < n1 && j < n2) {', '    if (L[i] <= M[j]) {', '      arr[k] = L[i];', '      i++;', '    } else {', '      arr[k] = M[j];', '      j++;', '    k++;', '  while (i < n1) {', '    arr[k] = L[i];', '    i++;', '    k++;', '  while (j < n2) {', '    arr[k] = M[j];', '    j++;', '    k++;', '  if (l < r) {', '    int m = l + (r - l) / 2;', '    mergeSort(arr, l, m);', '    mergeSort(arr, m + 1, r);', '    merge(arr, l, m, r);', '    cout << arr[i] << "" "";', '  cout << endl;', 'int main() {', '  mergeSort(arr, 0, size - 1);', '  cout << ""Sorted array: \\n"";', '  printArray(arr, size);', '  return 0;']","['void merge(int arr[], int p, int q, int r) {', '    for (int i = 0; i < n1; i++)', '    for (int j = 0; j < n2; j++)', 'void merge(int arr[], int p, int q, int r) {', '    int n1 = q - p + 1 = 3 - 0 + 1 = 4;', '            arr[k] = L[i]; i++; ', '        #  r is the point where the array is divided into two subarrays', '        # Until we reach either end of either L or M, pick larger among', '        # elements L and M and place them in the correct position at A[p..r]', '        while i < len(L) and j < len(M):', '        # When we run out of elements in either L or M,', '        # pick up the remaining elements and put in A[p..r]', '        print(array[i], end="" "")', '    array = [6, 5, 12, 10, 9, 1]', '  void merge(int arr[], int p, int q, int r) {', '    for (int i = 0; i < n1; i++)', '    for (int j = 0; j < n2; j++)', '  void mergeSort(int arr[], int l, int r) {', '  static void printArray(int arr[]) {', '      System.out.print(arr[i] + "" "");', '  public static void main(String args[]) {', '    int arr[] = { 6, 5, 12, 10, 9, 1 };', '    MergeSort ob = new MergeSort();', '    ob.mergeSort(arr, 0, arr.length - 1);', '    System.out.println(""Sorted array:"");', 'void merge(int arr[], int p, int q, int r) {', 'void mergeSort(int arr[], int l, int r) {', 'void printArray(int arr[], int size) {', '  for (int i = 0; i < size; i++)', '  int arr[] = {6, 5, 12, 10, 9, 1};', '  int size = sizeof(arr) / sizeof(arr[0]);', 'void merge(int arr[], int p, int q, int r) {', 'void mergeSort(int arr[], int l, int r) {', 'void printArray(int arr[], int size) {', '  for (int i = 0; i < size; i++)', '  int arr[] = {6, 5, 12, 10, 9, 1};', '  int size = sizeof(arr) / sizeof(arr[0]);']","['MergeSort(A, p, r):', '    if p > r ', '        return', '    q = (p+r)/2', '    mergeSort(A, p, q)', '    mergeSort(A, q+1, r)', '    merge(A, p, q, r)', 'Have we reached the end of any of the arrays?', '    No:', '        Compare current elements of both arrays ', '        Copy smaller element into sorted array', '        Move pointer of element containing smaller element', '    Yes:', '        Copy all remaining elements of non-empty array']",['ime Complexity|||\xa0&&&est|||O(n*log n)&&&orst|||O(n*log n)&&&verage|||O(n*log n)&&&pace Complexity|||O(n)&&&tability|||Yes'],"['Inversion count problem|||External sorting|||E-commerce applications|||&&&Create copies of the subarrays L ← A[p..q] and M ← A[q+1..r].|||Create three pointers i, j and k|||i maintains current index of L, starting at 1|||j maintains current index of M, starting at 1|||k maintains the current index of A[p..q], starting at p.||||||Until we reach the end of either L or M, pick the larger among the elements from L and M and place them in the correct position at A[p..q]|||When we run out of elements in either L or M, pick up the remaining elements and put in A[p..q]|||i maintains current index of L, starting at 1|||j maintains current index of M, starting at 1|||k maintains the current index of A[p..q], starting at p.|||Quicksort|||Insertion Sort|||Selection Sort|||Bucket Sort|||']"
49,['Quicksort Algorithm'],"['In this tutorial, you will learn about the quick sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Quicksort Algorithm', 'Quick Sort Algorithm', 'Quicksort Code in Python, Java, and C/C++', 'Quicksort Complexity', 'Quicksort Applications']","['Visual Illustration of Quicksort Algorithm', '1. Time Complexities', '2. Space Complexity', 'Similar Sorting Algorithms']","['//cdn.programiz.com/cdn/farfuture/7qpYqe1UtqYbKzIBY_W8ljqkUz9iS6jZGobim6LDhtM/mtime:1582112622/sites/tutorial2program/files/quick-sort-0.1_0.png', '//cdn.programiz.com/cdn/farfuture/1Xn_e4xeHQjOsXExVhTgVbggPgpMk9WV4Z8gxmZgdyg/mtime:1582112622/sites/tutorial2program/files/quick-sort-0.2_0.png', '//cdn.programiz.com/cdn/farfuture/zaN86RZ0WfV0PhWpWDhis-f9lWlfgKJt_liYoGjZAIk/mtime:1617189498/sites/tutorial2program/files/quick-sort-partition-first-step.png', '//cdn.programiz.com/cdn/farfuture/RzFeResnC88JRu9IFh2YqUKZMXltQ51EeiioINCMcEA/mtime:1617189487/sites/tutorial2program/files/quick-sort-partition-second-step.png', '//cdn.programiz.com/cdn/farfuture/QA-TsXFkcz3cNyJikcbIWxepFVDu8ntl220KzlG8zdw/mtime:1617189492/sites/tutorial2program/files/quick-sort-partition-third-step.png', '//cdn.programiz.com/cdn/farfuture/tMmdAbX5gev9K20XI1kzQ3n932vSjnN1MszZouHV7Yc/mtime:1617189469/sites/tutorial2program/files/quick-sort-partition-fourth-step.png', '//cdn.programiz.com/cdn/farfuture/MNYV977xf4N3cgCpAtkB1KDyPqyG9OvlKSkHSdd0kys/mtime:1617189475/sites/tutorial2program/files/quick-sort-partition-fifth-step.png', '//cdn.programiz.com/cdn/farfuture/lAMcHRRzL8TJEh7bjY3rAufTTy3y5-o4Nt0z5L1AB8A/mtime:1617189481/sites/tutorial2program/files/quick-sort-partition-sixth-step.png', '//cdn.programiz.com/cdn/farfuture/dK3pGyiHqFZOYklwABPBZ4zq_VZU1dMWBIbWhHJ-Rgw/mtime:1617189464/sites/tutorial2program/files/quick-sort_1.png', '//cdn.programiz.com/cdn/farfuture/FxRG-2wIayocfWeQvHxMmUQTKhibQiI2FLqjkIr3Vi4/mtime:1608894915/sites/tutorial2program/files/quick-sort-working.png', '//cdn.programiz.com/cdn/farfuture/0k2dzQ8-WHeClPRTiv9CEdX1KkqBMpS_0St0lzT9RO8/mtime:1582112622/sites/tutorial2program/files/quick-sort-1.png']","['1. Select the Pivot Element', '2. Rearrange the Array', ""Here's how we rearrange the array:"", '3. Divide Subarrays', 'The space complexity for quicksort is O(log n).', 'Quicksort algorithm is used when']","['Quicksort is a sorting algorithm based on the divide and conquer approach where', 'Pivot elements are again chosen for the left and the right sub-parts separately. And, step 2 is repeated.', 'The subarrays are divided until each subarray is formed of a single element. At this point, the array is already sorted.', 'You can understand the working of quicksort algorithm with the help of the illustrations below.']","['There are different variations of quicksort where the pivot element is selected from different positions. Here, we will be selecting the rightmost element of the array as the pivot element.', 'Now the elements of the array are rearranged so that elements that are smaller than the pivot are put on the left and the elements greater than the pivot are put on the right.']","['  if element[i] < pivotElement', '    storeIndex++', 'return storeIndex + 1', '# Quick sort in Python', '  pivot = array[high]', '  i = low - 1', '  for j in range(low, high):', '    if array[j] <= pivot:', '      i = i + 1', '  return i + 1', '  if low < high:', 'data = [8, 7, 2, 1, 0, 9, 6]', 'print(""Unsorted Array"")', 'print(data)', 'size = len(data)', 'quickSort(data, 0, size - 1)', 'print(data)', 'import java.util.Arrays;', 'class Quicksort {', '    int pivot = array[high];', '    int i = (low - 1);', '      if (array[j] <= pivot) {', '        i++;', '        int temp = array[i];', '        array[i] = array[j];', '        array[j] = temp;', '    int temp = array[i + 1];', '    array[high] = temp;', '    return (i + 1);', '    if (low < high) {', 'class Main {', '    int size = data.length;', '#include <stdio.h>', 'void swap(int *a, int *b) {', '  int t = *a;', '  *a = *b;', '  *b = t;', '  int pivot = array[high];', '  int i = (low - 1);', '    if (array[j] <= pivot) {', '        ', '      i++;', '  return (i + 1);', '  if (low < high) {', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  printf(""Unsorted Array\\n"");', '  printArray(data, n);', '  quickSort(data, 0, n - 1);', '  printArray(data, n);', '#include <iostream>', 'using namespace std;', 'void swap(int *a, int *b) {', '  int t = *a;', '  *a = *b;', '  *b = t;', '  int i;', '  for (i = 0; i < size; i++)', '    cout << array[i] << "" "";', '  cout << endl;', '  int pivot = array[high];', '  int i = (low - 1);', '    if (array[j] <= pivot) {', '        ', '      i++;', '  return (i + 1);', '  if (low < high) {', 'int main() {', '  printArray(data, n);', '  quickSort(data, 0, n - 1);', '  printArray(data, n);']","['quickSort(array, leftmostIndex, rightmostIndex)', '  if (leftmostIndex < rightmostIndex)', '    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)', '    quickSort(array, leftmostIndex, pivotIndex - 1)', '    quickSort(array, pivotIndex, rightmostIndex)', 'partition(array, leftmostIndex, rightmostIndex)', '  set rightmostIndex as pivotIndex', '  storeIndex <- leftmostIndex - 1', '  for i <- leftmostIndex + 1 to rightmostIndex', '    swap element[i] and element[storeIndex]', '  swap pivotElement and element[storeIndex+1]', '# function to find the partition position', 'def partition(array, low, high):', '  # choose the rightmost element as pivot', '  # traverse through all elements', '  # compare each element with pivot', '      # if element smaller than pivot is found', '      # swap it with the greater element pointed by i', '      # swapping element at i with element at j', '      (array[i], array[j]) = (array[j], array[i])', '  # swap the pivot element with the greater element specified by i', '  (array[i + 1], array[high]) = (array[high], array[i + 1])', '  # return the position from where partition is done', 'def quickSort(array, low, high):', '    # find pivot element such that', '    # element smaller than pivot are on the left', '    # element greater than pivot are on the right', '    pi = partition(array, low, high)', '    # recursive call on the left of pivot', '    quickSort(array, low, pi - 1)', '    # recursive call on the right of pivot', '    quickSort(array, pi + 1, high)', ""print('Sorted Array in Ascending Order:')"", '  static int partition(int array[], int low, int high) {', '    for (int j = low; j < high; j++) {', '  static void quickSort(int array[], int low, int high) {', '      int pi = partition(array, low, high);', '      quickSort(array, low, pi - 1);', '      quickSort(array, pi + 1, high);', '  public static void main(String args[]) {', '    int[] data = { 8, 7, 2, 1, 0, 9, 6 };', '    System.out.println(""Unsorted Array"");', '    System.out.println(Arrays.toString(data));', '    Quicksort.quickSort(data, 0, size - 1);', '    System.out.println(""Sorted Array in Ascending Order: "");', '    System.out.println(Arrays.toString(data));', 'int partition(int array[], int low, int high) {', '  for (int j = low; j < high; j++) {', '      swap(&array[i], &array[j]);', '  swap(&array[i + 1], &array[high]);', 'void quickSort(int array[], int low, int high) {', '    int pi = partition(array, low, high);', '    quickSort(array, low, pi - 1);', '    quickSort(array, pi + 1, high);', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {8, 7, 2, 1, 0, 9, 6};', '  int n = sizeof(data) / sizeof(data[0]);', '  printf(""Sorted array in ascending order: \\n"");', 'void printArray(int array[], int size) {', 'int partition(int array[], int low, int high) {', '  for (int j = low; j < high; j++) {', '      swap(&array[i], &array[j]);', '  swap(&array[i + 1], &array[high]);', 'void quickSort(int array[], int low, int high) {', '    int pi = partition(array, low, high);', '    quickSort(array, low, pi - 1);', '    quickSort(array, pi + 1, high);', '  int data[] = {8, 7, 6, 1, 0, 9, 2};', '  int n = sizeof(data) / sizeof(data[0]);', '  cout << ""Sorted array in ascending order: \\n"";']",[],['ime Complexity|||\xa0&&&est|||O(n*log n)&&&orst|||O(n2)&&&verage|||O(n*log n)&&&pace Complexity|||O(log n)&&&tability|||No'],"['Worst Case Complexity [Big-O]: O(n2)|||It occurs when the pivot element picked is either the greatest or the smallest element.|||This condition leads to the case in which the pivot element lies in an extreme end of the sorted array. One sub-array is always empty and another sub-array contains n - 1 elements. Thus, quicksort is called only on this sub-array.|||However, the quicksort algorithm has better performance for scattered pivots.|||Best Case Complexity [Big-omega]: O(n*log n)|||It occurs when the pivot element is always the middle element or near to the middle element.|||Average Case Complexity [Big-theta]: O(n*log n)|||It occurs when the above conditions do not occur.|||the programming language is good for recursion|||time complexity matters|||space complexity matters|||Insertion Sort|||Merge Sort|||Selection Sort|||Bucket Sort|||&&&An array is divided into subarrays by selecting a pivot element (element selected from the array).|||While dividing the array, the pivot element should be positioned in such a way that elements less than pivot are kept on the left side and elements greater than pivot are on the right side of the pivot.|||The left and right subarrays are also divided using the same approach. This process continues until each subarray contains a single element.|||At this point, elements are already sorted. Finally, elements are combined to form a sorted array.|||A pointer is fixed at the pivot element. The pivot element is compared with the elements beginning from the first index.|||Comparison of pivot element with element beginning from the first index|||If the element is greater than the pivot element, a second pointer is set for that element.|||If the element is greater than the pivot element, a second pointer is set for that element.|||Now, pivot is compared with other elements. If an element smaller than the pivot element is reached, the smaller element is swapped with the greater element found earlier.|||Pivot is compared with other elements.|||Again, the process is repeated to set the next greater element as the second pointer. And, swap it with another smaller element.|||The process is repeated to set the next greater element as the second pointer.|||The process goes on until the second last element is reached.|||The process goes on until the second last element is reached.|||Finally, the pivot element is swapped with the second pointer.|||Finally, the pivot element is swapped with the second pointer.|||']"
50,['Counting Sort Algorithm'],"['In this tutorial, you will learn about the counting sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Counting Sort', 'Counting Sort Algorithm', 'Counting Sort Code in Python, Java, and C/C++', 'Complexity', 'Counting Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/_iojSNQFxCvNdbdPPmMVCJZxGFTS0TOZRIt1E4Wte0Y/mtime:1582112622/sites/tutorial2program/files/Counting-sort-0_0.png', '//cdn.programiz.com/cdn/farfuture/bRDNfPQG8lie6m7EFXVqPj8w6RzkRhM34XNaAoG2dCs/mtime:1582112622/sites/tutorial2program/files/Counting-sort-1.png', '//cdn.programiz.com/cdn/farfuture/CIyC1Lkj5JFln_hjy8U1acmUZ4JST__v4bQBvPcnOkk/mtime:1582112622/sites/tutorial2program/files/Counting-sort-2.png', '//cdn.programiz.com/cdn/farfuture/6A5S6vY-KsapHcyBjGgLNrp-58NRdyGDeVXspSzUbwM/mtime:1582112622/sites/tutorial2program/files/Counting-sort-3.png', '//cdn.programiz.com/cdn/farfuture/tcfjQdeYwL_jETOCPZxNjIXbysRrb7MaG6PwO2MzHnM/mtime:1582112622/sites/tutorial2program/files/Counting-sort-4_1.png']","['Time Complexities', 'Overall complexity = O(max)+O(size)+O(max)+O(size) = O(max+size)', 'Space Complexity', 'Counting sort is used when:']","['There are mainly four main loops. (Finding the greatest value can be done outside the function.)', 'The space complexity of Counting Sort is O(max). Larger the range of elements, larger is the space complexity.']","['Counting sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrences of each unique element in the array. The count is stored in an auxiliary array and the sorting is done by mapping the count as an index of the auxiliary array.', 'In all the above cases, the complexity is the same because no matter how the elements are placed in the array, the algorithm goes through n+k times.', 'There is no comparison between any elements, so it is better than comparison based sorting techniques. But, it is bad if the integers are very large because the array of that size should be made.']","['countingSort(array, size)', '  for j <- 0 to size', '  for i <- 1 to max', '  for j <- size down to 1', 'def countingSort(array):', '    size = len(array)', '    output = [0] * size', '    # Initialize count array', '    count = [0] * 10', '    for i in range(0, size):', '        count[array[i]] += 1', '    for i in range(1, 10):', '    i = size - 1', '    while i >= 0:', '        count[array[i]] -= 1', '        i -= 1', '    for i in range(0, size):', '        array[i] = output[i]', 'data = [4, 2, 2, 8, 3, 3, 1]', 'countingSort(data)', 'print(data)', 'import java.util.Arrays;', 'class CountingSort {', '    int max = array[0];', '      if (array[i] > max)', '        max = array[i];', '      count[i] = 0;', '      count[array[i]]++;', '      count[array[i]]--;', '      array[i] = output[i];', '    int size = data.length;', '    cs.countSort(data, size);', '#include <stdio.h>', '  int output[10];', '  int max = array[0];', '    if (array[i] > max)', '      max = array[i];', '  int count[10];', '    count[i] = 0;', '    count[array[i]]++;', '    count[i] += count[i - 1];', '    count[array[i]]--;', '    array[i] = output[i];', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  countingSort(array, n);', '  printArray(array, n);', '#include <iostream>', 'using namespace std;', '  int output[10];', '  int count[10];', '  int max = array[0];', '    if (array[i] > max)', '      max = array[i];', '    count[i] = 0;', '    count[array[i]]++;', '    count[i] += count[i - 1];', '    count[array[i]]--;', '    array[i] = output[i];', '    cout << array[i] << "" "";', '  cout << endl;', 'int main() {', '  countSort(array, n);', '  printArray(array, n);']","['  max <- find largest element in array', '  initialize count array with all zeros', '    find the total count of each unique element and ', '    store the count at jth index in count array', '    find the cumulative sum and store it in count array itself', '    restore the elements to array', '    decrease count of each element restored by 1', '# Counting sort in Python programming', '    # Store the count of each elements in count array', '    # Store the cummulative count', '        count[i] += count[i - 1]', '    # Find the index of each element of the original array in count array', '    # place the elements in output array', '        output[count[array[i]] - 1] = array[i]', '    # Copy the sorted elements into original array', 'print(""Sorted Array in Ascending Order: "")', '  void countSort(int array[], int size) {', '    int[] output = new int[size + 1];', '    for (int i = 1; i < size; i++) {', '    int[] count = new int[max + 1];', '    for (int i = 0; i < max; ++i) {', '    for (int i = 0; i < size; i++) {', '    for (int i = 1; i <= max; i++) {', '    for (int i = size - 1; i >= 0; i--) {', '      output[count[array[i]] - 1] = array[i];', '    for (int i = 0; i < size; i++) {', '  public static void main(String args[]) {', '    int[] data = { 4, 2, 2, 8, 3, 3, 1 };', '    CountingSort cs = new CountingSort();', '    System.out.println(""Sorted Array in Ascending Order: "");', '    System.out.println(Arrays.toString(data));', 'void countingSort(int array[], int size) {', '  for (int i = 1; i < size; i++) {', '  for (int i = 0; i <= max; ++i) {', '  for (int i = 0; i < size; i++) {', '  for (int i = 1; i <= max; i++) {', '  for (int i = size - 1; i >= 0; i--) {', '    output[count[array[i]] - 1] = array[i];', '  for (int i = 0; i < size; i++) {', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int array[] = {4, 2, 2, 8, 3, 3, 1};', '  int n = sizeof(array) / sizeof(array[0]);', 'void countSort(int array[], int size) {', '  for (int i = 1; i < size; i++) {', '  for (int i = 0; i <= max; ++i) {', '  for (int i = 0; i < size; i++) {', '  for (int i = 1; i <= max; i++) {', '  for (int i = size - 1; i >= 0; i--) {', '    output[count[array[i]] - 1] = array[i];', '  for (int i = 0; i < size; i++) {', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; i++)', '  int array[] = {4, 2, 2, 8, 3, 3, 1};', '  int n = sizeof(array) / sizeof(array[0]);']",[],"['ime Complexity|||\xa0&&&est|||O(n+k)&&&orst|||O(n+k)&&&verage|||O(n+k)&&&pace Complexity|||O(max)&&&tability|||Yes', 'or-loop|||time of counting&&&st|||O(max)&&&nd|||O(size)&&&rd|||O(max)&&&th|||O(size)']","['Worst Case Complexity: O(n+k)|||Best Case Complexity: O(n+k)|||Average Case Complexity: O(n+k)|||there are smaller integers with multiple counts.|||linear complexity is the need.|||&&&Find out the maximum element (let it be max) from the given array.||||||Given array|||Initialize an array of length max+1 with all elements 0. This array is used for storing the count of the elements in the array.|||Count array|||Store the count of each element at their respective index in count array|||For example: if the count of element 3 is 2 then, 2 is stored in the 3rd position of count array. If element ""5"" is not present in the array, then 0 is stored in 5th position.|||Count of each element stored|||Store cumulative sum of the elements of the count array. It helps in placing the elements into the correct index of the sorted array.|||Cumulative count|||Find the index of each element of the original array in the count array. This gives the cumulative count. Place the element at the index calculated as shown in figure below.|||Counting sort|||After placing each element at its correct position, decrease its count by one.|||Quicksort|||Merge Sort|||Bucket Sort|||Radix Sort|||']"
51,['Radix Sort Algorithm'],"['In this tutorial, you will learn about the radix sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Radix Sort', 'Radix Sort Algorithm', 'Radix Sort Code in Python, Java, and C/C++', 'Radix Sort Complexity', 'Radix Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/GKQPB3dxbVfvYT3qiSZtTQDI5UOENnLr-oTPlCbYKaM/mtime:1582112622/sites/tutorial2program/files/Radix-sort-0_0.png', '//cdn.programiz.com/cdn/farfuture/uCNpqDxCh0fa6L5HIYKbmYCbiZHlGhzXXBsxKVpItSs/mtime:1591330108/sites/tutorial2program/files/Radix-sort-one.png', '//cdn.programiz.com/cdn/farfuture/k2d_8gQeDKJ5pafc96mpZMqZvEqOOrh9eBCVmKRTBsg/mtime:1591330113/sites/tutorial2program/files/Radix-sort-ten.png', '//cdn.programiz.com/cdn/farfuture/CvIF-W6hxb0-kwt-hn9Gb3IWlpTVxR3PK7X4TQimROc/mtime:1591330096/sites/tutorial2program/files/Radix-sort-hundred.png']",['Radix sort is implemented in'],"['Let the initial array be [121, 432, 564, 23, 1, 45, 788]. It is sorted according to radix sort as shown in the figure below.', 'Since radix sort is a non-comparative algorithm, it has advantages over comparative sorting algorithms.', 'For the radix sort that uses counting sort as an intermediate stable sort, the time complexity is O(d(n+k)).', 'Here, d is the number cycle and O(n+k) is the time complexity of counting sort.', 'Thus, radix sort has linear time complexity which is better than O(nlog n) of comparative sorting algorithms.', 'This makes radix sort space inefficient. This is the reason why this sort is not used in software libraries.']","['Radix sort is a sorting algorithm that sorts the elements by first grouping the individual digits of the same place value. Then, sort the elements according to their increasing/decreasing order.', 'Suppose, we have an array of 8 elements. First, we will sort elements based on the value of the unit place. Then, we will sort elements based on the value of the tenth place. This process goes on until the last significant place.', 'Please go through the counting sort before reading this article because counting sort is used as an intermediate sort in radix sort.', 'If we take very large digit numbers or the number of other bases like 32-bit and 64-bit numbers then it can perform in linear time however the intermediate sort takes large space.']","['radixSort(array)', '  create d buckets of size 0-9', '  for i <- 0 to d', 'countingSort(array, d)', '  for j <- 0 to size', '  for i <- 1 to max', '  for j <- size down to 1', '# Radix sort in Python', '    size = len(array)', '    output = [0] * size', '    count = [0] * 10', '    for i in range(0, size):', '        count[index % 10] += 1', '    for i in range(1, 10):', '    i = size - 1', '    while i >= 0:', '        count[index % 10] -= 1', '        i -= 1', '    for i in range(0, size):', '        array[i] = output[i]', 'def radixSort(array):', '    # Get maximum element', '    max_element = max(array)', '    place = 1', '        place *= 10', 'radixSort(data)', 'print(data)', 'import java.util.Arrays;', 'class RadixSort {', '    int max = array[0];', '      if (array[i] > max)', '        max = array[i];', '      count[i] = 0;', '      array[i] = output[i];', '    int max = array[0];', '      if (array[i] > max)', '        max = array[i];', '    return max;', '    int size = data.length;', '    rs.radixSort(data, size);', '#include <stdio.h>', '  int max = array[0];', '  for (int i = 1; i < n; i++)', '    if (array[i] > max)', '      max = array[i];', '  return max;', '  int output[size + 1];', '      max = array[i];', '  int count[max + 1];', '    count[i] = 0;', '  for (int i = 1; i < 10; i++)', '    count[i] += count[i - 1];', '    array[i] = output[i];', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  radixsort(array, n);', '  printArray(array, n);', '#include <iostream>', 'using namespace std;', '  int max = array[0];', '  for (int i = 1; i < n; i++)', '    if (array[i] > max)', '      max = array[i];', '  return max;', '  const int max = 10;', '  int output[size];', '  int count[max];', '    count[i] = 0;', '    count[i] += count[i - 1];', '    array[i] = output[i];', '  int i;', '  for (i = 0; i < size; i++)', '    cout << array[i] << "" "";', '  cout << endl;', 'int main() {', '  radixsort(array, n);', '  printArray(array, n);']","['  d <- maximum number of digits in the largest element', '    sort the elements according to ith place digits using countingSort', '  max <- find largest element among dth place elements', '  initialize count array with all zeros', '    find the total count of each unique digit in dth place of elements and', '    store the count at jth index in count array', '    find the cumulative sum and store it in count array itself', '    restore the elements to array', '    decrease count of each element restored by 1', '# Using counting sort to sort the elements in the basis of significant places', '    # Calculate count of elements', '        index = array[i] // place', '    # Calculate cumulative count', '        count[i] += count[i - 1]', '    # Place the elements in sorted order', '        index = array[i] // place', '        output[count[index % 10] - 1] = array[i]', '# Main function to implement radix sort', '    # Apply counting sort to sort elements based on place value.', '    while max_element // place > 0:', '        countingSort(array, place)', 'data = [121, 432, 564, 23, 1, 45, 788]', '  void countingSort(int array[], int size, int place) {', '    int[] output = new int[size + 1];', '    for (int i = 1; i < size; i++) {', '    int[] count = new int[max + 1];', '    for (int i = 0; i < max; ++i)', '    for (int i = 0; i < size; i++)', '      count[(array[i] / place) % 10]++;', '    for (int i = 1; i < 10; i++)', '    for (int i = size - 1; i >= 0; i--) {', '      output[count[(array[i] / place) % 10] - 1] = array[i];', '      count[(array[i] / place) % 10]--;', '    for (int i = 0; i < size; i++)', '  int getMax(int array[], int n) {', '  void radixSort(int array[], int size) {', '    int max = getMax(array, size);', '    for (int place = 1; max / place > 0; place *= 10)', '      countingSort(array, size, place);', '  public static void main(String args[]) {', '    int[] data = { 121, 432, 564, 23, 1, 45, 788 };', '    RadixSort rs = new RadixSort();', '    System.out.println(""Sorted Array in Ascending Order: "");', '    System.out.println(Arrays.toString(data));', 'int getMax(int array[], int n) {', 'void countingSort(int array[], int size, int place) {', '  int max = (array[0] / place) % 10;', '  for (int i = 1; i < size; i++) {', '    if (((array[i] / place) % 10) > max)', '  for (int i = 0; i < size; i++)', '    count[(array[i] / place) % 10]++;', '  for (int i = size - 1; i >= 0; i--) {', '    output[count[(array[i] / place) % 10] - 1] = array[i];', '    count[(array[i] / place) % 10]--;', '  for (int i = 0; i < size; i++)', 'void radixsort(int array[], int size) {', '  int max = getMax(array, size);', '  for (int place = 1; max / place > 0; place *= 10)', '    countingSort(array, size, place);', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int array[] = {121, 432, 564, 23, 1, 45, 788};', '  int n = sizeof(array) / sizeof(array[0]);', 'int getMax(int array[], int n) {', 'void countingSort(int array[], int size, int place) {', '  for (int i = 0; i < size; i++)', '    count[(array[i] / place) % 10]++;', '  for (int i = size - 1; i >= 0; i--) {', '    output[count[(array[i] / place) % 10] - 1] = array[i];', '    count[(array[i] / place) % 10]--;', '  for (int i = 0; i < size; i++)', 'void radixsort(int array[], int size) {', '  int max = getMax(array, size);', '  for (int place = 1; max / place > 0; place *= 10)', '    countingSort(array, size, place);', 'void printArray(int array[], int size) {', '  int array[] = {121, 432, 564, 23, 1, 45, 788};', '  int n = sizeof(array) / sizeof(array[0]);']",[],['ime Complexity|||\xa0&&&est|||O(n+k)&&&orst|||O(n+k)&&&verage|||O(n+k)&&&pace Complexity|||O(max)&&&tability|||Yes'],"['DC3 algorithm (Kärkkäinen-Sanders-Burkhardt) while making a suffix array.|||places where there are numbers in large ranges.|||&&&Find the largest element in the array, i.e. max. Let X be the number of digits in max. X is calculated because we have to go through all the significant places of all elements.|||In this array [121, 432, 564, 23, 1, 45, 788], we have the largest number 788. It has 3 digits. Therefore, the loop should go up to hundreds place (3 times).|||Now, go through each significant place one by one.|||Use any stable sorting technique to sort the digits at each significant place. We have used counting sort for this.|||Sort the elements based on the unit place digits (X=0).|||Using counting sort to sort elements based on unit place|||Now, sort the elements based on digits at tens place.|||Sort elements based on tens place|||Finally, sort the elements based on the digits at hundreds place.|||Sort elements based on hundreds place|||Quicksort|||Merge Sort|||Bucket Sort|||Counting Sort|||']"
52,['Bucket Sort Algorithm'],"['In this tutorial, you will learn about the bucket sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Bucket Sort', 'Bucket Sort Algorithm', 'Bucket Sort Code in Python, Java, and C/C++', 'Bucket Sort Complexity', 'Bucket Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/gNSELV0jV05rlFjkjScrcZWCFeRsJqJUczwEOcne9D0/mtime:1582112622/sites/tutorial2program/files/Bucket_2.png', '//cdn.programiz.com/cdn/farfuture/nZnEPMDyED_o3k9I9B_kA62pnHztKRSQy2CjCqLRI0I/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0.1_0.png', '//cdn.programiz.com/cdn/farfuture/Vfhp1cQfAtSDdhNoGxyahhZ1usg1tFN-048etgx7w7k/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0_0.png', '//cdn.programiz.com/cdn/farfuture/hREOdaen0Rf3tOH3peobau0_r1NK0tB8B3OsChICkc0/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0.2_0.png', '//cdn.programiz.com/cdn/farfuture/zNeS_ImQpS0e-lHiTIZC5tLlOuX4M58TwCaZV8tveOE/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0.3_0.png', '//cdn.programiz.com/cdn/farfuture/mOL3yaTcJAp3WbD0kTJq7rWgnLl6nMrR762voPIsyN8/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0.4_0.png', '//cdn.programiz.com/cdn/farfuture/VobtThxrLKyQDQa8o5gUKmCAHBAJzBIjZ3wEuEyL8Fc/mtime:1582112622/sites/tutorial2program/files/Bucket-sort-0.5_0.png']","['Scatter Gather Approach', 'Bucket sort is used when:']","['Finally, the sorted buckets are combined to form a final sorted array.']","['Bucket Sort is\xa0a sorting algorithm that divides the unsorted array elements into several groups called buckets. Each bucket is then sorted by using any of the suitable sorting algorithms or recursively applying the same bucket algorithm.', 'The process of bucket sort can be understood as a scatter-gather approach. Here, elements are first scattered into buckets then the elements in each bucket are sorted. Finally, the elements are gathered in order.']","['bucketSort()', '  for all the buckets', '  for all the buckets', '  for all the buckets ', 'end bucketSort', '# Bucket Sort in Python', 'def bucketSort(array):', '    bucket = []', '    # Create empty buckets', '        bucket.append([])', '    for j in array:', '        index_b = int(10 * j)', '    # Get the sorted elements', '    k = 0', '            k += 1', '    return array', 'print(bucketSort(array))', 'import java.util.ArrayList;', 'import java.util.Collections;', 'public class BucketSort {', '    if (n <= 0)', '      return;', '    int index = 0;', '        (float) 0.51 };', '    b.bucketSort(arr, 7);', '    for (float i : arr)', '#include <stdio.h>', '#include <stdlib.h>', 'struct Node {', '  int data;', '  struct Node *next;', 'void BucketSort(int arr[]);', 'void print(int arr[]);', 'int getBucketIndex(int value);', 'void BucketSort(int arr[]) {', '  int i, j;', '  struct Node **buckets;', '    buckets[i] = NULL;', '    struct Node *current;', '    current->data = arr[i];', '    buckets[pos] = current;', '    printf(""Bucket[%d]: "", i);', '    printBuckets(buckets[i]);', '    printf(""\\n"");', '  printf(""-------------\\n"");', '    printf(""Bucket[%d]: "", i);', '    printBuckets(buckets[i]);', '    printf(""\\n"");', '    struct Node *node;', '    node = buckets[i];', '    while (node) {', '      arr[j++] = node->data;', '      node = node->next;', '  return;', '  struct Node *k, *nodeList;', '    return list;', '  nodeList = list;', '  k = list->next;', '  nodeList->next = 0;', '  while (k != 0) {', '    struct Node *ptr;', '      struct Node *tmp;', '      tmp = k;', '      k = k->next;', '      tmp->next = nodeList;', '      nodeList = tmp;', '      continue;', '        break;', '    if (ptr->next != 0) {', '      struct Node *tmp;', '      tmp = k;', '      k = k->next;', '      tmp->next = ptr->next;', '      ptr->next = tmp;', '      continue;', '    } else {', '      ptr->next = k;', '      k = k->next;', '      ptr->next->next = 0;', '      continue;', '  return nodeList;', '  return value / INTERVAL;', 'void print(int ar[]) {', '  int i;', '    printf(""%d "", ar[i]);', '  printf(""\\n"");', '  struct Node *cur = list;', '  while (cur) {', '    printf(""%d "", cur->data);', '    cur = cur->next;', 'int main(void) {', '  printf(""Initial array: "");', '  print(array);', '  printf(""-------------\\n"");', '  BucketSort(array);', '  printf(""-------------\\n"");', '  printf(""Sorted array: "");', '  print(array);', '  return 0;', '#include <iomanip>', '#include <iostream>', 'using namespace std;', 'struct Node {', '  int data;', '  struct Node *next;', 'void BucketSort(int arr[]);', 'void print(int arr[]);', 'int getBucketIndex(int value);', 'void BucketSort(int arr[]) {', '  int i, j;', '  struct Node **buckets;', '    buckets[i] = NULL;', '    struct Node *current;', '    current->data = arr[i];', '    buckets[pos] = current;', '    printBuckets(buckets[i]);', '    cout << endl;', '    printBuckets(buckets[i]);', '    cout << endl;', '    struct Node *node;', '    node = buckets[i];', '    while (node) {', '      arr[j++] = node->data;', '      node = node->next;', '    struct Node *node;', '    node = buckets[i];', '    while (node) {', '      struct Node *tmp;', '      tmp = node;', '      node = node->next;', '      free(tmp);', '  free(buckets);', '  return;', '  struct Node *k, *nodeList;', '    return list;', '  nodeList = list;', '  k = list->next;', '  nodeList->next = 0;', '  while (k != 0) {', '    struct Node *ptr;', '      struct Node *tmp;', '      tmp = k;', '      k = k->next;', '      tmp->next = nodeList;', '      nodeList = tmp;', '      continue;', '        break;', '    if (ptr->next != 0) {', '      struct Node *tmp;', '      tmp = k;', '      k = k->next;', '      tmp->next = ptr->next;', '      ptr->next = tmp;', '      continue;', '    } else {', '      ptr->next = k;', '      k = k->next;', '      ptr->next->next = 0;', '      continue;', '  return nodeList;', '  return value / INTERVAL;', 'void print(int ar[]) {', '  int i;', '    cout << setw(3) << ar[i];', '  cout << endl;', '  struct Node *cur = list;', '  while (cur) {', '    cur = cur->next;', 'int main(void) {', '  print(array);', '  BucketSort(array);', '  print(array);']","['  create N buckets each of which can hold a range of values', '    initialize each bucket with 0 values', '    put elements into buckets matching the range', '    sort elements in each bucket', '  gather elements from each bucket', '    # Insert elements into their respective buckets', '        bucket[index_b].append(j)', '    # Sort the elements of each bucket', '        bucket[i] = sorted(bucket[i])', '        for j in range(len(bucket[i])):', '            array[k] = bucket[i][j]', 'array = [.42, .32, .33, .52, .37, .47, .51]', 'print(""Sorted Array in descending order is"")', '  public void bucketSort(float[] arr, int n) {', '    @SuppressWarnings(""unchecked"")', '    ArrayList<Float>[] bucket = new ArrayList[n];', '      bucket[i] = new ArrayList<Float>();', '    for (int i = 0; i < n; i++) {', '      int bucketIndex = (int) arr[i] * n;', '      bucket[bucketIndex].add(arr[i]);', '    for (int i = 0; i < n; i++) {', '      Collections.sort((bucket[i]));', '    for (int i = 0; i < n; i++) {', '      for (int j = 0, size = bucket[i].size(); j < size; j++) {', '        arr[index++] = bucket[i].get(j);', '  public static void main(String[] args) {', '    BucketSort b = new BucketSort();', '    float[] arr = { (float) 0.42, (float) 0.32, (float) 0.33, (float) 0.52, (float) 0.37, (float) 0.47,', '      System.out.print(i + ""  "");', '#define NARRAY 7   // Array size', '#define NBUCKET 6  // Number of buckets', '#define INTERVAL 10  // Each bucket capacity', 'struct Node *InsertionSort(struct Node *list);', 'void printBuckets(struct Node *list);', '  buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);', '  for (i = 0; i < NBUCKET; ++i) {', '  for (i = 0; i < NARRAY; ++i) {', '    int pos = getBucketIndex(arr[i]);', '    current = (struct Node *)malloc(sizeof(struct Node));', '    current->next = buckets[pos];', '  for (i = 0; i < NBUCKET; i++) {', '  for (i = 0; i < NBUCKET; ++i) {', '    buckets[i] = InsertionSort(buckets[i]);', '  printf(""Bucktets after sorting\\n"");', '  for (i = 0; i < NBUCKET; i++) {', '  for (j = 0, i = 0; i < NBUCKET; ++i) {', 'struct Node *InsertionSort(struct Node *list) {', '  if (list == 0 || list->next == 0) {', '    if (nodeList->data > k->data) {', '    for (ptr = nodeList; ptr->next != 0; ptr = ptr->next) {', '      if (ptr->next->data > k->data)', '  for (i = 0; i < NARRAY; ++i) {', 'void printBuckets(struct Node *list) {', '  int array[NARRAY] = {42, 32, 33, 52, 37, 47, 51};', '#define NARRAY 7   // Array size', '#define NBUCKET 6  // Number of buckets', '#define INTERVAL 10  // Each bucket capacity', 'struct Node *InsertionSort(struct Node *list);', 'void printBuckets(struct Node *list);', '  buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);', '  for (i = 0; i < NBUCKET; ++i) {', '  for (i = 0; i < NARRAY; ++i) {', '    int pos = getBucketIndex(arr[i]);', '    current = (struct Node *)malloc(sizeof(struct Node));', '    current->next = buckets[pos];', '  for (i = 0; i < NBUCKET; i++) {', '    cout << ""Bucket["" << i << ""] : "";', '  for (i = 0; i < NBUCKET; ++i) {', '    buckets[i] = InsertionSort(buckets[i]);', '  cout << ""-------------"" << endl;', '  cout << ""Bucktets after sorted"" << endl;', '  for (i = 0; i < NBUCKET; i++) {', '    cout << ""Bucket["" << i << ""] : "";', '  for (j = 0, i = 0; i < NBUCKET; ++i) {', '  for (i = 0; i < NBUCKET; ++i) {', 'struct Node *InsertionSort(struct Node *list) {', '  if (list == 0 || list->next == 0) {', '    if (nodeList->data > k->data) {', '    for (ptr = nodeList; ptr->next != 0; ptr = ptr->next) {', '      if (ptr->next->data > k->data)', '  for (i = 0; i < NARRAY; ++i) {', 'void printBuckets(struct Node *list) {', '    cout << setw(3) << cur->data;', '  int array[NARRAY] = {42, 32, 33, 52, 37, 47, 51};', '  cout << ""Initial array: "" << endl;', '  cout << ""-------------"" << endl;', '  cout << ""-------------"" << endl;', '  cout << ""Sorted array: "" << endl;']",[],['ime Complexity|||\xa0&&&est|||O(n+k)&&&orst|||O(n2)&&&verage|||O(n)&&&pace Complexity|||O(n+k)&&&tability|||Yes'],"['Worst Case Complexity: O(n2)|||When there are elements of close range in the array, they are likely to be placed in the same bucket. This may result in some buckets having more number of elements than others.|||It makes the complexity depend on the sorting algorithm used to sort the elements of the bucket.|||The complexity becomes even worse when the elements are in reverse order. If insertion sort is used to sort elements of the bucket, then the time complexity becomes O(n2).|||Best Case Complexity: O(n+k)|||It occurs when the elements are uniformly distributed in the buckets with a nearly equal number of elements in each bucket.|||The complexity becomes even better if the elements inside the buckets are already sorted.|||If insertion sort is used to sort elements of a bucket then the overall complexity in the best case will be linear ie. O(n+k). O(n) is the complexity for making the buckets and O(k) is the complexity for sorting the elements of the bucket using algorithms having linear time complexity at the best case.|||Average Case Complexity: O(n)|||It occurs when the elements are distributed randomly in the array. Even if the elements are not distributed uniformly, bucket sort runs in linear time. It holds true until the sum of the squares of the bucket sizes is linear in the total number of elements.|||input is uniformly distributed over a range.|||there are floating point values|||Bubble Sort|||Quicksort|||Insertion Sort|||Merge Sort|||Selection Sort|||&&&Suppose, the input array is:|||Input array|||Create an array of size 10. Each slot of this array is used as a bucket for storing elements.|||Array in which each position is a bucket|||Insert elements into the buckets from the array. The elements are inserted according to the range of the bucket.|||In our example code, we have buckets each of ranges from 0 to 1, 1 to 2, 2 to 3,...... (n-1) to n.|||Suppose, an input element is .23 is taken. It is multiplied by size = 10 (ie. .23*10=2.3). Then, it is converted into an integer (ie. 2.3≈2). Finally, .23 is inserted into bucket-2.|||Insert elements into the buckets from the array|||Similarly, .25 is also inserted into the same bucket. Everytime, the floor value of the floating point number is taken.If we take integer numbers as input, we have to divide it by the interval (10 here) to get the floor value.|||Similarly, other elements are inserted into their respective buckets.|||Insert all the elements into the buckets from the array|||The elements of each bucket are sorted using any of the stable sorting algorithms. Here, we have used quicksort (inbuilt function).|||Sort the elements in each bucket|||The elements from each bucket are gathered.|||It is done by iterating through the bucket and inserting an individual element into the original array in each cycle. The element from the bucket is erased once it is copied into the original array.|||Gather elements from each bucket|||']"
53,['Heap Sort Algorithm'],"['In this tutorial, you will learn about the heap sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Relationship between Array Indexes and Tree Elements', 'What is Heap Data Structure?', 'How to ""heapify"" a tree', 'Build max-heap', 'Working of Heap Sort', 'Heap Sort Code in Python, Java, and C/C++', 'Heap Sort Complexity', 'Heap Sort Applications', 'Similar Sorting Algorithms']",[],"['//cdn.programiz.com/cdn/farfuture/yBcZxf7VSecOV66J8-kdwS0lX5mah3oLZzWcbRNqFog/mtime:1586942656/sites/tutorial2program/files/array-vs-heap-indices.png', '//cdn.programiz.com/cdn/farfuture/ku9PI_QBgYEk3neZkm92PDkwkvQzbTQX_aSYg_Ns6M0/mtime:1586942755/sites/tutorial2program/files/max-heap-min-heap.png', '//cdn.programiz.com/cdn/farfuture/30vnL_La8pfA_TTxFypa1W6TTGXTyDBv2Bgk8BAmwKA/mtime:1587702414/sites/tutorial2program/files/heapify-base-case_0.png', '//cdn.programiz.com/cdn/farfuture/fbVKp-kc906qn9j2PHyJAT_WAwHV2XTiV6PvnSssv5U/mtime:1586942750/sites/tutorial2program/files/heapify-when-children-are-heaps.png', '//cdn.programiz.com/cdn/farfuture/1UijfnF1fTdC0naF0xH-tvlIkxey-DLhc88vMAi3G90/mtime:1586942733/sites/tutorial2program/files/heapfy-root-element-when-subtrees-are-max-heaps.png', '//cdn.programiz.com/cdn/farfuture/ep4SjRFZZbEsM10mXLEsWxgk0IUxYwIQTRCStHpxNRE/mtime:1586942720/sites/tutorial2program/files/build-max-heap.png', '//cdn.programiz.com/cdn/farfuture/uGu5NTueaGzATlldVMVkJ0smTclr1loskdD7ASYYp44/mtime:1586942703/sites/tutorial2program/files/build-max-heap-0.png', '//cdn.programiz.com/cdn/farfuture/zVtMrgAyh8rV-yjXHi6BKyR3EhGDftydtGZbA_Jd-Ms/mtime:1586942708/sites/tutorial2program/files/build-max-heap-1.png', '//cdn.programiz.com/cdn/farfuture/xXHiTf614ZV4eJR_Mp5owybelD_kpHozV35Dsj80kUk/mtime:1592889836/sites/tutorial2program/files/build-max-heap-2_01.png', '//cdn.programiz.com/cdn/farfuture/VicaT2DyDXxbtM88OYklajepD4hkdSumEHTg2nBwe7s/mtime:1586942728/sites/tutorial2program/files/heap_sort.png']","[""Let's test it out,"", 'The following example diagram shows Max-Heap and Min-Heap.', 'To learn more about it, please visit Heap Data Structure.', 'We can combine both these conditions in one heapify function as', 'So, we can build a maximum heap as', 'The code below shows the operation.']","['Heap sort works by visualizing the elements of the array as a special kind of complete binary tree called a heap.', 'Note: As a prerequisite, you must know about a complete binary tree and heap data structure.', 'A complete binary tree has an interesting property that we can use to find the children and parents of any node.', 'Let us also confirm that the rules hold for finding parent of any node', 'Heap is a special tree-based data structure. A binary tree is said to follow a heap data structure if', ""If you're worked with recursive algorithms before, you've probably identified that this must be the base case."", ""Now let's think of another scenario in which there is more than one level."", ""The top element isn't a max-heap but all the sub-trees are max-heaps."", ""If you've understood everything till here, congratulations, you are on your way to mastering the Heap sort."", 'Heap Sort has O(nlog n) time complexities for all the cases ( best case, average case, and worst case).', 'Let us understand the reason why. The height of a complete binary tree containing n elements is log n']","['Heap Sort is a popular and efficient sorting algorithm in computer programming. Learning how to write the heap sort algorithm requires knowledge of two types of data structures - arrays and trees.', 'The initial set of numbers that we want to sort is stored in an array e.g. [10, 3, 76, 34, 23, 32] and after sorting, we get a sorted array [3,10,23,32,34,76].', 'If the index of any element in the array is i, the element in the index 2i+1 will become the left child and element in 2i+2 index will become the right child. Also, the parent of any element at index i is given by the lower bound of (i-1)/2.', 'Understanding this mapping of array indexes to tree positions is critical to understanding how the Heap Data Structure works and how it is used to implement Heap Sort.', 'Starting from a complete binary tree, we can modify it to become a Max-Heap by running a function called heapify on all the non-leaf elements of the heap.', ""Since heapify uses recursion, it can be difficult to grasp. So let's first think about how you would heapify a tree with just three elements."", ""The example above shows two scenarios - one in which the root is the largest element and we don't need to do anything. And another in which the root had a larger element as a child and we needed to swap to maintain max-heap property."", 'To maintain the max-heap property for the entire tree, we will have to keep pushing 2 downwards until it reaches its correct position.', 'Thus, to maintain the max-heap property in a tree where both sub-trees are max-heaps, we need to run heapify on the root element repeatedly until it is larger than its children or it becomes a leaf node.', 'This function works for both the base case and for a tree of any size. We can thus move the root element to the correct position to maintain the max-heap status for any tree size as long as the sub-trees are max-heaps.', 'To build a max-heap from any tree, we can thus start heapifying each sub-tree from the bottom up and end up with a max-heap after the function is applied to all the elements including the root element.', ""In the case of a complete tree, the first index of a non-leaf node is given by n/2 - 1. All other nodes after that are leaf-nodes and thus don't need to be heapified."", 'As shown in the above diagram, we start by heapifying the lowest smallest trees and gradually move up until we reach the root element.', 'As we have seen earlier, to fully heapify an element whose subtrees are already max-heaps, we need to keep comparing the element with its left and right children and pushing it downwards until it reaches a point where both its children are smaller than it.', 'In the worst case scenario, we will need to move an element from the root to the leaf node making a multiple of log(n) comparisons and swaps.', 'During the build_max_heap stage, we do that for n/2 elements so the worst case complexity of the build_heap step is n/2*log n ~ nlog n.', 'During the sorting step, we exchange the root element with the last element and heapify the root element. For each element, this again takes log n worst time because we might have to bring the element all the way from the root to the leaf. Since we repeat this n times, the heap_sort step is also nlog n.', 'Also since the build_max_heap and heap_sort steps are executed one after another, the algorithmic complexity is not multiplied and it remains in the order of nlog n.', 'Also it performs sorting in O(1) space complexity. Compared with Quick Sort, it has a better worst case ( O(nlog n) ). Quick Sort has complexity O(n^2) for worst case. But in other cases, Quick Sort is fast. Introsort is an alternative to heapsort that combines quicksort and heapsort to retain advantages of both: worst case speed of heapsort and average speed of quicksort.', ""Systems concerned with security and embedded systems such as Linux Kernel use Heap Sort because of the O(n log n) upper bound on Heapsort's running time and constant O(1) upper bound on its auxiliary storage."", ""Although Heap Sort has O(n log n) time complexity even for the worst case, it doesn't have more applications ( compared to other sorting algorithms like Quick Sort, Merge Sort ). However, its underlying data structure, heap, can be efficiently used if we want to extract the smallest (or largest) from the list of items without the overhead of keeping the remaining items in the sorted order. For e.g Priority Queues.""]","['heapify(array)', '    Root = array[0]', '    if(Root != Largest)', '          Swap(Root, Largest)', '  int largest = i;', '  int left = 2 * i + 1;', '  int right = 2 * i + 2;', '    largest = left;', '    largest = right;', '    if (largest != i) {', '      heapify(arr, n, i);', '      swap(&arr[0], &arr[i]);', '      heapify(arr, i, 0);', '# Heap Sort in python', '  def heapify(arr, n, i):', '      largest = i', '      l = 2 * i + 1', '      r = 2 * i + 2', '          largest = l', '          largest = r', '      if largest != i:', '  def heapSort(arr):', '      n = len(arr)', '      # Build max heap', '          heapify(arr, n, i)', '          # Swap', '          heapify(arr, i, 0)', '  arr = [1, 12, 9, 5, 6, 10]', '  heapSort(arr)', '  n = len(arr)', '  print(""Sorted array is"")', '  for i in range(n):', '  public class HeapSort {', '      int n = arr.length;', '        heapify(arr, n, i);', '        int temp = arr[0];', '        arr[0] = arr[i];', '        arr[i] = temp;', '        heapify(arr, i, 0);', '      int largest = i;', '      int l = 2 * i + 1;', '      int r = 2 * i + 2;', '        largest = l;', '        largest = r;', '      if (largest != i) {', '        int swap = arr[i];', '        arr[i] = arr[largest];', '        arr[largest] = swap;', '      int n = arr.length;', '      System.out.println();', '      hs.sort(arr);', '      printArray(arr);', '  #include <stdio.h>', '  void swap(int *a, int *b) {', '    int temp = *a;', '    *a = *b;', '    *b = temp;', '    int largest = i;', '    int left = 2 * i + 1;', '    int right = 2 * i + 2;', '      largest = left;', '      largest = right;', '    if (largest != i) {', '      heapify(arr, n, i);', '      swap(&arr[0], &arr[i]);', '      heapify(arr, i, 0);', '      printf(""%d "", arr[i]);', '    printf(""\\n"");', '  int main() {', '    heapSort(arr, n);', '    printArray(arr, n);', '  #include <iostream>', '  using namespace std;', '    int largest = i;', '    int left = 2 * i + 1;', '    int right = 2 * i + 2;', '      largest = left;', '      largest = right;', '    if (largest != i) {', '      heapify(arr, n, i);', '      swap(arr[0], arr[i]);', '      heapify(arr, i, 0);', '      cout << arr[i] << "" "";', '    cout << ""\\n"";', '  int main() {', '    heapSort(arr, n);', '    printArray(arr, n);']","['    Largest = largest( array[0] , array [2*0 + 1]. array[2*0+2])', 'void heapify(int arr[], int n, int i) {', '  if (left < n && arr[left] > arr[largest])', '  if (right < n && arr[right] > arr[largest])', '      swap(&arr[i], &arr[largest]);', '    for (int i = n / 2 - 1; i >= 0; i--)', '    for (int i = n - 1; i >= 0; i--) {', '      # Find largest among root and children', '      if l < n and arr[i] < arr[l]:', '      if r < n and arr[largest] < arr[r]:', '      # If root is not largest, swap with largest and continue heapifying', '          arr[i], arr[largest] = arr[largest], arr[i]', '          heapify(arr, n, largest)', '      for i in range(n//2, -1, -1):', '      for i in range(n-1, 0, -1):', '          arr[i], arr[0] = arr[0], arr[i]', '          # Heapify root element', '      print(""%d "" % arr[i], end=\'\')', '    public void sort(int arr[]) {', '      for (int i = n / 2 - 1; i >= 0; i--) {', '      for (int i = n - 1; i >= 0; i--) {', '    void heapify(int arr[], int n, int i) {', '      if (l < n && arr[l] > arr[largest])', '      if (r < n && arr[r] > arr[largest])', '        heapify(arr, n, largest);', '    static void printArray(int arr[]) {', '      for (int i = 0; i < n; ++i)', '        System.out.print(arr[i] + "" "");', '    public static void main(String args[]) {', '      int arr[] = { 1, 12, 9, 5, 6, 10 };', '      HeapSort hs = new HeapSort();', '      System.out.println(""Sorted array is"");', '  void heapify(int arr[], int n, int i) {', '    if (left < n && arr[left] > arr[largest])', '    if (right < n && arr[right] > arr[largest])', '      swap(&arr[i], &arr[largest]);', '  void heapSort(int arr[], int n) {', '    for (int i = n / 2 - 1; i >= 0; i--)', '    for (int i = n - 1; i >= 0; i--) {', '  void printArray(int arr[], int n) {', '    int arr[] = {1, 12, 9, 5, 6, 10};', '    int n = sizeof(arr) / sizeof(arr[0]);', '    printf(""Sorted array is \\n"");', '  void heapify(int arr[], int n, int i) {', '    if (left < n && arr[left] > arr[largest])', '    if (right < n && arr[right] > arr[largest])', '      swap(arr[i], arr[largest]);', '  void heapSort(int arr[], int n) {', '    for (int i = n / 2 - 1; i >= 0; i--)', '    for (int i = n - 1; i >= 0; i--) {', '  void printArray(int arr[], int n) {', '    int arr[] = {1, 12, 9, 5, 6, 10};', '    int n = sizeof(arr) / sizeof(arr[0]);', '    cout << ""Sorted array is \\n"";']","['Left child of 1 (index 0)', '= element in (2*0+1) index ', '= element in 1 index ', '= 12', 'Right child of 1', '= element in (2*0+2) index', '= element in 2 index ', '= 9', 'Similarly,', 'Left child of 12 (index 1)', '= element in (2*1+1) index', '= element in 3 index', '= 5', 'Right child of 12', '= element in (2*1+2) index', '= element in 4 index', '= 6', 'Parent of 9 (position 2) ', '= (2-1)/2 ', '= ½ ', '= 0.5', '~ 0 index ', '= 1', 'Parent of 12 (position 1) ', '= (1-1)/2 ', '= 0 index ', '= 1']",['ime Complexity|||\xa0&&&est|||O(nlog n)&&&orst|||O(nlog n)&&&verage|||O(nlog n)&&&pace Complexity|||O(1)&&&tability|||No'],"['it is a complete binary tree|||All nodes in the tree follow the property that they are greater than their children i.e. the largest element is at the root and both its children and smaller than the root and so on. Such a heap is called a max-heap. If instead, all nodes are smaller than their children, it is called a min-heap|||&&&Since the tree satisfies Max-Heap property, then the largest item is stored at the root node.|||Swap: Remove the root element and put at the end of the array (nth position) Put the last item of the tree (heap) at the vacant place.|||Remove: Reduce the size of the heap by 1.|||Heapify: Heapify the root element again so that we have the highest element at root.|||The process is repeated until all the items of the list are sorted.|||Quicksort|||Merge Sort|||']"
54,['Shell Sort Algorithm'],"['In this tutorial, you will learn about the shell sort algorithm and its implementation in Python, Java, C, and C++.']",[],[],"['Working of Shell Sort', 'Shell Sort Algorithm', 'Shell Sort Code in Python, Java, and C/C++', 'Shell Sort Complexity', 'Shell Sort Applications', 'Other Sorting Algorithms']","['Time Complexity', 'Space Complexity:']","['//cdn.programiz.com/cdn/farfuture/oCTu5VnBtOj-EguONZh7omUmqK57UWdv7K140UW58u0/mtime:1582112622/sites/tutorial2program/files/shell-sort-0.0.png', '//cdn.programiz.com/cdn/farfuture/DTqGWkBqy4Ui0eRi_qNJE1pothruM99CpS6N1ziBhy8/mtime:1582112622/sites/tutorial2program/files/shell-sort-0.1.png', '//cdn.programiz.com/cdn/farfuture/RM9zyvnjAlLBN2f6qyrZOZGf3Z0hDuSEo1XU95UAaQs/mtime:1582112622/sites/tutorial2program/files/shell-sort-0.2.png', '//cdn.programiz.com/cdn/farfuture/mWN26SdYDVUrjxrxkn_LMQAnuBMIOeK1Rafy8bOb-FQ/mtime:1582112622/sites/tutorial2program/files/shell-sort-0.3.png', '//cdn.programiz.com/cdn/farfuture/8E8UaAuB56Z4ATHhsHvm5mtg_zfeTLXnwWuVT97DQc8/mtime:1582112622/sites/tutorial2program/files/shell-sort-0.4.png', '//cdn.programiz.com/cdn/farfuture/D1p118uTKPJe0dW5hiapQSVzoclNdhjrlL8312Q9m7M/mtime:1619172539/sites/tutorial2program/files/shell-sort-step_4.png', '//cdn.programiz.com/cdn/farfuture/k4hVaQ09MUohD3kYSLzRMTCwsbW_DjarXxW2r-JVuHk/mtime:1619172531/sites/tutorial2program/files/shell-sort-step_5.png']","['The space complexity for shell sort is O(1).', 'Shell sort is used when:']",['Note: The performance of the shell sort depends on the type of sequence used for a given input array.'],"['Shell sort is a generalized version of the insertion sort algorithm. It first sorts elements that are far apart from each other and successively reduces the interval between the elements to be sorted.', 'The interval between the elements is reduced based on the sequence used. Some of the optimal sequences that can be used in the shell sort algorithm are:', 'Shell sort is an unstable sorting algorithm because this algorithm does not examine the elements lying in between the intervals.', 'The complexity depends on the interval chosen. The above complexities differ for different increment sequences chosen. Best increment sequence is unknown.']","['shellSort(array, size)', 'end shellSort', '# Shell sort in python', 'def shellSort(array, n):', '    interval = n // 2', '    while interval > 0:', '            temp = array[i]', '            j = i', '                j -= interval', '            array[j] = temp', '        interval //= 2', 'size = len(data)', 'shellSort(data, size)', 'print(data)', 'import java.util.Arrays;', 'class ShellSort {', '    int temp = array[i];', '    int j;', '    array[j] = temp;', '  int size = data.length;', '  ss.shellSort(data, size);', '#include <stdio.h>', '      int temp = array[i];', '      int j;', '      array[j] = temp;', '    printf(""%d  "", array[i]);', '  printf(""\\n"");', 'int main() {', '  shellSort(data, size);', '  printf(""Sorted array: \\n"");', '  printArray(data, size);', '#include <iostream>', 'using namespace std;', '      int temp = array[i];', '      int j;', '      array[j] = temp;', '  int i;', '  for (i = 0; i < size; i++)', '    cout << array[i] << "" "";', '  cout << endl;', 'int main() {', '  shellSort(data, size);', '  cout << ""Sorted array: \\n"";', '  printArray(data, size);']","['  for interval i <- size/2n down to 1', '    for each interval ""i"" in array', '        sort all the elements at interval ""i""', '    # Rearrange elements at each n/2, n/4, n/8, ... intervals', '        for i in range(interval, n):', '            while j >= interval and array[j - interval] > temp:', '                array[j] = array[j - interval]', ""print('Sorted Array in Ascending Order:')"", '  void shellSort(int array[], int n) {', '  for (int interval = n / 2; interval > 0; interval /= 2) {', '    for (int i = interval; i < n; i += 1) {', '    for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {', '      array[j] = array[j - interval];', '  public static void main(String args[]) {', '  int[] data = { 9, 8, 3, 7, 5, 6, 4, 1 };', '  ShellSort ss = new ShellSort();', '  System.out.println(""Sorted Array in Ascending Order: "");', '  System.out.println(Arrays.toString(data));', 'void shellSort(int array[], int n) {', '  for (int interval = n / 2; interval > 0; interval /= 2) {', '    for (int i = interval; i < n; i += 1) {', '      for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {', '        array[j] = array[j - interval];', 'void printArray(int array[], int size) {', '  for (int i = 0; i < size; ++i) {', '  int data[] = {9, 8, 3, 7, 5, 6, 4, 1};', '  int size = sizeof(data) / sizeof(data[0]);', 'void shellSort(int array[], int n) {', '  for (int interval = n / 2; interval > 0; interval /= 2) {', '    for (int i = interval; i < n; i += 1) {', '      for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {', '        array[j] = array[j - interval];', 'void printArray(int array[], int size) {', '  int data[] = {9, 8, 3, 7, 5, 6, 4, 1};', '  int size = sizeof(data) / sizeof(data[0]);']",[],['ime Complexity|||\xa0&&&est|||O(nlog n)&&&orst|||O(n2)&&&verage|||O(nlog n)&&&pace Complexity|||O(1)&&&tability|||No'],"[""Shell's original sequence: N/2 , N/4 , …, 1|||Knuth's increments: 1, 4, 13, …, (3k – 1) / 2|||Sedgewick's increments: 1, 8, 23, 77, 281, 1073, 4193, 16577...4j+1+ 3·2j+ 1|||Hibbard's increments: 1, 3, 7, 15, 31, 63, 127, 255, 511…|||Papernov & Stasevich increment: 1, 3, 5, 9, 17, 33, 65,...|||Pratt: 1, 2, 3, 4, 6, 9, 8, 12, 18, 27, 16, 24, 36, 54, 81....|||Worst Case Complexity: less than or equal to O(n2)|||Worst case complexity for shell sort is always less than or equal to O(n2).|||According to Poonen Theorem, worst case complexity for shell sort is Θ(Nlog N)2/(log log N)2) or Θ(Nlog N)2/log log N) or Θ(N(log N)2) or something in between.|||Best Case Complexity: O(n*log n)|||When the array is already sorted, the total number of comparisons for each interval (or increment) is equal to the size of the array.|||Average Case Complexity: O(n*log n)|||It is around O(n1.25).|||calling a stack is overhead. uClibc library uses this sort.|||recursion exceeds a limit. bzip2 compressor uses it.|||Insertion sort does not perform well when the close elements are far apart. Shell sort helps in reducing the distance between the close elements. Thus, there will be less number of swappings to be performed.|||&&&Suppose, we need to sort the following array.|||Initial array|||We are using the shell's original sequence (N/2, N/4, ...1) as intervals in our algorithm.|||In the first loop, if the array size is N = 8 then, the elements lying at the interval of N/2 = 4 are compared and swapped if they are not in order.|||The 0th element is compared with the 4th element.|||If the 0th element is greater than the 4th one then, the 4th element is first stored in temp variable and the 0th element (ie. greater element) is stored in the 4th position and the element stored in temp is stored in the 0th position.|||Rearrange the elements at n/2 interval|||This process goes on for all the remaining elements.|||Rearrange all the elements at n/2 interval||||||In the second loop, an interval of N/4 = 8/4 = 2 is taken and again the elements lying at these intervals are sorted.|||Rearrange the elements at n/4 interval|||You might get confused at this point.|||All the elements in the array lying at the current interval are compared.|||The elements at 4th and 2nd position are compared. The elements at 2nd and 0th position are also compared. All the elements in the array lying at the current interval are compared.|||The same process goes on for remaining elements.|||Rearrange all the elements at n/4 interval|||Finally, when the interval is N/8 = 8/8 =1 then the array elements lying at the interval of 1 are sorted. The array is now completely sorted.|||Rearrange the elements at n/8 interval|||The 0th element is compared with the 4th element.|||If the 0th element is greater than the 4th one then, the 4th element is first stored in temp variable and the 0th element (ie. greater element) is stored in the 4th position and the element stored in temp is stored in the 0th position.|||Rearrange the elements at n/2 interval|||This process goes on for all the remaining elements.|||Rearrange all the elements at n/2 interval|||Bubble Sort|||Quicksort|||Insertion Sort|||Selection Sort|||""]"
55,['Linear Search'],"['In this tutorial, you will learn about linear search. Also, you will find working examples of linear search C, C++, Java and Python.']",[],[],"['How Linear Search Works?', 'Linear Search Algorithm', 'Python, Java and C/C++ Examples', 'Linear Search Complexities', 'Linear Search Applications']",[],"['//cdn.programiz.com/sites/tutorial2program/files/linear-search-initial-array.png', '//cdn.programiz.com/sites/tutorial2program/files/linear-search-comparisons.png', '//cdn.programiz.com/sites/tutorial2program/files/linear-search-found.png']","['Time Complexity: O(n)', 'Space Complexity: O(1)']",['The following steps are followed to search for an element k = 1 in the list below.'],['Linear search is a sequential searching algorithm where we start from one end and check every element of the list until the desired element is found. It is the simplest searching algorithm.'],"['# Linear Search in Python', 'def linearSearch(array, n, x):', '    for i in range(0, n):', '        if (array[i] == x):', '            return i', '    return -1', 'array = [2, 4, 0, 1, 9]', 'n = len(array)', 'if(result == -1):', '    print(""Element not found"")', 'class LinearSearch {', '  int n = array.length;', '    if (array[i] == x)', '    return i;', '  return -1;', '  int x = 1;', '  if (result == -1)', '#include <stdio.h>', '  for (int i = 0; i < n; i++)', '    if (array[i] == x)', '      return i;', '  return -1;', 'int main() {', '  int x = 1;', '#include <iostream>', 'using namespace std;', '  for (int i = 0; i < n; i++)', '    if (array[i] == x)', '      return i;', '  return -1;', 'int main() {', '  int x = 1;']","['    # Going through array sequencially', 'result = linearSearch(array, n, x)', '    print(""Element found at index: "", result)', '  public static int linearSearch(int array[], int x) {', '  public static void main(String args[]) {', '  int array[] = { 2, 4, 0, 1, 9 };', '  int result = linearSearch(array, x);', '    System.out.print(""Element not found"");', '    System.out.print(""Element found at index: "" + result);', 'int search(int array[], int n, int x) {', '  int array[] = {2, 4, 0, 1, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = search(array, n, x);', '  (result == -1) ? printf(""Element not found"") : printf(""Element found at index: %d"", result);', 'int search(int array[], int n, int x) {', '  int array[] = {2, 4, 0, 1, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = search(array, n, x);', '  (result == -1) ? cout << ""Element not found"" : cout << ""Element found at index: "" << result;']","['LinearSearch(array, key)', '  for each item in the array', '    if item == value', '      return its index']",[],"['Start from the first element, compare k with each element x.||||||Compare with each element|||If x == k, return the index.|||Element found|||Else, return not found.|||For searching operations in smaller arrays (<100 items).|||']"
56,['Binary Search'],"['In this tutorial, you will learn how Binary Search sort works. Also, you will find working examples of Binary Search in C, C++, Java and Python.']",[],[],"['Binary Search Working', 'Binary Search Algorithm', 'Python, Java, C/C++ Examples (Iterative Method)', 'Python, Java, C/C++ Examples (Recursive Method)', 'Binary Search Complexity', 'Binary Search Applications']","['Iteration Method', 'Recursive Method']","['//cdn.programiz.com/sites/tutorial2program/files/binary-search-initial-array.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-search-set-pointers.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-search-mid.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-search-find-mid.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-search-mid-again.png', '//cdn.programiz.com/sites/tutorial2program/files/binary-search-found.png']","['The recursive method follows the divide and conquer approach.', 'The general steps for both methods are discussed below.', 'Time Complexities', 'Space Complexity', 'The space complexity of the binary search is O(1).']","[""Binary Search is a searching algorithm for finding an element's position in a sorted array."", 'In this approach, the element is always searched in the middle of a portion of an array.', 'Binary Search Algorithm can be implemented in two ways which are discussed below.']","['Binary search can be implemented only on a sorted list of items. If the elements are not sorted already, we need to sort them first.']","['# Binary Search in python', '    while low <= high:', '        if array[mid] == x:', '            return mid', '        elif array[mid] < x:', '            low = mid + 1', '        else:', '            high = mid - 1', '    return -1', 'array = [3, 4, 5, 6, 7, 8, 9]', 'if result != -1:', '    print(""Not found"")', 'class BinarySearch {', '    while (low <= high) {', '      if (array[mid] == x)', '        return mid;', '      if (array[mid] < x)', '        low = mid + 1;', '      else', '        high = mid - 1;', '    return -1;', '    int n = array.length;', '    int x = 4;', '    if (result == -1)', '    else', '#include <stdio.h>', '  while (low <= high) {', '    if (array[mid] == x)', '      return mid;', '    if (array[mid] < x)', '      low = mid + 1;', '    else', '      high = mid - 1;', '  return -1;', 'int main(void) {', '  int x = 4;', '  if (result == -1)', '    printf(""Not found"");', '  return 0;', '#include <iostream>', 'using namespace std;', '  while (low <= high) {', '    if (array[mid] == x)', '      return mid;', '    if (array[mid] < x)', '      low = mid + 1;', '    else', '      high = mid - 1;', '  return -1;', 'int main(void) {', '  int x = 4;', '  if (result == -1)', '    printf(""Not found"");', '# Binary Search in python', '    if high >= low:', '        if array[mid] == x:', '            return mid', '        # Search the left half', '        elif array[mid] > x:', '        else:', '    else:', '        return -1', 'array = [3, 4, 5, 6, 7, 8, 9]', 'if result != -1:', '    print(""Not found"")', 'class BinarySearch {', '    if (high >= low) {', '      if (array[mid] == x)', '        return mid;', '      if (array[mid] > x)', '    return -1;', '    int n = array.length;', '    int x = 4;', '    if (result == -1)', '    else', '#include <stdio.h>', '  if (high >= low) {', '    if (array[mid] == x)', '      return mid;', '    if (array[mid] > x)', '  return -1;', 'int main(void) {', '  int x = 4;', '  if (result == -1)', '    printf(""Not found"");', '#include <iostream>', 'using namespace std;', '  if (high >= low) {', '    if (array[mid] == x)', '      return mid;', '    if (array[mid] > x)', '  return -1;', 'int main(void) {', '  int x = 4;', '  if (result == -1)', '    printf(""Not found"");']","['def binarySearch(array, x, low, high):', '    # Repeat until the pointers low and high meet each other', '        mid = low + (high - low)//2', 'result = binarySearch(array, x, 0, len(array)-1)', '    print(""Element is present at index "" + str(result))', '  int binarySearch(int array[], int x, int low, int high) {', '      int mid = low + (high - low) / 2;', '  public static void main(String args[]) {', '    BinarySearch ob = new BinarySearch();', '    int array[] = { 3, 4, 5, 6, 7, 8, 9 };', '    int result = ob.binarySearch(array, x, 0, n - 1);', '      System.out.println(""Not found"");', '      System.out.println(""Element found at index "" + result);', 'int binarySearch(int array[], int x, int low, int high) {', '    int mid = low + (high - low) / 2;', '  int array[] = {3, 4, 5, 6, 7, 8, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = binarySearch(array, x, 0, n - 1);', '    printf(""Element is found at index %d"", result);', 'int binarySearch(int array[], int x, int low, int high) {', '    int mid = low + (high - low) / 2;', '  int array[] = {3, 4, 5, 6, 7, 8, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = binarySearch(array, x, 0, n - 1);', '    printf(""Element is found at index %d"", result);', 'def binarySearch(array, x, low, high):', '        mid = low + (high - low)//2', '        # If found at mid, then return it', '            return binarySearch(array, x, low, mid-1)', '            return binarySearch(array, x, mid + 1, high)', 'result = binarySearch(array, x, 0, len(array)-1)', '    print(""Element is present at index "" + str(result))', '  int binarySearch(int array[], int x, int low, int high) {', '      int mid = low + (high - low) / 2;', '        return binarySearch(array, x, low, mid - 1);', '      return binarySearch(array, x, mid + 1, high);', '  public static void main(String args[]) {', '    BinarySearch ob = new BinarySearch();', '    int array[] = { 3, 4, 5, 6, 7, 8, 9 };', '    int result = ob.binarySearch(array, x, 0, n - 1);', '      System.out.println(""Not found"");', '      System.out.println(""Element found at index "" + result);', 'int binarySearch(int array[], int x, int low, int high) {', '    int mid = low + (high - low) / 2;', '      return binarySearch(array, x, low, mid - 1);', '    return binarySearch(array, x, mid + 1, high);', '  int array[] = {3, 4, 5, 6, 7, 8, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = binarySearch(array, x, 0, n - 1);', '    printf(""Element is found at index %d"", result);', 'int binarySearch(int array[], int x, int low, int high) {', '    int mid = low + (high - low) / 2;', '      return binarySearch(array, x, low, mid - 1);', '    return binarySearch(array, x, mid + 1, high);', '  int array[] = {3, 4, 5, 6, 7, 8, 9};', '  int n = sizeof(array) / sizeof(array[0]);', '  int result = binarySearch(array, x, 0, n - 1);', '    printf(""Element is found at index %d"", result);']","['do until the pointers low and high meet each other.', '    mid = (low + high)/2', '    if (x == arr[mid])', '        return mid', '    else if (x > arr[mid]) // x is on the right side', '        low = mid + 1', '    else                       // x is on the left side', '        high = mid - 1', 'binarySearch(arr, x, low, high)', '    if low > high', '        return False ', '    else', '        mid = (low + high) / 2 ', '        if x == arr[mid]', '            return mid', '        else if x > arr[mid]        // x is on the right side', '            return binarySearch(arr, x, mid + 1, high)', '        else                               // x is on the right side', '            return binarySearch(arr, x, low, mid - 1)']",[],"['Best case complexity: O(1)|||Average case complexity: O(log n)|||Worst case complexity: O(log n)|||In libraries of Java, .Net, C++ STL|||While debugging, the binary search is used to pinpoint the place where the error happens.|||&&&Iterative Method|||Recursive Method|||The array in which searching is to be performed is:|||Initial array|||Let x = 4 be the element to be searched.|||Set two pointers low and high at the lowest and the highest positions respectively.|||Setting pointers|||Find the middle element mid of the array ie. arr[(low + high)/2] = 6.|||Mid element|||If x == mid, then return mid.Else, compare the element to be searched with m.|||If x > mid, compare x with the middle element of the elements on the right side of mid. This is done by setting low to low = mid + 1.|||Else, compare x with the middle element of the elements on the left side of mid. This is done by setting high to high = mid - 1.|||Finding mid element|||Repeat steps 3 to 6 until low meets high.|||Mid element|||x = 4 is found.|||Found|||']"
57,['Greedy Algorithm'],"['In this tutorial, you will learn what a Greedy Algorithm is. Also, you will find an example of a greedy approach.']",[],[],"['Advantages of Greedy Approach', 'Drawback of Greedy Approach', 'Greedy Algorithm', 'Example - Greedy Approach', 'Different Types of Greedy Algorithm']",[],"['//cdn.programiz.com/cdn/farfuture/6mg9RE5q583xEvKZ9R0jpGcvYN7uSLQNwyuRlxe2-Do/mtime:1623409564/sites/tutorial2program/files/greedy_approach_na.png', '//cdn.programiz.com/cdn/farfuture/PXnueYkTeqK8lCugIGkiZ4e7UwaY70R8SMnFSNK4TSM/mtime:1623409557/sites/tutorial2program/files/greedy_approach_longest.png']","['1. Greedy Choice Property', '2. Optimal Substructure', 'Greedy Approach', ""Let's now use this algorithm to solve a problem."", 'Solution:']","['The algorithm never reverses the earlier decision even if the choice is wrong. It works in a top-down approach.', 'However, we can determine if the algorithm can be used with any problem if the problem has the following properties:', ""1. Let's start with the root node 20. The weight of the right child is 3 and the weight of the left child is 2."", '3. Finally the weight of an only child of 3 is 1. This gives us our final result 20 + 3 + 1 = 24.', 'Therefore, greedy algorithms do not always give an optimal/feasible solution.']","[""A greedy algorithm is an approach for solving a problem by selecting the best option available at the moment. It doesn't worry whether the current best result will bring the overall optimal result."", ""This algorithm may not produce the best result for all the problems. It's because it always goes for the local best choice to produce the global best result."", 'If an optimal solution to the problem can be found by choosing the best choice at each step without reconsidering the previous steps once chosen, the problem can be solved using a greedy approach. This property is called greedy choice property.', 'If the optimal overall solution to the problem corresponds to the optimal solution to its subproblems, then the problem can be solved using a greedy approach. This property is called optimal substructure.', ""As mentioned earlier, the greedy algorithm doesn't always produce the optimal solution. This is the major disadvantage of the algorithm"", ""For example, suppose we want to find the longest path in the graph below from root to leaf. Let's use the greedy algorithm here."", '2. Our problem is to find the largest path. And, the optimal solution at the moment is 3. So, the greedy algorithm will choose 3.', 'However, it is not the optimal solution. There is another path that carries more weight (20 + 2 + 10 = 32) as shown in the image below.']",[],[],"['Problem: You have to make a change of an amount using the smallest possible number of coins.', 'Amount: $18', 'Available coins are', '  $5 coin', '  $2 coin', '  $1 coin', 'There is no limit to the number of each coin you can use.']",[],"[""The algorithm is easier to describe.|||This algorithm can perform better than other algorithms (but, not in all cases).|||Selection Sort|||Knapsack Problem|||Minimum Spanning Tree|||Single-Source Shortest Path Problem|||Job Scheduling Problem|||Prim's Minimal Spanning Tree Algorithm|||Kruskal's Minimal Spanning Tree Algorithm|||Dijkstra's Minimal Spanning Tree Algorithm|||Huffman Coding|||Ford-Fulkerson Algorithm|||&&&To begin with, the solution set (containing answers) is empty.|||At each step, an item is added to the solution set until a solution is reached.|||If the solution set is feasible, the current item is kept.|||Else, the item is rejected and never considered again.|||Create an empty solution-set = { }. Available coins are {5, 2, 1}.|||We are supposed to find the sum = 18. Let's start with sum = 0.|||Always select the coin with the largest value (i.e. 5) until the sum > 18. (When we select the largest value at each step, we hope to reach the destination faster. This concept is called greedy choice property.)|||In the first iteration, solution-set = {5} and sum = 5.|||In the second iteration, solution-set = {5, 5} and sum = 10.|||In the third iteration, solution-set = {5, 5, 5} and sum = 15.|||In the fourth iteration, solution-set = {5, 5, 5, 2} and sum = 17. (We cannot select 5 here because if we do so, sum = 20 which is greater than 18. So, we select the 2nd largest item which is 2.)|||Similarly, in the fifth iteration, select 1. Now sum = 18 and solution-set = {5, 5, 5, 2, 1}.|||""]"
58,['Ford-Fulkerson Algorithm'],"['In this tutorial, you will learn what Ford-Fulkerson algorithm is. Also, you will find working examples of finding maximum flow in a flow network in C, C++, Java and Python.']",[],[],"['Terminologies Used', 'How Ford-Fulkerson Algorithm works?', 'Ford-Fulkerson Example', 'Python, Java and C/C++ Examples', 'Ford-Fulkerson Applications']","['Augmenting Path', 'Residual Graph', 'Residual Capacity']","['//cdn.programiz.com/sites/tutorial2program/files/flow-network.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-example.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-1.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-1-update.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-2.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-2-update.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-3.png', '//cdn.programiz.com/sites/tutorial2program/files/flow-network-3-update.png']","['It is the path available in a flow network.', 'It represents the flow network that has additional possible flow.', 'The algorithm follows:', 'The above concepts can be understood with the example below.', 'The flow of all the edges is 0 at the beginning.']","['Ford-Fulkerson algorithm is a greedy approach for calculating the maximum possible flow in a network or a graph.', 'It is the capacity of the edge after subtracting the flow from the maximum capacity.', 'We can also consider reverse-path if required because if we do not consider them, we may never find a maximum flow.', 'Note that if the capacity for any edge is full, then that path cannot be used.']","['A term, flow network, is used to describe a network of vertices and edges with a source (S) and a sink (T). Each vertex, except S and T, can receive and send an equal amount of stuff through it. S can only send and T can only receive stuff.', 'We can visualize the understanding of the algorithm using a flow of liquid inside a network of pipes of different capacities. Each pipe has a certain capacity of liquid it can transfer at an instance. For this algorithm, we are going to find how much liquid can be flowed from the source to the sink at an instance using the network.']","['class Graph:', '    def __init__(self, graph):', '        self.graph = graph', '        self. ROW = len(graph)', '        queue = []', '        queue.append(s)', '        visited[s] = True', '        while queue:', '            u = queue.pop(0)', '        max_flow = 0', '            s = sink', '                s = parent[s]', '            v = sink', '                u = parent[v]', '                v = parent[v]', '        return max_flow', 'graph = [[0, 8, 0, 0, 3, 0],', '         [0, 0, 9, 0, 0, 0],', '         [0, 0, 0, 0, 7, 2],', '         [0, 0, 0, 0, 0, 5],', '         [0, 0, 7, 4, 0, 0],', '         [0, 0, 0, 0, 0, 0]]', 'g = Graph(graph)', 'source = 0', 'sink = 5', 'import java.util.LinkedList;', 'class FordFulkerson {', '  static final int V = 6;', '      visited[i] = false;', '    queue.add(s);', '    visited[s] = true;', '    p[s] = -1;', '      int u = queue.poll();', '          queue.add(v);', '          p[v] = u;', '          visited[v] = true;', '        }', '    int u, v;', '    for (u = 0; u < V; u++)', '      for (v = 0; v < V; v++)', '    int p[] = new int[V];', '    int max_flow = 0;', '        u = p[v];', '        u = p[v];', '      max_flow += path_flow;', '    return max_flow;', '#include <stdio.h>', '#define A 0', '#define B 1', '#define C 2', '#define MAX_NODES 1000', '#define O 1000000000', 'int color[MAX_NODES];', 'int pred[MAX_NODES];', 'int min(int x, int y) {', '  return x < y ? x : y;', 'int head, tail;', 'int q[MAX_NODES + 2];', 'void enqueue(int x) {', '  q[tail] = x;', '  tail++;', '  color[x] = B;', 'int dequeue() {', '  int x = q[head];', '  head++;', '  color[x] = C;', '  return x;', '  int u, v;', '  for (u = 0; u < n; u++) {', '    color[u] = A;', '  head = tail = 0;', '  enqueue(start);', '  pred[start] = -1;', '  while (head != tail) {', '    u = dequeue();', '    for (v = 0; v < n; v++) {', '        enqueue(v);', '        pred[v] = u;', '  return color[target] == C;', '  int i, j, u;', '  int max_flow = 0;', '  for (i = 0; i < n; i++) {', '    for (j = 0; j < n; j++) {', '      flow[i][j] = 0;', '  while (bfs(source, sink)) {', '    int increment = O;', '    max_flow += increment;', '  return max_flow;', 'int main() {', '      capacity[i][j] = 0;', '  n = 6;', '  e = 7;', '  capacity[0][1] = 8;', '  capacity[0][4] = 3;', '  capacity[1][2] = 9;', '  capacity[2][4] = 7;', '  capacity[2][5] = 2;', '  capacity[3][5] = 5;', '  capacity[4][2] = 7;', '  capacity[4][3] = 4;', '  int s = 0, t = 5;', '#include <limits.h>', '#include <string.h>', '#include <iostream>', '#include <queue>', 'using namespace std;', '#define V 6', '  bool visited[V];', '  queue<int> q;', '  q.push(s);', '  visited[s] = true;', '  parent[s] = -1;', '  while (!q.empty()) {', '    int u = q.front();', '    q.pop();', '        q.push(v);', '        parent[v] = u;', '        visited[v] = true;', '  return (visited[t] == true);', '  int u, v;', '  int rGraph[V][V];', '  for (u = 0; u < V; u++)', '    for (v = 0; v < V; v++)', '  int parent[V];', '  int max_flow = 0;', '    int path_flow = INT_MAX;', '      u = parent[v];', '      u = parent[v];', '    max_flow += path_flow;', '  return max_flow;', 'int main() {']","['# Ford-Fulkerson algorith in Python', 'from collections import defaultdict', '    # Using BFS as a searching algorithm ', '    def searching_algo_BFS(self, s, t, parent):', '        visited = [False] * (self.ROW)', '            for ind, val in enumerate(self.graph[u]):', '                if visited[ind] == False and val > 0:', '                    queue.append(ind)', '                    visited[ind] = True', '                    parent[ind] = u', '        return True if visited[t] else False', '    # Applying fordfulkerson algorithm', '    def ford_fulkerson(self, source, sink):', '        parent = [-1] * (self.ROW)', '        while self.searching_algo_BFS(source, sink, parent):', '            path_flow = float(""Inf"")', '                path_flow = min(path_flow, self.graph[parent[s]][s])', '            # Adding the path flows', '            max_flow += path_flow', '            # Updating the residual values of edges', '                self.graph[u][v] -= path_flow', '                self.graph[v][u] += path_flow', 'print(""Max Flow: %d "" % g.ford_fulkerson(source, sink))', '  boolean bfs(int Graph[][], int s, int t, int p[]) {', '    boolean visited[] = new boolean[V];', '    LinkedList<Integer> queue = new LinkedList<Integer>();', '      for (int v = 0; v < V; v++) {', '        if (visited[v] == false && Graph[u][v] > 0) {', '    return (visited[t] == true);', '  int fordFulkerson(int graph[][], int s, int t) {', '    int Graph[][] = new int[V][V];', '        Graph[u][v] = graph[u][v];', '    # Updating the residual calues of edges', '    while (bfs(Graph, s, t, p)) {', '      int path_flow = Integer.MAX_VALUE;', '      for (v = t; v != s; v = p[v]) {', '        path_flow = Math.min(path_flow, Graph[u][v]);', '      for (v = t; v != s; v = p[v]) {', '        Graph[u][v] -= path_flow;', '        Graph[v][u] += path_flow;', '  public static void main(String[] args) throws java.lang.Exception {', '    int graph[][] = new int[][] { { 0, 8, 0, 0, 3, 0 }, { 0, 0, 9, 0, 0, 0 }, { 0, 0, 0, 0, 7, 2 },', '        { 0, 0, 0, 0, 0, 5 }, { 0, 0, 7, 4, 0, 0 }, { 0, 0, 0, 0, 0, 0 } };', '    FordFulkerson m = new FordFulkerson();', '    System.out.println(""Max Flow: "" + m.fordFulkerson(graph, 0, 5));', '/ Ford - Fulkerson algorith in C', 'int capacity[MAX_NODES][MAX_NODES];', 'int bfs(int start, int target) {', '      if (color[v] == A && capacity[u][v] - flow[u][v] > 0) {', 'int fordFulkerson(int source, int sink) {', '    for (u = n - 1; pred[u] >= 0; u = pred[u]) {', '      increment = min(increment, capacity[pred[u]][u] - flow[pred[u]][u]);', '    for (u = n - 1; pred[u] >= 0; u = pred[u]) {', '      flow[pred[u]][u] += increment;', '      flow[u][pred[u]] -= increment;', '    for (int j = 0; j < n; j++) {', '  printf(""Max Flow: %d\\n"", fordFulkerson(s, t));', 'bool bfs(int rGraph[V][V], int s, int t, int parent[]) {', '  memset(visited, 0, sizeof(visited));', '    for (int v = 0; v < V; v++) {', '      if (visited[v] == false && rGraph[u][v] > 0) {', 'int fordFulkerson(int graph[V][V], int s, int t) {', '      rGraph[u][v] = graph[u][v];', '  while (bfs(rGraph, s, t, parent)) {', '    for (v = t; v != s; v = parent[v]) {', '      path_flow = min(path_flow, rGraph[u][v]);', '    for (v = t; v != s; v = parent[v]) {', '      rGraph[u][v] -= path_flow;', '      rGraph[v][u] += path_flow;', '  int graph[V][V] = {{0, 8, 0, 0, 3, 0},', '             {0, 0, 9, 0, 0, 0},', '             {0, 0, 0, 0, 7, 2},', '             {0, 0, 0, 0, 0, 5},', '             {0, 0, 7, 4, 0, 0},', '             {0, 0, 0, 0, 0, 0}};', '  cout << ""Max Flow: "" << fordFulkerson(graph, 0, 5) << endl;']",[],[],"['Water distribution pipeline|||Bipartite matching problem|||Circulation with demands|||&&&Initialize the flow in all the edges to 0.|||While there is an augmenting path between the source and the sink, add this path to the flow.|||Update the residual graph.|||Select any arbitrary path from S to T. In this step, we have selected path S-A-B-T.||||||Find a path|||The minimum capacity among the three edges is 2 (B-T). Based on this, update the flow/capacity for each path.||||||Update the capacities|||Select another path S-D-C-T. The minimum capacity among these edges is 3 (S-D).|||Find next path|||Update the capacities according to this.|||Update the capacities|||Now, let us consider the reverse-path B-D as well. Selecting path S-A-B-D-C-T. The minimum residual capacity among the edges is 1 (D-C).|||Find next path|||Updating the capacities.|||Update the capacities|||The capacity for forward and reverse paths are considered separately.|||Adding all the flows = 2 + 3 + 1 = 6, which is the maximum possible flow on the flow network.|||']"
59,"[""Dijkstra's Algorithm""]","[""Dijkstra's algorithm allows us to find the shortest path between any two vertices of a graph.""]",[],[],"[""How Dijkstra's Algorithm works"", ""Example of Dijkstra's algorithm"", ""Djikstra's algorithm pseudocode"", ""Code for Dijkstra's Algorithm"", ""Dijkstra's Algorithm Complexity"", ""Dijkstra's Algorithm Applications""]",[],"['//cdn.programiz.com/sites/tutorial2program/files/shortest-subpath.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-1.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-2.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-3.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-4.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-5.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-6.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-7.png', '//cdn.programiz.com/sites/tutorial2program/files/dj-8.png']","['Time Complexity: O(E Log V)', 'where, E is the number of edges and V is the number of vertices.', 'Space Complexity: O(V)']","['It is easier to start with an example and then think about the algorithm.', 'Once the algorithm is over, we can backtrack from the destination vertex to the source vertex to find the path.', 'A minimum priority queue can be used to efficiently receive the vertex with least path distance.']","['It differs from the minimum spanning tree because the shortest distance between two vertices might not include all the vertices of the graph.', ""Dijkstra's Algorithm works on the basis that any subpath B -> D of the shortest path A -> D between vertices A and D is also the shortest path between vertices B and D."", 'Djikstra used this property in the opposite direction i.e we overestimate the distance of each vertex from the starting vertex. Then we visit each node and its neighbors to find the shortest subpath to those neighbors.', 'The algorithm uses a greedy approach in the sense that we find the next best solution hoping that the end result is the best solution for the whole problem.', 'We need to maintain the path distance of every vertex. We can store that in an array of size v, where v is the number of vertices.', 'We also want to be able to get the shortest path, not only know the length of the shortest path. For this, we map each vertex to the vertex that last updated its path length.', ""The implementation of Dijkstra's Algorithm in C++ is given below. The complexity of the code can be improved, but the abstractions are convenient to relate the code with the algorithm.""]","['function dijkstra(G, S)', '    for each vertex V in G', '        previous[V] <- NULL', '    distance[S] <- 0', '    while Q IS NOT EMPTY', 'import sys', '# Providing the graph', 'def to_be_visited():', '    v = -10', '            v = index', '    return v', '    to_visit = to_be_visited()', '        ', '# Printing the distance', '    i = i + 1', 'public class Dijkstra {', '    int count = graph.length;', '    distance[source] = 0;', '      visitedVertex[u] = true;', '        }', '        minDistanceVertex = i;', '    return minDistanceVertex;', '    T.dijkstra(graph, 0);', '#include <stdio.h>', '#define INFINITY 9999', '#define MAX 10', '  for (i = 0; i < n; i++)', '    for (j = 0; j < n; j++)', '      if (Graph[i][j] == 0)', '        cost[i][j] = INFINITY;', '      else', '  for (i = 0; i < n; i++) {', '    pred[i] = start;', '    visited[i] = 0;', '  distance[start] = 0;', '  visited[start] = 1;', '  count = 1;', '  while (count < n - 1) {', '    mindistance = INFINITY;', '    for (i = 0; i < n; i++)', '        nextnode = i;', '    visited[nextnode] = 1;', '    for (i = 0; i < n; i++)', '      if (!visited[i])', '          pred[i] = nextnode;', '        }', '    count++;', '  for (i = 0; i < n; i++)', '    if (i != start) {', 'int main() {', '  n = 7;', '  Graph[0][0] = 0;', '  Graph[0][1] = 0;', '  Graph[0][2] = 1;', '  Graph[0][3] = 2;', '  Graph[0][4] = 0;', '  Graph[0][5] = 0;', '  Graph[0][6] = 0;', '  Graph[1][0] = 0;', '  Graph[1][1] = 0;', '  Graph[1][2] = 2;', '  Graph[1][3] = 0;', '  Graph[1][4] = 0;', '  Graph[1][5] = 3;', '  Graph[1][6] = 0;', '  Graph[2][0] = 1;', '  Graph[2][1] = 2;', '  Graph[2][2] = 0;', '  Graph[2][3] = 1;', '  Graph[2][4] = 3;', '  Graph[2][5] = 0;', '  Graph[2][6] = 0;', '  Graph[3][0] = 2;', '  Graph[3][1] = 0;', '  Graph[3][2] = 1;', '  Graph[3][3] = 0;', '  Graph[3][4] = 0;', '  Graph[3][5] = 0;', '  Graph[3][6] = 1;', '  Graph[4][0] = 0;', '  Graph[4][1] = 0;', '  Graph[4][2] = 3;', '  Graph[4][3] = 0;', '  Graph[4][4] = 0;', '  Graph[4][5] = 2;', '  Graph[4][6] = 0;', '  Graph[5][0] = 0;', '  Graph[5][1] = 3;', '  Graph[5][2] = 0;', '  Graph[5][3] = 0;', '  Graph[5][4] = 2;', '  Graph[5][5] = 0;', '  Graph[5][6] = 1;', '  Graph[6][0] = 0;', '  Graph[6][1] = 0;', '  Graph[6][2] = 0;', '  Graph[6][3] = 1;', '  Graph[6][4] = 0;', '  Graph[6][5] = 1;', '  Graph[6][6] = 0;', '  u = 0;', '  Dijkstra(Graph, n, u);', '  return 0;', '#include <iostream>', '#include <vector>', '#define INT_MAX 10000000', 'using namespace std;', 'void DijkstrasTest();', 'int main() {', '  DijkstrasTest();', '  return 0;', 'class Node;', 'class Edge;', 'void Dijkstras();', 'vector<Node*> nodes;', 'vector<Edge*> edges;', 'class Node {', '   public:', '  Node(char id)', '    nodes.push_back(this);', '   public:', '  char id;', '  Node* previous;', '  int distanceFromStart;', 'class Edge {', '   public:', '    edges.push_back(this);', '    return (', '      (node1 == this->node1 &&', '      (node1 == this->node2 &&', '       node2 == this->node1));', '   public:', '  Node* node1;', '  Node* node2;', '  int distance;', 'void DijkstrasTest() {', ""  Node* a = new Node('a');"", ""  Node* b = new Node('b');"", ""  Node* c = new Node('c');"", ""  Node* d = new Node('d');"", ""  Node* e = new Node('e');"", ""  Node* f = new Node('f');"", ""  Node* g = new Node('g');"", '  Dijkstras();', '  PrintShortestRouteTo(f);', 'void Dijkstras() {', '  while (nodes.size() > 0) {', '    delete adjacentNodes;', '  int size = nodes.size();', '  if (size == 0) return NULL;', '  int smallestPosition = 0;', '      smallest = current;', '      smallestPosition = i;', '  return smallest;', '    Edge* edge = edges.at(i);', '    Node* adjacent = NULL;', '    if (edge->node1 == node) {', '      adjacent = edge->node2;', '      adjacent = edge->node1;', '  return adjacentNodes;', '    Edge* edge = edges.at(i);', '      return edge->distance;', '    if (node == nodes.at(i)) {', '      return true;', '  return false;', '  while (previous) {', '  cout << endl;', '    Edge* edge = edges.at(i);', '    if (edge->node1 == node) {', '  return adjacentEdges;', '  vector<Edge*>::iterator it;', '    if (*it == edge) {', '      edges.erase(it);', '      return;']","['        If V != S, add V to Priority Queue Q', '        for each unvisited neighbour V of U', '            tempDistance <- distance[U] + edge_weight(U, V)', '            if tempDistance < distance[V]', '                distance[V] <- tempDistance', '                previous[V] <- U', '    return distance[], previous[]', ""# Dijkstra's Algorithm in Python"", 'vertices = [[0, 0, 1, 1, 0, 0, 0],', '            [0, 0, 1, 0, 0, 1, 0],', '            [1, 1, 0, 1, 1, 0, 0],', '            [1, 0, 1, 0, 0, 0, 1],', '            [0, 0, 1, 0, 0, 1, 0],', '            [0, 1, 0, 0, 1, 0, 1],', '            [0, 0, 0, 1, 0, 1, 0]]', '# Find which vertex is to be visited next', '    for index in range(num_of_vertices):', '        if visited_and_distance[index][0] == 0 \\', '            and (v < 0 or visited_and_distance[index][1] <=', '                 visited_and_distance[v][1]):', 'num_of_vertices = len(vertices[0])', 'for i in range(num_of_vertices-1):', '    visited_and_distance.append([0, sys.maxsize])', 'for vertex in range(num_of_vertices):', '    # Find next vertex to be visited', '    for neighbor_index in range(num_of_vertices):', '        # Updating new distances', '        if vertices[to_visit][neighbor_index] == 1 and \\', '                visited_and_distance[neighbor_index][0] == 0:', '            new_distance = visited_and_distance[to_visit][1] \\', '                + edges[to_visit][neighbor_index]', '            if visited_and_distance[neighbor_index][1] > new_distance:', '                visited_and_distance[neighbor_index][1] = new_distance', '        visited_and_distance[to_visit][0] = 1', 'for distance in visited_and_distance:', '    print(""Distance of "", chr(ord(\'a\') + i),', '          "" from source vertex: "", distance[1])', '  public static void dijkstra(int[][] graph, int source) {', '    boolean[] visitedVertex = new boolean[count];', '    int[] distance = new int[count];', '    for (int i = 0; i < count; i++) {', '      distance[i] = Integer.MAX_VALUE;', '    for (int i = 0; i < count; i++) {', '      int u = findMinDistance(distance, visitedVertex);', '      for (int v = 0; v < count; v++) {', '        if (!visitedVertex[v] && graph[u][v] != 0 && (distance[u] + graph[u][v] < distance[v])) {', '          distance[v] = distance[u] + graph[u][v];', '    for (int i = 0; i < distance.length; i++) {', '      System.out.println(String.format(""Distance from %s to %s is %s"", source, i, distance[i]));', '  private static int findMinDistance(int[] distance, boolean[] visitedVertex) {', '    int minDistance = Integer.MAX_VALUE;', '    for (int i = 0; i < distance.length; i++) {', '      if (!visitedVertex[i] && distance[i] < minDistance) {', '        minDistance = distance[i];', '  public static void main(String[] args) {', '    int graph[][] = new int[][] { { 0, 0, 1, 2, 0, 0, 0 }, { 0, 0, 2, 0, 0, 3, 0 }, { 1, 2, 0, 1, 3, 0, 0 },', '        { 2, 0, 1, 0, 0, 0, 1 }, { 0, 0, 3, 0, 0, 2, 0 }, { 0, 3, 0, 0, 2, 0, 1 }, { 0, 0, 0, 1, 0, 1, 0 } };', '    Dijkstra T = new Dijkstra();', 'void Dijkstra(int Graph[MAX][MAX], int n, int start);', 'void Dijkstra(int Graph[MAX][MAX], int n, int start) {', '  int cost[MAX][MAX], distance[MAX], pred[MAX];', '  int visited[MAX], count, mindistance, nextnode, i, j;', '        cost[i][j] = Graph[i][j];', '    distance[i] = cost[start][i];', '      if (distance[i] < mindistance && !visited[i]) {', '        mindistance = distance[i];', '        if (mindistance + cost[nextnode][i] < distance[i]) {', '          distance[i] = mindistance + cost[nextnode][i];', '      printf(""\\nDistance from source to %d: %d"", i, distance[i]);', '  int Graph[MAX][MAX], i, j, n, u;', 'vector<Node*>* AdjacentRemainingNodes(Node* node);', 'Node* ExtractSmallest(vector<Node*>& nodes);', 'int Distance(Node* node1, Node* node2);', 'bool Contains(vector<Node*>& nodes, Node* node);', 'void PrintShortestRouteTo(Node* destination);', '    : id(id), previous(NULL), distanceFromStart(INT_MAX) {', '  Edge(Node* node1, Node* node2, int distance)', '    : node1(node1), node2(node2), distance(distance) {', '  bool Connects(Node* node1, Node* node2) {', '  a->distanceFromStart = 0;  // set start node', '    Node* smallest = ExtractSmallest(nodes);', '    vector<Node*>* adjacentNodes =', '      AdjacentRemainingNodes(smallest);', '    const int size = adjacentNodes->size();', '    for (int i = 0; i < size; ++i) {', '      Node* adjacent = adjacentNodes->at(i);', '      int distance = Distance(smallest, adjacent) +', '               smallest->distanceFromStart;', '      if (distance < adjacent->distanceFromStart) {', '        adjacent->distanceFromStart = distance;', '        adjacent->previous = smallest;', 'Node* ExtractSmallest(vector<Node*>& nodes) {', '  for (int i = 1; i < size; ++i) {', '    Node* current = nodes.at(i);', '    if (current->distanceFromStart <', '      smallest->distanceFromStart) {', '  nodes.erase(nodes.begin() + smallestPosition);', 'vector<Node*>* AdjacentRemainingNodes(Node* node) {', '  vector<Node*>* adjacentNodes = new vector<Node*>();', '  const int size = edges.size();', '  for (int i = 0; i < size; ++i) {', '    } else if (edge->node2 == node) {', '    if (adjacent && Contains(nodes, adjacent)) {', '      adjacentNodes->push_back(adjacent);', 'int Distance(Node* node1, Node* node2) {', '  const int size = edges.size();', '  for (int i = 0; i < size; ++i) {', '    if (edge->Connects(node1, node2)) {', '  return -1;  // should never happen', 'bool Contains(vector<Node*>& nodes, Node* node) {', '  const int size = nodes.size();', '  for (int i = 0; i < size; ++i) {', 'void PrintShortestRouteTo(Node* destination) {', '  cout << ""Distance from start: ""', '     << destination->distanceFromStart << endl;', '    cout << previous->id << "" "";', '    previous = previous->previous;', 'vector<Edge*>* AdjacentEdges(vector<Edge*>& Edges, Node* node);', 'void RemoveEdge(vector<Edge*>& Edges, Edge* edge);', 'vector<Edge*>* AdjacentEdges(vector<Edge*>& edges, Node* node) {', '  vector<Edge*>* adjacentEdges = new vector<Edge*>();', '  const int size = edges.size();', '  for (int i = 0; i < size; ++i) {', '      cout << ""adjacent: "" << edge->node2->id << endl;', '      adjacentEdges->push_back(edge);', '    } else if (edge->node2 == node) {', '      cout << ""adjacent: "" << edge->node1->id << endl;', '      adjacentEdges->push_back(edge);', 'void RemoveEdge(vector<Edge*>& edges, Edge* edge) {', '  for (it = edges.begin(); it < edges.end(); ++it) {']",[],[],['To find the shortest path|||In social networking applications|||In a telephone network|||To find the locations in the map|||']
60,"[""Kruskal's Algorithm""]","[""In this tutorial, you will learn how Kruskal's Algorithmworks. Also, you will find working examples of Kruskal's Algorithm in C, C++, Java and Python.""]",[],[],"[""How Kruskal's algorithm works"", ""Example of Kruskal's algorithm"", 'Kruskal Algorithm Pseudocode', 'Python, Java and C/C++ Examples', ""Kruskal's vs Prim's Algorithm"", ""Kruskal's Algorithm Complexity"", ""Kruskal's Algorithm Applications""]",[],"['//cdn.programiz.com/sites/tutorial2program/files/ka-1.png', '//cdn.programiz.com/sites/tutorial2program/files/ka-2.png', '//cdn.programiz.com/sites/tutorial2program/files/ka-3.png', '//cdn.programiz.com/sites/tutorial2program/files/ka-4.png', '//cdn.programiz.com/sites/tutorial2program/files/ka-5.png', '//cdn.programiz.com/sites/tutorial2program/files/ka-6.png']","[""The steps for implementing Kruskal's algorithm are as follows:"", ""The time complexity Of Kruskal's Algorithm is: O(E log E).""]","['We start from the edges with the lowest weight and keep adding edges until we reach our goal.', 'Any minimum spanning tree algorithm revolves around checking if adding an edge creates a loop or not.']","[""Kruskal's algorithm is a minimum spanning tree algorithm that takes a graph as input and finds the subset of the edges of that graph which"", 'It falls under a class of algorithms called greedy algorithms that find the local optimum in the hopes of finding a global optimum.', 'The most common way to find this out is an algorithm called Union FInd. The Union-Find algorithm divides the vertices into clusters and allows us to check if two vertices belong to the same cluster or not and hence decide whether adding an edge creates a cycle.', ""Prim's algorithm is another popular minimum spanning tree algorithm that uses a different logic to find the MST of a graph. Instead of starting from an edge, Prim's algorithm starts from a vertex and keeps adding lowest-weight edges which aren't in the tree, until all vertices have been covered.""]","['KRUSKAL(G):', 'For each vertex v ∈ G.V:', '    MAKE-SET(v)', '    A = A ∪ {(u, v)}', '    UNION(u, v)', 'return A', 'class Graph:', '        self.V = vertices', '        self.graph = []', '    # Search function', '    def find(self, parent, i):', '        if parent[i] == i:', '            return i', '        else:', '            rank[xroot] += 1', '    def kruskal_algo(self):', '        result = []', '        i, e = 0, 0', '        parent = []', '        rank = []', '            rank.append(0)', '        while e < self.V - 1:', '            i = i + 1', '            if x != y:', '                e = e + 1', 'g = Graph(6)', 'g.add_edge(0, 1, 4)', 'g.add_edge(0, 2, 4)', 'g.add_edge(1, 2, 2)', 'g.add_edge(1, 0, 4)', 'g.add_edge(2, 0, 4)', 'g.add_edge(2, 1, 2)', 'g.add_edge(2, 3, 3)', 'g.add_edge(2, 5, 2)', 'g.add_edge(2, 4, 4)', 'g.add_edge(3, 2, 3)', 'g.add_edge(3, 4, 3)', 'g.add_edge(4, 2, 4)', 'g.add_edge(4, 3, 3)', 'g.add_edge(5, 2, 2)', 'g.add_edge(5, 4, 3)', 'g.kruskal_algo()', 'import java.util.*;', 'class Graph {', '    int src, dest, weight;', '  class subset {', '    int parent, rank;', '  int vertices, edges;', '  Edge edge[];', '  Graph(int v, int e) {', '    vertices = v;', '    edges = e;', '    edge = new Edge[edges];', '      edge[i] = new Edge();', '    return subsets[i].parent;', '    else {', '      subsets[xroot].rank++;', '  void KruskalAlgo() {', '    int e = 0;', '    int i = 0;', '      result[i] = new Edge();', '    Arrays.sort(edge);', '      subsets[v].parent = v;', '      subsets[v].rank = 0;', '    i = 0;', '    while (e < vertices - 1) {', '      next_edge = edge[i++];', '      if (x != y) {', '        Union(subsets, x, y);', '    for (i = 0; i < e; ++i)', '    G.edge[0].src = 0;', '    G.edge[0].dest = 1;', '    G.edge[0].weight = 4;', '    G.edge[1].src = 0;', '    G.edge[1].dest = 2;', '    G.edge[1].weight = 4;', '    G.edge[2].src = 1;', '    G.edge[2].dest = 2;', '    G.edge[2].weight = 2;', '    G.edge[3].src = 2;', '    G.edge[3].dest = 3;', '    G.edge[3].weight = 3;', '    G.edge[4].src = 2;', '    G.edge[4].dest = 5;', '    G.edge[4].weight = 2;', '    G.edge[5].src = 2;', '    G.edge[5].dest = 4;', '    G.edge[5].weight = 4;', '    G.edge[6].src = 3;', '    G.edge[6].dest = 4;', '    G.edge[6].weight = 3;', '    G.edge[7].src = 5;', '    G.edge[7].dest = 4;', '    G.edge[7].weight = 3;', '    G.KruskalAlgo();', '#include <stdio.h>', '#define MAX 30', 'typedef struct edge {', '  int u, v, w;', 'typedef struct edge_list {', '  edge data[MAX];', '  int n;', '} edge_list;', 'edge_list elist;', 'int Graph[MAX][MAX], n;', 'edge_list spanlist;', 'void kruskalAlgo();', 'void sort();', 'void print();', 'void kruskalAlgo() {', '  elist.n = 0;', '  for (i = 1; i < n; i++)', '    for (j = 0; j < i; j++) {', '      if (Graph[i][j] != 0) {', '        elist.n++;', '  sort();', '  for (i = 0; i < n; i++)', '    belongs[i] = i;', '  spanlist.n = 0;', '    if (cno1 != cno2) {', '  return (belongs[vertexno]);', '  int i;', '  for (i = 0; i < n; i++)', '    if (belongs[i] == c2)', '      belongs[i] = c1;', 'void sort() {', '  int i, j;', '  edge temp;', '        temp = elist.data[j];', 'void print() {', '  int i, cost = 0;', 'int main() {', '  int i, j, total_cost;', '  n = 6;', '  Graph[0][0] = 0;', '  Graph[0][1] = 4;', '  Graph[0][2] = 4;', '  Graph[0][3] = 0;', '  Graph[0][4] = 0;', '  Graph[0][5] = 0;', '  Graph[0][6] = 0;', '  Graph[1][0] = 4;', '  Graph[1][1] = 0;', '  Graph[1][2] = 2;', '  Graph[1][3] = 0;', '  Graph[1][4] = 0;', '  Graph[1][5] = 0;', '  Graph[1][6] = 0;', '  Graph[2][0] = 4;', '  Graph[2][1] = 2;', '  Graph[2][2] = 0;', '  Graph[2][3] = 3;', '  Graph[2][4] = 4;', '  Graph[2][5] = 0;', '  Graph[2][6] = 0;', '  Graph[3][0] = 0;', '  Graph[3][1] = 0;', '  Graph[3][2] = 3;', '  Graph[3][3] = 0;', '  Graph[3][4] = 3;', '  Graph[3][5] = 0;', '  Graph[3][6] = 0;', '  Graph[4][0] = 0;', '  Graph[4][1] = 0;', '  Graph[4][2] = 4;', '  Graph[4][3] = 3;', '  Graph[4][4] = 0;', '  Graph[4][5] = 0;', '  Graph[4][6] = 0;', '  Graph[5][0] = 0;', '  Graph[5][1] = 0;', '  Graph[5][2] = 2;', '  Graph[5][3] = 0;', '  Graph[5][4] = 3;', '  Graph[5][5] = 0;', '  Graph[5][6] = 0;', '  kruskalAlgo();', '  print();', '#include <algorithm>', '#include <iostream>', '#include <vector>', 'using namespace std;', '#define edge pair<int, int>', 'class Graph {', '   private:', '  int *parent;', '   public:', '  Graph(int V);', '  int find_set(int i);', '  void kruskal();', '  void print();', 'Graph::Graph(int V) {', '  parent = new int[V];', '  for (int i = 0; i < V; i++)', '    parent[i] = i;', '  G.clear();', '  T.clear();', 'int Graph::find_set(int i) {', '  if (i == parent[i])', '    return i;', '  parent[u] = parent[v];', 'void Graph::kruskal() {', '  int i, uRep, vRep;', '    if (uRep != vRep) {', '      union_set(uRep, vRep);', 'void Graph::print() {', '  cout << ""Edge :""', '     << "" Weight"" << endl;', '       << T[i].first;', '    cout << endl;', 'int main() {', '  Graph g(6);', '  g.AddWeightedEdge(0, 1, 4);', '  g.AddWeightedEdge(0, 2, 4);', '  g.AddWeightedEdge(1, 2, 2);', '  g.AddWeightedEdge(1, 0, 4);', '  g.AddWeightedEdge(2, 0, 4);', '  g.AddWeightedEdge(2, 1, 2);', '  g.AddWeightedEdge(2, 3, 3);', '  g.AddWeightedEdge(2, 5, 2);', '  g.AddWeightedEdge(2, 4, 4);', '  g.AddWeightedEdge(3, 2, 3);', '  g.AddWeightedEdge(3, 4, 3);', '  g.AddWeightedEdge(4, 2, 4);', '  g.AddWeightedEdge(4, 3, 3);', '  g.AddWeightedEdge(5, 2, 2);', '  g.AddWeightedEdge(5, 4, 3);', '  g.kruskal();', '  g.print();', '  return 0;']","['For each edge (u, v) ∈ G.E ordered by increasing order by weight(u, v):', '    if FIND-SET(u) ≠ FIND-SET(v):       ', '    def __init__(self, vertices):', '    def add_edge(self, u, v, w):', '        self.graph.append([u, v, w])', '        return self.find(parent, parent[i])', '    def apply_union(self, parent, rank, x, y):', '        xroot = self.find(parent, x)', '        yroot = self.find(parent, y)', '        if rank[xroot] < rank[yroot]:', '            parent[xroot] = yroot', '        elif rank[xroot] > rank[yroot]:', '            parent[yroot] = xroot', '            parent[yroot] = xroot', '    #  Applying Kruskal algorithm', '        self.graph = sorted(self.graph, key=lambda item: item[2])', '        for node in range(self.V):', '            u, v, w = self.graph[i]', '            x = self.find(parent, u)', '            y = self.find(parent, v)', '                result.append([u, v, w])', '                self.apply_union(parent, rank, x, y)', '        for u, v, weight in result:', '            print(""%d - %d: %d"" % (u, v, weight))', '  class Edge implements Comparable<Edge> {', '    public int compareTo(Edge compareEdge) {', '      return this.weight - compareEdge.weight;', '  int find(subset subsets[], int i) {', '      subsets[i].parent = find(subsets, subsets[i].parent);', '  void Union(subset subsets[], int x, int y) {', '    int xroot = find(subsets, x);', '    int yroot = find(subsets, y);', '    if (subsets[xroot].rank < subsets[yroot].rank)', '      subsets[xroot].parent = yroot;', '    else if (subsets[xroot].rank > subsets[yroot].rank)', '      subsets[yroot].parent = xroot;', '      subsets[yroot].parent = xroot;', '    Edge result[] = new Edge[vertices];', '    for (i = 0; i < vertices; ++i)', '    subset subsets[] = new subset[vertices];', '    for (i = 0; i < vertices; ++i)', '      subsets[i] = new subset();', '    for (int v = 0; v < vertices; ++v) {', '      Edge next_edge = new Edge();', '      int x = find(subsets, next_edge.src);', '      int y = find(subsets, next_edge.dest);', '        result[e++] = next_edge;', '      System.out.println(result[i].src + "" - "" + result[i].dest + "": "" + result[i].weight);', '  public static void main(String[] args) {', '    int vertices = 6; // Number of vertices', '    int edges = 8; // Number of edges', '    Graph G = new Graph(vertices, edges);', 'int find(int belongs[], int vertexno);', 'void applyUnion(int belongs[], int c1, int c2);', '  int belongs[MAX], i, j, cno1, cno2;', '        elist.data[elist.n].u = i;', '        elist.data[elist.n].v = j;', '        elist.data[elist.n].w = Graph[i][j];', '  for (i = 0; i < elist.n; i++) {', '    cno1 = find(belongs, elist.data[i].u);', '    cno2 = find(belongs, elist.data[i].v);', '      spanlist.data[spanlist.n] = elist.data[i];', '      spanlist.n = spanlist.n + 1;', '      applyUnion(belongs, cno1, cno2);', 'int find(int belongs[], int vertexno) {', 'void applyUnion(int belongs[], int c1, int c2) {', '    for (j = 0; j < elist.n - 1; j++)', '      if (elist.data[j].w > elist.data[j + 1].w) {', '        elist.data[j] = elist.data[j + 1];', '        elist.data[j + 1] = temp;', '  for (i = 0; i < spanlist.n; i++) {', '    printf(""\\n%d - %d : %d"", spanlist.data[i].u, spanlist.data[i].v, spanlist.data[i].w);', '    cost = cost + spanlist.data[i].w;', '  printf(""\\nSpanning tree cost: %d"", cost);', '  vector<pair<int, edge> > G;  // graph', '  vector<pair<int, edge> > T;  // mst', '  int V;  // number of vertices/nodes in graph', '  void AddWeightedEdge(int u, int v, int w);', 'void Graph::AddWeightedEdge(int u, int v, int w) {', '  G.push_back(make_pair(w, edge(u, v)));', 'void Graph::union_set(int u, int v) {', '  sort(G.begin(), G.end());  // increasing weight', '  for (i = 0; i < G.size(); i++) {', '    uRep = find_set(G[i].second.first);', '    vRep = find_set(G[i].second.second);', '      T.push_back(G[i]);  // add to tree', '  for (int i = 0; i < T.size(); i++) {', '    cout << T[i].second.first << "" - "" << T[i].second.second << "" : ""']",[],[],"['form a tree that includes every vertex|||has the minimum sum of weights among all the trees that can be formed from the graph|||In order to layout electrical wiring|||In computer network (LAN connection)|||&&&Sort all the edges from low weight to high|||Take the edge with the lowest weight and add it to the spanning tree. If adding the edge created a cycle, then reject this edge.|||Keep adding edges until we reach all vertices.|||']"
61,"[""Prim's Algorithm""]","[""In this tutorial, you will learn how  Prim's Algorithm works. Also, you will find working examples of Prim's Algorithm in C, C++, Java and Python.""]",[],[],"[""How Prim's algorithm works"", ""Example of Prim's algorithm"", ""Prim's Algorithm pseudocode"", 'Python, Java and C/C++ Examples', ""Prim's vs Kruskal's Algorithm"", ""Prim's Algorithm Complexity"", ""Prim's Algorithm Application""]",[],"['//cdn.programiz.com/sites/tutorial2program/files/pa_1.png', '//cdn.programiz.com/sites/tutorial2program/files/pa_2.png', '//cdn.programiz.com/sites/tutorial2program/files/pa_3.png', '//cdn.programiz.com/sites/tutorial2program/files/pa_4.png', '//cdn.programiz.com/sites/tutorial2program/files/pa_5.png', '//cdn.programiz.com/sites/tutorial2program/files/pa_6.png']","[""The steps for implementing Prim's algorithm are as follows:"", ""The time complexity of Prim's algorithm is O(E log V).""]",['We start from one vertex and keep adding edges with the lowest weight until we reach our goal.'],"[""Prim's algorithm is a minimum spanning tree algorithm that takes a graph as input and finds the subset of the edges of that graph which"", 'It falls under a class of algorithms called greedy algorithms that find the local optimum in the hopes of finding a global optimum.', ""The pseudocode for prim's algorithm shows how we create two sets of vertices U and V-U. U contains the list of vertices that have been visited and V-U the list of vertices that haven't. One by one, we move vertices from set V-U to set U by connecting the least weight edge."", 'Although adjacency matrix representation of graphs is used, this algorithm can also be implemented using Adjacency List to improve its efficiency.', ""Kruskal's algorithm is another popular minimum spanning tree algorithm that uses a different logic to find the MST of a graph. Instead of starting from a vertex, Kruskal's algorithm sorts all the edges from low weight to high and keeps adding the lowest edges, ignoring those edges that create a cycle.""]","['U = { 1 };', 'while (U ≠ V)', '    T = T ∪ {(u, v)}', '    U = U ∪ {v}', ""# Prim's Algorithm in Python"", 'INF = 9999999', '# number of vertices in graph', 'G = [[0, 9, 75, 0, 0],', '     [9, 0, 95, 19, 42],', '     [75, 95, 0, 51, 66],', '     [0, 19, 51, 0, 31],', '     [0, 42, 66, 31, 0]]', 'selected = [0, 0, 0, 0, 0]', '# set number of edge to 0', 'no_edge = 0', 'selected[0] = True', '# print for edge and weight', 'print(""Edge : Weight\\n"")', 'while (no_edge < V - 1):', '    minimum = INF', '    x = 0', '    y = 0', '    for i in range(V):', '        if selected[i]:', '            for j in range(V):', '                        x = i', '                        y = j', '    selected[y] = True', '    no_edge += 1', 'import java.util.Arrays;', 'class PGraph {', '    int INF = 9999999;', '    no_edge = 0;', '    selected[0] = true;', '    while (no_edge < V - 1) {', '      int min = INF;', '      int x = 0; // row number', '      int y = 0; // col number', '                min = G[i][j];', '                x = i;', '                y = j;', '              }', '            }', '          }', '        }', '      selected[y] = true;', '      no_edge++;', '    PGraph g = new PGraph();', '    int V = 5;', '    g.Prim(G, V);', '#include<stdio.h>', '#include<stdbool.h> ', '#define INF 9999999', '#define V 5', 'int G[V][V] = {', '  {0, 9, 75, 0, 0},', '  {9, 0, 95, 19, 42},', '  {75, 95, 0, 51, 66},', '  {0, 19, 51, 0, 31},', '  {0, 42, 66, 31, 0}};', 'int main() {', '  int selected[V];', '  no_edge = 0;', '  selected[0] = true;', '  int x;  //  row number', '  int y;  //  col number', '  printf(""Edge : Weight\\n"");', '  while (no_edge < V - 1) {', '    int min = INF;', '    x = 0;', '    y = 0;', '      if (selected[i]) {', '              min = G[i][j];', '              x = i;', '              y = j;', '            }', '          }', '        }', '    selected[y] = true;', '    no_edge++;', '  return 0;', '#include <cstring>', '#include <iostream>', 'using namespace std;', '#define INF 9999999', '#define V 5', 'int G[V][V] = {', '  {0, 9, 75, 0, 0},', '  {9, 0, 95, 19, 42},', '  {75, 95, 0, 51, 66},', '  {0, 19, 51, 0, 31},', '  {0, 42, 66, 31, 0}};', 'int main() {', '  int selected[V];', '  no_edge = 0;', '  selected[0] = true;', '  int x;  //  row number', '  int y;  //  col number', '  cout << ""Edge""', '     << "" : ""', '     << ""Weight"";', '  cout << endl;', '  while (no_edge < V - 1) {', '    int min = INF;', '    x = 0;', '    y = 0;', '      if (selected[i]) {', '              min = G[i][j];', '              x = i;', '              y = j;', '            }', '          }', '        }', '    cout << endl;', '    selected[y] = true;', '    no_edge++;', '  return 0;']","['    let (u, v) be the lowest cost edge such that u ∈ U and v ∈ V - U;', '# for adjacency matrix to represent graph', '# create a array to track selected vertex', '# selected will become true otherwise false', '# the number of egde in minimum spanning tree will be', '# always less than(V - 1), where V is number of vertices in', '# choose 0th vertex and make it true', '    # For every vertex in the set S, find the all adjacent vertices', '    #, calculate the distance from the vertex selected at step 1.', '    # if the vertex is already in the set S, discard it otherwise', '    # choose another vertex nearest to selected vertex  at step 1.', '                if ((not selected[j]) and G[i][j]):  ', '                    # not in selected and there is an edge', '                    if minimum > G[i][j]:', '                        minimum = G[i][j]', '    print(str(x) + ""-"" + str(y) + "":"" + str(G[x][y]))', '  public void Prim(int G[][], int V) {', '    int no_edge; // number of edge', '    boolean[] selected = new boolean[V];', '    Arrays.fill(selected, false);', '    System.out.println(""Edge : Weight"");', '      for (int i = 0; i < V; i++) {', '        if (selected[i] == true) {', '          for (int j = 0; j < V; j++) {', '            if (!selected[j] && G[i][j] != 0) {', '              if (min > G[i][j]) {', '      System.out.println(x + "" - "" + y + "" :  "" + G[x][y]);', '  public static void main(String[] args) {', '    int[][] G = { { 0, 9, 75, 0, 0 }, { 9, 0, 95, 19, 42 }, { 75, 95, 0, 51, 66 }, { 0, 19, 51, 0, 31 },', '  int no_edge;  // number of edge', '  memset(selected, false, sizeof(selected));', '    for (int i = 0; i < V; i++) {', '        for (int j = 0; j < V; j++) {', '          if (!selected[j] && G[i][j]) {  // not in selected and there is an edge', '            if (min > G[i][j]) {', '    printf(""%d - %d : %d\\n"", x, y, G[x][y]);', '  int no_edge;  // number of edge', '  memset(selected, false, sizeof(selected));', '    for (int i = 0; i < V; i++) {', '        for (int j = 0; j < V; j++) {', '          if (!selected[j] && G[i][j]) {  // not in selected and there is an edge', '            if (min > G[i][j]) {', '    cout << x << "" - "" << y << "" :  "" << G[x][y];']",[],[],"['form a tree that includes every vertex|||has the minimum sum of weights among all the trees that can be formed from the graph|||Laying cables of electrical wiring|||In network designed|||To make protocols in network cycles|||&&&Initialize the minimum spanning tree with a vertex chosen at random.|||Find all the edges that connect the tree to new vertices, find the minimum and add it to the tree|||Keep repeating step 2 until we get a minimum spanning tree|||']"
