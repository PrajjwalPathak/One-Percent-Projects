,main_headings,sub_headings_h2,sub_headings_h3,image_urls,video_urls,links,facts,definitions,explanations,codes,outputs,table_data,list_items
0,['Introduction to C++ Programming Language'],[],[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190430122723/cpp-program-compilation3-1024x375.png'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/interesting-facts-about-c/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Some of the features & key-points to note about the programming language are as follows:', 'Applications of C++:\xa0C++ finds varied usage in applications such as:', 'Some interesting facts about C++:\xa0Here are some awesome facts about C++ that may interest you:', 'https://youtu.be/wmje4']","['C++ is a general-purpose programming language that was developed as an enhancement of the C language to include object-oriented paradigm. It is an imperative and a compiled language.\xa0\xa0', 'C++ is a middle-level language rendering it the advantage of programming low-level (drivers, kernels) and even higher-level applications (games, GUI, desktop apps etc.). The basic syntax and code structure of both C and C++ are the same.\xa0']",[],[],[],[],"['Simple: It is a simple language in the sense that programs can be broken down into logical units and parts, has a rich library support and a variety of data-types.|||Machine Independent but Platform Dependent: A C++ executable is not platform-independent (compiled programs on Linux won’t run on Windows), however they are machine independent.|||Mid-level language: It is a mid-level language as we can do both systems-programming (drivers, kernels, networking etc.) and build large-scale user applications (Media Players, Photoshop, Game Engines etc.)|||Rich library support: Has a rich library support (Both standard ~ built-in data structures, algorithms etc.) as well 3rd party libraries (e.g. Boost libraries) for fast and rapid development.|||Speed of execution: C++ programs excel in execution speed. Since, it is a compiled language, and also hugely procedural. Newer languages have extra in-built default features such as garbage-collection, dynamic typing etc. which slow the execution of the program overall. Since there is no additional processing overhead like this in C++, it is blazing fast.|||Pointer and direct Memory-Access: C++ provides pointer support which aids users to directly manipulate storage address. This helps in doing low-level programming (where one might need to have explicit control on the storage of variables).|||Object-Oriented: One of the strongest points of the language which sets it apart from C. Object-Oriented support helps C++ to make maintainable and extensible programs. i.e. Large-scale applications can be built. Procedural code becomes difficult to maintain as code-size grows.|||Compiled Language: C++ is a compiled language, contributing to its speed.&&&Operating Systems & Systems Programming. e.g. Linux-based OS (Ubuntu etc.)|||Browsers (Chrome & Firefox)|||Graphics & Game engines (Photoshop, Blender, Unreal-Engine)|||Database Engines (MySQL, MongoDB, Redis etc.)|||Cloud/Distributed Systems&&&&&&The name of C++ signifies the evolutionary nature of the changes from C. “++” is the C increment operator.|||C++ is one of the predominant languages for the development of all kind of technical and commercial software.|||C++ introduces Object-Oriented Programming, not present in C. Like other things, C++ supports the four primary features of OOP: encapsulation, polymorphism, abstraction, and inheritance.|||C++ got the OOP features from Simula67 Programming language.|||A function is a minimum requirement for a C++ program to run.(at least main() function)&&&']"
1,['Setting up C++ Development Environment'],['CPP'],[],[],['https://www.youtube.com/embed/dsbj7XpHOcE?list=PLqM7alHXFySGg6GSRmE2INI4k8fPH5qVB'],"['https://www.geeksforgeeks.org/basic/', 'https://ide.geeksforgeeks.org/', 'http://www.codeblocks.org/downloads/26', 'https://www.geeksforgeeks.org/developer.apple.com/technologies/tools/', 'http://www.contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['Setting up local environment'],['For setting up your own personal development environment on your local machine you need to install two important softwares:\xa0'],"['C++ is a general-purpose programming language and widely used nowadays for competitive programming. It has imperative, object-oriented and generic programming features.\xa0C++ runs on lots of platform like Windows, Linux, Unix, Mac, etc. Before we start programming with C++. We will need an environment to be set-up on our local computer to compile and run our C++ programs successfully. If you do not want to set up a local environment you can also use online IDEs for compiling your program.Using online IDE: IDE stands for integrated development environment. IDE is a software application that provides facilities to a computer programmer for developing software. There are many online IDEs available which you can use to compile and run your programs easily without setting up a local development environment.ide.geeksforgeeks.org is one such IDE provided by GeeksforGeeks.\xa0You can click on the Run on IDE button to run the program.', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['#include<iostream>using namespace std;main(){    cout << ""Learning C++ at GeekforGeeks"";}']","['sudo apt-get update\nsudo apt-get install gcc\nsudo apt-get install g++', 'sudo apt-get install build-essential', 'g++ --version', 'g++ filename.cpp -o any-name', 'g++ helloworld.cpp -o hello', './hello']",[],"['Linux Installation: We will install the GNU GCC compiler on Linux. To install and work with the GCC compiler on your Linux machine, proceed according to below steps:You have to first run the below two commands from your Linux terminal window:|||You have to first run the below two commands from your Linux terminal window:&&&You have to first run the below two commands from your Linux terminal window:&&&This command will install the GCC compiler on your system. You may also run the below command:&&&This command will install all the libraries which are required to compile and run a C++ program.|||After completing the above step, you should check whether the GCC compiler is installed in your system correctly or not. To do this you have to run the below-given command from Linux terminal:&&&If you have completed the above two steps without any errors, then your Linux environment is set up and ready to be used to compile C++ programs. In further steps, we will learn how to compile and run a C++ program on Linux using GCC compiler.|||Write your program in a text file and save it with any file name and.CPP extension. We have written a program to display “Hello World” and saved it in a file with the filename “helloworld.cpp” on desktop.|||Now you have to open the Linux terminal and move to the directory where you have saved your file. Then you have to run the below command to compile your file:&&&filename.cpp is the name of your source code file. In our case, the name is “helloworld.cpp” and any-name can be any name of your choice. This name will be assigned to the executable file which is created by the compiler after compilation. In our case, we choose any-name to be “hello”.We will run the above command as:&&&After executing the above command, you will see a new file is created automatically in the same directory where you have saved the source file and the name of this file is the name you chose as any-name.Now to run your program you have to run the below command:&&&This command will run your program in the terminal window.|||Windows Installation: There are lots of IDE available for windows operating system which you can use to work easily with C++ programming language. One of the popular IDE is Code::Blocks. To download Code::Blocks you may visit this link. Once you have downloaded the setup file of Code::Blocks from the given link open it and follow the instruction to install.After successfully installing Code::Blocks, go to File menu -> Select New and create an Empty file.Now write your C++ program in this empty file and save the file with a ‘.cpp’ extension.After saving the file with ‘.cpp’ extension, go to Build menu and choose the Build and Run option.|||After successfully installing Code::Blocks, go to File menu -> Select New and create an Empty file.|||Now write your C++ program in this empty file and save the file with a ‘.cpp’ extension.|||After saving the file with ‘.cpp’ extension, go to Build menu and choose the Build and Run option.|||Mac OS X Installation: If you are a Mac user,you have to download Xcode. To download Xcode you have to visit the apple website or you can search it on apple app store. You may follow the link developer.apple.com/technologies/tools/ to download Xcode. You will find all the necessary install instructions there.After successfully installing Xcode, open the Xcode application.To create a new project. Go to File menu -> select New -> select Project. This will create a new project for you.Now in the next window you have to choose a template for your project. To choose a C++ template choose Application option which is under the OS X section on the left side bar. Now choose command-line tools from available options and hit Next button.On the next window provide all the necessary details like ‘name of organisation’, ‘Product Name’ etc. But make sure to choose the language as C++ . After filling the details hit the next button to proceed to further steps.Choose the location where you want to save your project. After this choose the main.cpp file from the directory list on the left side-bar.Now after opening the main.cpp file, you will see a pre written c++ program or template is provided. You may change this program as per your requirement. To run your C++ program you have to go to Product menu and choose the Run option from the dropdown.|||After successfully installing Xcode, open the Xcode application.|||To create a new project. Go to File menu -> select New -> select Project. This will create a new project for you.|||Now in the next window you have to choose a template for your project. To choose a C++ template choose Application option which is under the OS X section on the left side bar. Now choose command-line tools from available options and hit Next button.|||On the next window provide all the necessary details like ‘name of organisation’, ‘Product Name’ etc. But make sure to choose the language as C++ . After filling the details hit the next button to proceed to further steps.|||Choose the location where you want to save your project. After this choose the main.cpp file from the directory list on the left side-bar.|||Now after opening the main.cpp file, you will see a pre written c++ program or template is provided. You may change this program as per your requirement. To run your C++ program you have to go to Product menu and choose the Run option from the dropdown.&&&After successfully installing Code::Blocks, go to File menu -> Select New and create an Empty file.|||Now write your C++ program in this empty file and save the file with a ‘.cpp’ extension.|||After saving the file with ‘.cpp’ extension, go to Build menu and choose the Build and Run option.&&&After successfully installing Xcode, open the Xcode application.|||To create a new project. Go to File menu -> select New -> select Project. This will create a new project for you.|||Now in the next window you have to choose a template for your project. To choose a C++ template choose Application option which is under the OS X section on the left side bar. Now choose command-line tools from available options and hit Next button.|||On the next window provide all the necessary details like ‘name of organisation’, ‘Product Name’ etc. But make sure to choose the language as C++ . After filling the details hit the next button to proceed to further steps.|||Choose the location where you want to save your project. After this choose the main.cpp file from the directory list on the left side-bar.|||Now after opening the main.cpp file, you will see a pre written c++ program or template is provided. You may change this program as per your requirement. To run your C++ program you have to go to Product menu and choose the Run option from the dropdown.&&&&&&Text Editor: Text Editors are type of programs used to edit or write texts. We will use text-editors to type our C++ programs. The normal extension of a text file is (.txt) but a text file containing C++ program should be saved with ‘.CPP’ or ‘.C’ extension. Files ending with the extension ‘.CPP’ and ‘.C’ are called source code files and they are supposed to contain source code written in C++ programming language. These extension helps the compiler to identify that the file contains a C++ program.Before beginning programming with C++, one must have a text-editor installed to write programs.|||C++ Compiler: Once you have installed text-editor and typed and save your program in a file with ‘.CPP’ extension, you will need a C++ compiler to compile this file. A compiler is a computer program which converts high-level language into machine understandable low-level language. In other words, we can say that it converts the source code written in a programming language into another computer language which the computer understands. For compiling a C++ program we will need a C++ compiler which will convert the source code written in C++ into machine codes. Below are the details about setting up compiler on different platforms.Linux Installation: We will install the GNU GCC compiler on Linux. To install and work with the GCC compiler on your Linux machine, proceed according to below steps:You have to first run the below two commands from your Linux terminal window:|||Linux Installation: We will install the GNU GCC compiler on Linux. To install and work with the GCC compiler on your Linux machine, proceed according to below steps:You have to first run the below two commands from your Linux terminal window:|||You have to first run the below two commands from your Linux terminal window:&&&']"
2,['C++ Programming Basics'],[],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/writing-first-c-program-hello-world-example/', 'https://www.geeksforgeeks.org/basic-input-output-c/', 'https://www.geeksforgeeks.org/comments-in-c-c/', 'https://www.geeksforgeeks.org/c-data-types/', 'https://www.geeksforgeeks.org/uninitialized-primitive-data-types-in-c-c/', 'https://www.geeksforgeeks.org/undefined-behavior-c-cpp/', 'https://www.geeksforgeeks.org/variables-in-c/', 'https://www.geeksforgeeks.org/scope-of-variables-in-c/', 'https://www.geeksforgeeks.org/constants-in-c/', 'https://www.geeksforgeeks.org/types-of-literals-in-c-c-with-examples/', 'https://www.geeksforgeeks.org/access-modifiers-in-c/', 'https://www.geeksforgeeks.org/storage-classes-in-c-with-examples/', 'https://www.geeksforgeeks.org/operators-c-c/', 'https://www.geeksforgeeks.org/loops-in-c-and-cpp/', 'https://www.geeksforgeeks.org/decision-making-c-c-else-nested-else/', 'https://www.geeksforgeeks.org/what-are-forward-declarations-in-c/', 'https://www.geeksforgeeks.org/errors-in-cc/', 'https://www.geeksforgeeks.org/tag/cpp-basics/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['Refer here for the archive of Basics in C++.\xa0'],"['C++ is a general-purpose programming language and widely used nowadays for competitive programming. It has imperative, object-oriented and generic programming features. C++ runs on lots of platform like Windows, Linux, Unix, Mac, etc.\xa0', 'However to become proficient in any programming language, one Firstly needs to understand the basics of that language.\xa0', 'Therefore, below are the basics of C++ in the format in which it will help you the most to get the headstart:\xa0']",[],[],[],[],"['Basic Syntax and First Program in C++: Learning C++ programming can be simplified into writing your program in a text editor and saving it with correct extension(.CPP, .C, .CP) and compiling your program using a compiler or online IDE. The “Hello World” program is the first step towards learning any programming language and also one of the simplest programs you will learn.|||Basic I/O in C++:C++ comes with libraries which provides us with many ways for performing input and output. In C++ input and output is performed in the form of a sequence of bytes or more commonly known as streams. The two keywords cin and cout are used very often for taking inputs and printing outputs respectively. These two are the most basic methods of taking input and output in C++.|||Comments in C++: A well-documented program is a good practice as a programmer. It makes a program more readable and error finding become easier. One important part of good documentation is Comments. In computer programming, a comment is a programmer-readable explanation or annotation in the source code of a computer program. These are statements that are not executed by the compiler and interpreter.|||Data Types and Modifiers in C++: All variables use data-type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data it can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data-type with which it is declared. Every data type requires a different amount of memory.|||Uninitialized variable in C++: “One of the things that has kept C++ viable is the zero-overhead rule: What you don’t use, you don’t pay for.” -Stroustrup. The overhead of initializing a stack variable is costly as it hampers the speed of execution, therefore these variables can contain indeterminate values. It is considered a best practice to initialize a primitive data type variable before using it in code.|||Undefined Behaviour in C++: If a user starts learning in C/C++ environment and is unclear with the concept of undefined behaviour then that can bring plenty of problems in the future like while debugging someone else code might be actually difficult in tracing the root to the undefined error.|||Variables and Types in C++: A variable is a name given to a memory location. It is the basic unit of storage in a program. The value stored in a variable can be changed during program execution. A variable is only a name given to a memory location, all the operations done on the variable effects that memory location. In C++, all the variables must be declared before use.|||Variable Scope in C++: In general, scope is defined as the extent up to which something can be worked with. In programming also the scope of a variable is defined as the extent of the program code within which the variable can we accessed or declared or worked with. There are mainly two types of variable scopes, Local and Global Variables.|||Constants and Literals in C++: As the name suggests the name constants is given to such variables or values in C++ programming language which cannot be modified once they are defined. They are fixed values in a program. There can be any types of constants like integer, float, octal, hexadecimal, character constants, etc. Every constant has some range. The integers that are too big to fit into an int will be taken as long. Now there are various ranges that differ from unsigned to signed bits. Under the signed bit, the range of an int varies from -128 to +127 and under the unsigned bit, int varies from 0 to 255. Literals are kind of constants and both the terms are used interchangeably in C++.|||Types of Literals in C++: In this article we will analyse the various kind of literals that C++ provides. The values assigned to each constant variables are referred to as the literals. Generally, both terms, constants and literals are used interchangeably. For eg, “const int = 5;“, is a constant expression and the value 5 is referred to as constant integer literal.|||Access Modifiers in C++: Access modifiers are used to implement an important feature of Object-Oriented Programming known as Data Hiding. Access modifiers or Access Specifiers in a class are used to set the accessibility of the class members. That is, it sets some restrictions on the class members not to get directly accessed by the outside functions.|||Storage Classes in C++: Storage Classes are used to describe the features of a variable/function. These features basically include the scope, visibility, and life-time which help us to trace the existence of a particular variable during the runtime of a program.|||Operators in C++: Operators are the foundation of any programming language. Thus the functionality of C/C++ programming language is incomplete without the use of operators. We can define operators as symbols that help us to perform specific mathematical and logical computations on operands. In other words, we can say that an operator operates the operands.|||Loops in C++: Loops in programming comes into use when we need to repeatedly execute a block of statements. For example: Suppose we want to print “Hello World” 10 times. This can be done in two ways, Iterative method and by using Loops.|||Decision Making in C++:There comes situations in real life when we need to make some decisions and based on these decisions, we decide what should we do next. Similar situations arise in programming also where we need to make some decisions and based on these decisions we will execute the next block of code. Decision-making statements in programming languages decide the direction of flow of program execution.|||Forward declarations in C++: It refers to the beforehand declaration of the syntax or signature of an identifier, variable, function, class, etc. prior to its usage (done later in the program). In C++, Forward declarations are usually used for Classes. In this, the class is pre-defined before its use so that it can be called and used by other classes that are defined before this.|||Errors in C++: Error is an illegal operation performed by the user which results in abnormal working of the program. Programming errors often remain undetected until the program is compiled or executed. Some of the errors inhibit the program from getting compiled or executed. Thus errors should be removed before compiling and executing.']"
3,['C++ Data Types'],['CPP'],[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113115600/DatatypesInC.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113121347/ModifiersInC.png']",[],"['https://www.geeksforgeeks.org/basic/', 'https://www.geeksforgeeks.org/variables-and-keywords-in-c/', 'https://www.geeksforgeeks.org/derived-data-types-in-c/', 'https://www.geeksforgeeks.org/user-defined-derived-data-types-in-c/', 'https://www.geeksforgeeks.org/wide-char-and-library-functions-in-c/', 'https://www.facebook.com/harsh.agarwal.16752', 'http://www.contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Data types in C++ is mainly divided into three types:\xa0\xa0', 'This article discusses primitive data types available in C++.\xa0\xa0', 'Datatype Modifiers', 'Data type modifiers available in C++ are:\xa0\xa0']","['All variables use data-type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data it can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data-type with which it is declared. Every data type requires a different amount of memory.\xa0', 'As the name implies, datatype modifiers are used with the built-in data types to modify the length of data that a particular data type can hold.\xa0\xa0', 'Below table summarizes the modified size and range of built-in datatypes when combined with the type modifiers:\xa0', 'Note : Above values may vary from compiler to compiler. In the above example, we have considered GCC 32 bit.We can display the size of all the data types by using the sizeof() operator and passing the keyword of the datatype as argument to this function as shown below:\xa0\xa0']","['This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ program to sizes of data types#include<iostream>using namespace std; int main(){    cout << ""Size of char : "" << sizeof(char)      << "" byte"" << endl;    cout << ""Size of int : "" << sizeof(int)      << "" bytes"" << endl;    cout << ""Size of short int : "" << sizeof(short int)      << "" bytes"" << endl;    cout << ""Size of long int : "" << sizeof(long int)       << "" bytes"" << endl;    cout << ""Size of signed long int : "" << sizeof(signed long int)       << "" bytes"" << endl;    cout << ""Size of unsigned long int : "" << sizeof(unsigned long int)       << "" bytes"" << endl;    cout << ""Size of float : "" << sizeof(float)       << "" bytes"" <<endl;    cout << ""Size of double : "" << sizeof(double)       << "" bytes"" << endl;    cout << ""Size of wchar_t : "" << sizeof(wchar_t)       << "" bytes"" <<endl;         return 0;}']",['Size of char : 1 byte\nSize of int : 4 bytes\nSize of short int : 2 bytes\nSize of long int : 8 bytes\nSize of signed long int : 8 bytes\nSize of unsigned long int : 8 bytes\nSize of float : 4 bytes\nSize of double : 8 bytes\nSize of wchar_t : 4 bytes'],[],"['Integer|||Character|||Boolean|||Floating Point|||Double Floating Point|||Valueless or Void|||Wide Character&&&Function|||Array|||Pointer|||Reference&&&Class|||Structure|||Union|||Enumeration|||Typedef defined DataType&&&Integer: Keyword used for integer data types is int. Integers typically requires 4 bytes of memory space and ranges from -2147483648 to 2147483647.|||Character: Character data type is used for storing characters. Keyword used for character data type is char. Characters typically requires 1 byte of memory space and ranges from -128 to 127 or 0 to 255.|||Boolean: Boolean data type is used for storing boolean or logical values. A boolean variable can store either true or false. Keyword used for boolean data type is bool.|||Floating Point: Floating Point data type is used for storing single precision floating point values or decimal values. Keyword used for floating point data type is float. Float variables typically requires 4 byte of memory space.|||Double Floating Point: Double Floating Point data type is used for storing double precision floating point values or decimal values. Keyword used for double floating point data type is double. Double variables typically requires 8 byte of memory space.|||void: Void means without any value. void datatype represents a valueless entity. Void data type is used for those function which does not returns a value.|||Wide Character: Wide character data type is also a character data type but this data type has size greater than the normal 8-bit datatype. Represented by wchar_t. It is generally 2 or 4 bytes long.&&&Signed|||Unsigned|||Short|||Long&&&&&&Primitive Data Types: These data types are built-in or predefined data types and can be used directly by the user to declare variables. example: int, char , float, bool etc. Primitive data types available in C++ are:IntegerCharacterBooleanFloating PointDouble Floating PointValueless or VoidWide Character|||Integer|||Character|||Boolean|||Floating Point|||Double Floating Point|||Valueless or Void|||Wide Character|||Derived Data Types: The data-types that are derived from the primitive or built-in datatypes are referred to as Derived Data Types. These can be of four types namely:FunctionArrayPointerReference|||Function|||Array|||Pointer|||Reference|||Abstract or User-Defined Data Types: These data types are defined by user itself. Like, defining a class in C++ or a structure. C++ provides the following user-defined datatypes:ClassStructureUnionEnumerationTypedef defined DataType|||Class|||Structure|||Union|||Enumeration|||Typedef defined DataType&&&']"
4,['Variables in C++'],['CPP'],[],"['https://media.geeksforgeeks.org/wp-content/uploads/20190708153106/Variables-in-C-1.jpg', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113121956/TypesofVariableInC.png']",[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/c-data-types/', 'https://www.geeksforgeeks.org/scope-of-variables-in-c/', 'https://www.geeksforgeeks.org/static-keyword-cpp/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['A variable is a name given to a memory location. It is the basic unit of storage in a program.\xa0', 'How to declare variables?', 'A typical variable declaration is of the form:\xa0\xa0', 'In the above diagram,\xa0\xa0', 'Examples:\xa0\xa0', 'Difference between variable declaration and definition', 'Types of variables', 'There are three types of variables based on the scope of variables in C++:\xa0\xa0', 'Let us now learn about each one of these variables in detail.\xa0\xa0', 'Instance variable Vs Static variable']","['A variable name can consist of alphabets (both upper and lower case), numbers and the underscore ‘_’ character. However, the name must not start with a number.\xa0', 'datatype: Type of data that can be stored in this variable.\xa0variable_name: Name given to the variable.\xa0value: It is the initial value stored in the variable.\xa0\xa0', 'The variable declaration refers to the part where a variable is first declared or introduced before its first use. A variable definition is a part where the variable is assigned a memory location and a value. Most of the times, variable declaration and definition are done together.See the following C++ program for better clarification:\xa0\xa0']",[],"[""#include <iostream>using namespace std;  int main(){    // declaration and definition    // of variable 'a123'    char a123 = 'a';      // This is also both declaration and definition    // as 'b' is allocated memory and    // assigned some garbage value.    float b;      // multiple declarations and definitions    int _c, _d45, e;      // Let us print a variable    cout << a123 << endl;      return 0;}""]","['// Declaring a single variable\ntype variable_name;\n\n// Declaring multiple variables:\ntype variable1_name, variable2_name, variable3_name;', '// Declaring float variable\nfloat simpleInterest; \n\n// Declaring integer variable\nint time, speed; \n\n// Declaring character variable\nchar var;', 'a', 'class Example\n{\n    static int a; // static variable\n    int b;        // instance variable\n}']",[],"['The value stored in a variable can be changed during program execution.|||A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.|||In C++, all the variables must be declared before use.&&&Local Variables|||Instance Variables|||Static Variables&&&These variable are created when the block in entered or the function is called and destroyed after exiting from the block or when the call returns from the function.|||The scope of these variables exists only within the block in which the variable is declared. i.e. we can access these variable only within that block.|||Initialisation of Local Variable is Mandatory.&&&As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed.|||Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier then the default access specifier will be used.|||Initialisation of Instance Variable is not Mandatory.|||Instance Variable can be accessed only by creating objects.&&&These variables are declared similarly as instance variables, the difference is that static variables are declared using the static keyword within a class outside any method constructor or block.|||Unlike instance variables, we can only have one copy of a static variable per class irrespective of how many objects we create.|||Static variables are created at the start of program execution and destroyed automatically when execution ends.|||Initialization of Static Variable is not Mandatory. Its default value is 0|||If we access the static variable like Instance variable (through an object), the compiler will show the warning message and it won’t halt the program. The compiler will replace the object name to class name automatically.|||If we access the static variable without the class name, Compiler will automatically append the class name.&&&Each object will have its own copy of instance variable whereas We can only have one copy of a static variable per class irrespective of how many objects we create.|||Changes made in an instance variable using one object will not be reflected in other objects as each object has its own copy of instance variable. In case of static, changes will be reflected in other objects as static variables are common to all object of a class.|||We can access instance variables through object references and Static Variables can be accessed directly using class name.|||Syntax for static and instance variables:class Example\n{\n    static int a; // static variable\n    int b;        // instance variable\n}&&&&&&Local Variables: A variable defined within a block or method or constructor is called local variable.These variable are created when the block in entered or the function is called and destroyed after exiting from the block or when the call returns from the function.The scope of these variables exists only within the block in which the variable is declared. i.e. we can access these variable only within that block.Initialisation of Local Variable is Mandatory.|||These variable are created when the block in entered or the function is called and destroyed after exiting from the block or when the call returns from the function.|||The scope of these variables exists only within the block in which the variable is declared. i.e. we can access these variable only within that block.|||Initialisation of Local Variable is Mandatory.|||Instance Variables: Instance variables are non-static variables and are declared in a class outside any method, constructor or block.As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed.Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier then the default access specifier will be used.Initialisation of Instance Variable is not Mandatory.Instance Variable can be accessed only by creating objects.|||As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed.|||Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier then the default access specifier will be used.|||Initialisation of Instance Variable is not Mandatory.|||Instance Variable can be accessed only by creating objects.|||Static Variables: Static variables are also known as Class variables.These variables are declared similarly as instance variables, the difference is that static variables are declared using the static keyword within a class outside any method constructor or block.Unlike instance variables, we can only have one copy of a static variable per class irrespective of how many objects we create.Static variables are created at the start of program execution and destroyed automatically when execution ends.Initialization of Static Variable is not Mandatory. Its default value is 0If we access the static variable like Instance variable (through an object), the compiler will show the warning message and it won’t halt the program. The compiler will replace the object name to class name automatically.If we access the static variable without the class name, Compiler will automatically append the class name.|||These variables are declared similarly as instance variables, the difference is that static variables are declared using the static keyword within a class outside any method constructor or block.|||Unlike instance variables, we can only have one copy of a static variable per class irrespective of how many objects we create.|||Static variables are created at the start of program execution and destroyed automatically when execution ends.|||Initialization of Static Variable is not Mandatory. Its default value is 0|||If we access the static variable like Instance variable (through an object), the compiler will show the warning message and it won’t halt the program. The compiler will replace the object name to class name automatically.|||If we access the static variable without the class name, Compiler will automatically append the class name.&&&']"
5,['Loops in C and C++'],"['C', 'C++', 'C', 'C++', 'C', 'C++', 'C', 'C++', 'C', 'C++']",[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191128194516/Cpp-loops.png', 'https://media.geeksforgeeks.org/wp-content/uploads/loops.png', 'https://media.geeksforgeeks.org/wp-content/uploads/php-while-loop.jpg', 'https://media.geeksforgeeks.org/wp-content/uploads/php-do-while.jpg']",[],"['https://www.geeksforgeeks.org/easy/', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191128194516/Cpp-loops.png', 'https://www.geeksforgeeks.org/range-based-loop-c/', 'https://www.geeksforgeeks.org/for_each-loop-c/', 'https://www.geeksforgeeks.org/what-happens-if-loop-runs-till-maximum-of-signed-and-unsigned-in-c/', 'https://www.geeksforgeeks.org/c-language-2-gq/loops-control-structure-gq/', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Iterative Method', 'An iterative method to do this is to write the printf() statement 10 times.', 'Using Loops', 'There are mainly two types of loops:', 'Equivalent flow diagram for loop :', 'While Loop', 'Flow Diagram:', 'do while loop', 'Note: Notice the semi – colon(“;”) in the end of loop.', 'Flow Diagram:', 'What about an Infinite Loop?', 'More Advanced Looping Techniques', 'Important Points:', 'Related Articles:']","['Loops in programming come into use when we need to repeatedly execute a block of statements. For example: Suppose we want to print “Hello World” 10 times. This can be done in two ways as shown below:', 'In Loop, the statement needs to be written only once and the loop will be executed 10 times as shown below.In computer programming, a loop is a sequence of instructions that is repeated until a certain condition is reached.', 'A for loop is a repetition control structure which allows us to write a loop that is executed a specific number of times. The loop enables us to perform n number of steps together in one line.Syntax:', 'In for loop, a loop variable is used to control the loop. First initialize this loop variable to some value, then check whether this variable is less than or greater than counter value. If statement is true, then loop body is executed and loop variable gets updated . Steps are repeated till exit condition comes.', 'While studying for loop we have seen that the number of iterations is known beforehand, i.e. the number of times the loop body is needed to be executed is known to us. while loops are used in situations where we do not know the exact number of iterations of loop beforehand. The loop execution is terminated on the basis of test condition.', 'Syntax:We have already stated that a loop is mainly consisted of three statements – initialization expression, test expression, update expression. The syntax of the three loops – For, while and do while mainly differs on the placement of these three statements.', 'In the above program the test condition (i<1) evaluates to false. But still as the loop is exit – controlled the loop body will execute once.', 'An infinite loop (sometimes called an endless loop ) is a piece of coding that lacks a functional exit so that it repeats indefinitely. An infinite loop occurs when a condition always evaluates to true. Usually, this is an error.', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['In do while loops also the loop execution is terminated on the basis of test condition. The main difference between do while loop and while loop is in do while loop the condition is tested at the end of loop body, i.e do while loop is exit controlled whereas the other two loops are entry controlled loops.Note: In do while loop the loop body will execute at least once irrespective of test condition.']","['// C program to illustrate need of loops#include <stdio.h>  int main(){    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");    printf( ""Hello World\\n"");          return 0;}', '// C++ program to illustrate need of loops#include <iostream>using namespace std;  int main(){    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    cout << ""Hello World\\n"";    return 0;}', '// C program to illustrate for loop#include <stdio.h>  int main(){    int i=0;          for (i = 1; i <= 10; i++)    {        printf( ""Hello World\\n"");        }      return 0;}', '// C++ program to illustrate for loop#include <iostream>using namespace std;  int main(){    for (int i = 1; i <= 10; i++)    {        cout << ""Hello World\\n"";    }      return 0;}', '// C program to illustrate while loop#include <stdio.h>  int main(){    // initialization expression    int i = 1;      // test expression    while (i < 6)    {        printf( ""Hello World\\n"");              // update expression        i++;    }      return 0;}', '// C++ program to illustrate while loop#include <iostream>using namespace std;  int main(){    // initialization expression    int i = 1;      // test expression    while (i < 6)    {        cout << ""Hello World\\n"";          // update expression        i++;    }      return 0;}', '// C program to illustrate do-while loop#include <stdio.h>  int main(){    int i = 2; // Initialization expression      do    {        // loop body        printf( ""Hello World\\n"");              // update expression        i++;      }  while (i < 1);   // test expression      return 0;}', '// C++ program to illustrate do-while loop#include <iostream>using namespace std;  int main(){    int i = 2; // Initialization expression      do    {        // loop body        cout << ""Hello World\\n"";          // update expression        i++;      }  while (i < 1);   // test expression      return 0;}', '// C program to demonstrate infinite loops// using for and while// Uncomment the  sections to see the output  #include <stdio.h>  int main (){    int i;      // This is an infinite for loop as the condition    // expression is blank    for ( ; ; )    {       printf(""This loop will run forever.\\n"");    }      // This is an infinite for loop as the condition    // given in while loop will keep repeating infinitely    /*    while (i != 0)    {        i-- ;        printf( ""This loop will run forever.\\n"");    }    */      // This is an infinite for loop as the condition    // given in while loop is ""true""    /*    while (true)    {        printf( ""This loop will run forever.\\n"");    }    */}', '// C++ program to demonstrate infinite loops// using for and while// Uncomment the  sections to see the output  #include <iostream>using namespace std;int main (){    int i;      // This is an infinite for loop as the condition    // expression is blank    for ( ; ; )    {        cout << ""This loop will run forever.\\n"";    }      // This is an infinite for loop as the condition    // given in while loop will keep repeating infinitely    /*    while (i != 0)    {        i-- ;        cout << ""This loop will run forever.\\n"";    }    */      // This is an infinite for loop as the condition    // given in while loop is ""true""    /*    while (true)    {        cout << ""This loop will run forever.\\n"";    }    */}']","['Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World', 'for (initialization expr; test expr; update expr)\n{    \n     // body of the loop\n     // statements we want to execute\n}', 'Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World', 'initialization expression;\nwhile (test_expression)\n{\n   // statements\n \n  update_expression;\n}', 'Hello World\nHello World\nHello World\nHello World\nHello World', 'initialization expression;\ndo\n{\n   // statements\n\n   update_expression;\n} while (test_expression);', 'Hello World', 'This loop will run forever.\nThis loop will run forever.\n...................']",[],"['An operation is done, such as getting an item of data and changing it, and then some condition is checked such as whether a counter has reached a prescribed number.|||Counter not Reached: If the counter has not reached the desired number, the next instruction in the sequence returns to the first instruction in the sequence and repeat it.|||Counter reached: If the condition has been reached, the next instruction “falls through” to the next sequential instruction or branches outside the loop.&&&Initialization Expression: In this expression we have to initialize the loop counter to some value. for example: int i=1;|||Test Expression: In this expression we have to test the condition. If the condition evaluates to true then we will execute the body of loop and go to update expression otherwise we will exit from the for loop. For example: i <= 10;|||Update Expression: After executing loop body this expression increments/decrements the loop variable by some value. for example: i++;&&&Range-based for loop in C++|||for_each loop in C++&&&Use for loop when number of iterations is known beforehand, i.e. the number of times the loop body is needed to be executed is known.|||Use while loops where exact number of iterations is not known but the loop termination condition is known.|||Use do while loop if the code needs to be executed at least once like in Menu driven programs&&&What happens if loop till Maximum of Signed and Unsigned in C/C++?|||Quiz on Loops&&&&&&Entry Controlled loops: In this type of loops the test condition is tested before entering the loop body. For Loop and While Loop are entry controlled loops.|||Exit Controlled Loops: In this type of loops the test condition is tested or evaluated at the end of loop body. Therefore, the loop body will execute atleast once, irrespective of whether the test condition is true or false. do – while loop is exit controlled loop.&&&']"
6,"['Decision Making in C / C++ (if , if..else, Nested if, if-else-if )']","['C', 'C++', 'C', 'C++', 'C', 'C++', 'C', 'C++', 'C', 'C++', 'C', 'C++', 'C++', 'C', 'C', 'C++', 'C', 'C++']",[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191202113149/CPP-Decision-Making.png', 'https://media.geeksforgeeks.org/wp-content/uploads/decision-making-c-1.png', 'https://media.geeksforgeeks.org/wp-content/uploads/decision-making-c-2.png', 'https://media.geeksforgeeks.org/wp-content/uploads/decision-making-c-3.png', 'https://media.geeksforgeeks.org/wp-content/uploads/decision-making-c-4.png', 'https://media.geeksforgeeks.org/wp-content/uploads/break.png', 'https://media.geeksforgeeks.org/wp-content/uploads/continue.png', 'https://media.geeksforgeeks.org/wp-content/uploads/goto.png']",[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/#if', 'https://www.geeksforgeeks.org/#if-else', 'https://www.geeksforgeeks.org/#nested-if', 'https://www.geeksforgeeks.org/#if-else-if', 'https://www.geeksforgeeks.org/switch-statement-cc/', 'https://www.geeksforgeeks.org/#jmp', 'https://www.geeksforgeeks.org/#brk', 'https://www.geeksforgeeks.org/#cont', 'https://www.geeksforgeeks.org/#got', 'https://www.geeksforgeeks.org/#ret', 'https://www.geeksforgeeks.org/break-statement-cc/', 'https://www.geeksforgeeks.org/continue-statement-cpp/', 'https://www.geeksforgeeks.org/continue-statement-cpp/', 'https://www.geeksforgeeks.org/break-statement-cc/', 'https://www.geeksforgeeks.org/goto-statement-in-c-cpp/', 'https://www.geeksforgeeks.org/return-statement-in-c-cpp-with-examples/', 'https://www.facebook.com/harsh.agarwal.16752', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['if statement in C/C++', 'Flowchart\xa0\xa0', 'if-else in C/C++', 'Flowchart:\xa0\xa0', 'nested-if in C/C++', 'Flowchart\xa0\xa0', 'Example:\xa0\xa0', 'if-else-if ladder in C/C++', 'Example:\xa0\xa0', 'Jump Statements in C/C++', '?list=PLqM7alHXFySGg6GSRmE2INI4k8fPH5qVB\xa0\xa0']","['Decision-making statements in programming languages decide the direction of the flow of program execution. Decision-making statements available in C or C++ are:\xa0\xa0', 'if statement is the most simple decision-making statement. It is used to decide whether a certain statement or block of statements will be executed or not i.e if a certain condition is true then a block of statement is executed otherwise not.\xa0Syntax:\xa0\xa0', 'Here, the condition after evaluation will be either true or false. C if statement accepts boolean values – if the value is true then it will execute the block of statements below it otherwise not. If we do not provide the curly braces ‘{‘ and ‘}’ after if(condition) then by default if statement will consider the first immediately below statement to be inside its block.\xa0Example:\xa0\xa0', 'As the condition present in the if statement is false. So, the block below the if statement is not executed.\xa0', 'The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false it won’t. But what if we want to do something else if the condition is false. Here comes the C else statement. We can use the else statement with if statement to execute a block of code when the condition is false.\xa0Syntax:\xa0\xa0', 'The block of code following the else statement is executed as the condition present in the if statement is false.\xa0', 'A nested if in C is an if statement that is the target of another if statement. Nested if statements mean an if statement inside another if statement. Yes, both C and C++ allow us to nested if statements within if statements, i.e, we can place an if statement inside another if statement.\xa0Syntax:\xa0\xa0', 'Here, a user can decide among multiple options. The C if statements are executed from the top down. As soon as one of the conditions controlling the if is true, the statement associated with that if is executed, and the rest of the C else-if ladder is bypassed. If none of the conditions are true, then the final else statement will be executed.\xa0Syntax:\xa0\xa0', 'These statements are used in C orC++ for the unconditional flow of control throughout the functions in a program. They support four types of jump statements:\xa0', 'If you create a variable in if-else in C/C++, it will be local to that if/else block only. You can use global variables inside the if/else block. If the name of the variable you created in if/else is as same as any global variable then priority will be given to `local variable`.\xa0']","['There come situations in real life when we need to make some decisions and based on these decisions, we decide what should we do next. Similar situations arise in programming also where we need to make some decisions and based on these decisions we will execute the next block of code. For example, in C if x occurs then execute y else execute z. There can also be multiple conditions like in C if x occurs then execute p, else if condition y occurs execute q, else execute r. This condition of C else-if is one of the many ways of importing multiple conditions.\xa0\xa0']","['// C program to illustrate If statement#include <stdio.h> int main() {    int i = 10;     if (i > 15)    {       printf(""10 is less than 15"");    }           printf(""I am Not in if"");}', '// C++ program to illustrate If statement#include<iostream>using namespace std;     int main()    {        int i = 10;          if (i > 15)        {           cout<<""10 is less than 15"";        }                   cout<<""I am Not in if"";    }', '// C program to illustrate If statement#include <stdio.h> int main() {    int i = 20;     if (i < 15){               printf(""i is smaller than 15"");    }    else{               printf(""i is greater than 15"");    }           return 0;   }', '// C++ program to illustrate if-else statement#include<iostream>using namespace std; int main() {        int i = 20;          if (i < 15)            cout<<""i is smaller than 15"";        else            cout<<""i is greater than 15"";                 return 0;    }', '// C program to illustrate nested-if statement#include <stdio.h> int main() {    int i = 10;     if (i == 10)    {        // First if statement        if (i < 15)           printf(""i is smaller than 15\\n"");         // Nested - if statement        // Will only be executed if statement above        // is true        if (i < 12)            printf(""i is smaller than 12 too\\n"");        else            printf(""i is greater than 15"");    }     return 0;}', '// C++ program to illustrate nested-if statement#include <iostream>using namespace std; int main(){    int i = 10;     if (i == 10)    {        // First if statement        if (i < 15)           cout<<""i is smaller than 15\\n"";         // Nested - if statement        // Will only be executed if statement above        // is true        if (i < 12)            cout<<""i is smaller than 12 too\\n"";        else            cout<<""i is greater than 15"";    }     return 0;}', '// C program to illustrate nested-if statement#include <stdio.h> int main() {    int i = 20;      if (i == 10)        printf(""i is 10"");    else if (i == 15)        printf(""i is 15"");    else if (i == 20)        printf(""i is 20"");    else        printf(""i is not present"");}', '// C++ program to illustrate if-else-if ladder#include<iostream>using namespace std; int main(){    int i = 20;      if (i == 10)        cout<<""i is 10"";    else if (i == 15)        cout<<""i is 15"";    else if (i == 20)        cout<<""i is 20"";    else        cout<<""i is not present"";}', '// C program to illustrate// Linear Search #include <stdio.h> void findElement(int arr[], int size, int key){    // loop to traverse array and search for key    for (int i = 0; i < size; i++) {        if (arr[i] == key) {            printf(""Element found at position: %d"", (i + 1));            break;        }    }} int main() {    int arr[] = { 1, 2, 3, 4, 5, 6 };         // no of elements    int n = 6;          // key to be searched    int key = 3;     // Calling function to find the key    findElement(arr, n, key);     return 0;}', '// CPP program to illustrate// Linear Search#include <iostream>using namespace std; void findElement(int arr[], int size, int key){    // loop to traverse array and search for key    for (int i = 0; i < size; i++) {        if (arr[i] == key) {            cout << ""Element found at position: "" << (i + 1);            break;        }    }} // Driver program to test above functionint main(){    int arr[] = { 1, 2, 3, 4, 5, 6 };    int n = 6; // no of elements    int key = 3; // key to be searched     // Calling function to find the key    findElement(arr, n, key);     return 0;}', '// C program to explain the use// of continue statement#include <stdio.h> int main() {    // loop from 1 to 10    for (int i = 1; i <= 10; i++) {         // If i is equals to 6,        // continue to next iteration        // without printing        if (i == 6)            continue;         else            // otherwise print the value of i            printf(""%d "", i);    }     return 0;}', '// C++ program to explain the use// of continue statement #include <iostream>using namespace std; int main(){    // loop from 1 to 10    for (int i = 1; i <= 10; i++) {         // If i is equals to 6,        // continue to next iteration        // without printing        if (i == 6)            continue;         else            // otherwise print the value of i            cout << i << "" "";    }     return 0;}', '#include<iostream>using namespace std; int main(){    int gfg=0; // local variable for main    cout<<""Before if-else block ""<<gfg<<endl;    if(1){        int gfg = 100; // new local variable of if block        cout<<""if block ""<<gfg<<endl;    }    cout<<""After if block ""<<gfg<<endl;    return 0;}/*    Before if-else block 0    if block 100    After if block 0*/', '#include <stdio.h> int main() {       int gfg=0; // local variable for main    printf(""Before if-else block %d\\n"",gfg);    if(1){        int gfg = 100; // new local variable of if block        printf(""if block %d\\n"",gfg);    }    printf(""After if block %d"",gfg);  return 0;}', '// C program to print numbers// from 1 to 10 using goto statement#include <stdio.h> // function to print numbers from 1 to 10void printNumbers(){    int n = 1;label:    printf(""%d "",n);    n++;    if (n <= 10)        goto label;} // Driver program to test above functionint main() {    printNumbers();    return 0;}', '// C++ program to print numbers// from 1 to 10 using goto statement#include <iostream>using namespace std; // function to print numbers from 1 to 10void printNumbers(){    int n = 1;label:    cout << n << "" "";    n++;    if (n <= 10)        goto label;} // Driver program to test above functionint main(){    printNumbers();    return 0;}', '// C code to illustrate return// statement#include <stdio.h> // non-void return type// function to calculate sumint SUM(int a, int b){    int s1 = a + b;    return s1;} // returns void// function to printvoid Print(int s2){    printf(""The sum is %d"", s2);    return;} int main(){    int num1 = 10;    int num2 = 10;    int sum_of = SUM(num1, num2);    Print(sum_of);    return 0;}', '// C++ code to illustrate return// statement#include <iostream>using namespace std; // non-void return type// function to calculate sumint SUM(int a, int b){    int s1 = a + b;    return s1;} // returns void// function to printvoid Print(int s2){    cout << ""The sum is ""<< s2;    return;} int main(){    int num1 = 10;    int num2 = 10;    int sum_of = SUM(num1, num2);    Print(sum_of);    return 0;}']","['if(condition) \n{\n   // Statements to execute if\n   // condition is true\n}', 'if(condition)\n   statement1;\n   statement2;\n\n// Here if the condition is true, if block \n// will consider only statement1 to be inside \n// its block.', 'I am Not in if', 'if (condition)\n{\n    // Executes this block if\n    // condition is true\n}\nelse\n{\n    // Executes this block if\n    // condition is false\n}', 'i is greater than 15', 'if (condition1) \n{\n   // Executes when condition1 is true\n   if (condition2) \n   {\n      // Executes when condition2 is true\n   }\n}', 'i is smaller than 15\ni is smaller than 12 too', 'if (condition)\n    statement;\nelse if (condition)\n    statement;\n.\n.\nelse\n    statement;', 'i is 20', 'break;', 'Element found at position: 3', 'continue;', '1 2 3 4 5 7 8 9 10', 'Syntax1      |   Syntax2\n----------------------------\ngoto label;  |    label:  \n.            |    .\n.            |    .\n.            |    .\nlabel:       |    goto label;', '1 2 3 4 5 6 7 8 9 10', 'return[expression];', 'The sum is 20']",[],"['if statement|||if..else statements|||nested if statements|||if-else-if ladder|||switch statements|||Jump Statements:breakcontinuegotoreturn|||break|||continue|||goto|||return&&&break|||continue|||goto|||return&&&C break: This loop control statement is used to terminate the loop. As soon as the break statement is encountered from within a loop, the loop iterations stop there, and control returns from the loop immediately to the first statement after the loop.Syntax:&&&Basically, break statements are used in situations when we are not sure about the actual number of iterations for the loop or we want to terminate the loop based on some condition.&&&Example:&&&&&&|||C continues: This loop control statement is just like the break statement. The continue statement is opposite to that of the break statement, instead of terminating the loop, it forces to execute the next iteration of the loop.As the name suggests the continue statement forces the loop to continue or execute the next iteration. When the continue statement is executed in the loop, the code inside the loop following the continue statement will be skipped and the next iteration of the loop will begin.Syntax:&&&&&&Example:&&&&&&&&&C goto: The goto statement in C/C++ also referred to as unconditional jump statement can be used to jump from one point to another within a function.Syntax:&&&In the above syntax, the first line tells the compiler to go to or jump to the statement marked as a label. Here label is a user-defined identifier that indicates the target statement. The statement immediately followed after ‘label:’ is the destination statement. The ‘label:’ can also appear before the ‘goto label;’ statement in the above syntax.&&&Below are some examples of how to use goto statement:Examples:&&&&&&|||C return: The return in C or C++ returns the flow of the execution to the function from where it is called. This statement does not mandatorily need any conditional statements. As soon as the statement is executed, the flow of the program stops immediately and return the control from where it was called. The return statement may or may not return anything for a void function, but for a non-void function, a return value is must be returned.Syntax:&&&Example:&&&&&&']"
7,['I/O Redirection in C++'],['CPP'],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'http://www.cplusplus.com/reference/cstdio/freopen/', 'http://www.cplusplus.com/reference/ios/ios/rdbuf/', 'http://www.cplusplus.com/reference/ios/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['For Example, to redirect the stdout to say a textfile, we could write\xa0', 'We can use the function ios::rdbuf() to perform two operations.\xa0', 'Here is an example program below to show the steps\xa0', 'Note:\xa0The above steps can be condensed into a single step\xa0', 'References:\xa0CPP IOS\xa0']","['In C, we could use the function freopen() to redirect an existing FILE pointer to another stream. The prototype for freopen() is given as\xa0']","['While this method is still supported in C++, this article discusses another way to redirect I/O streams.C++ being an object-oriented programming language gives us the ability to not only define our own streams but also redirect standard streams. Thus, in C++, a stream is an object whose behavior is defined by a class. Thus, anything that behaves like a stream is also a stream.\xa0Streams Objects in C++ are mainly of three types :\xa0\xa0', 'All these classes, as well as file stream classes, derived from the classes: ios and streambuf. Thus, filestream and IO stream objects behave similarly.All stream objects also have an associated data member of class streambuf. Simply put streambuf object is the buffer for the stream. When we read data from a stream, we don’t read it directly from the source, but instead, we read it from the buffer which is linked to the source. Similarly, output operations are first performed on the buffer, and then the buffer is flushed (written to the physical device) when needed.C++ allows us to set the stream buffer for any stream. So the task of redirecting the stream simply reduces to changing the stream buffer associated with the stream. Thus, to redirect a Stream A to Stream B we need to do:-\xa0']","['// Cpp program to redirect cout to a file#include <fstream>#include <iostream>#include <string> using namespace std; int main(){    fstream file;    file.open(""cout.txt"", ios::out);    string line;     // Backup streambuffers of  cout    streambuf* stream_buffer_cout = cout.rdbuf();    streambuf* stream_buffer_cin = cin.rdbuf();     // Get the streambuffer of the file    streambuf* stream_buffer_file = file.rdbuf();     // Redirect cout to file    cout.rdbuf(stream_buffer_file);     cout << ""This line written to file"" << endl;     // Redirect cout back to screen    cout.rdbuf(stream_buffer_cout);    cout << ""This line is written to screen"" << endl;     file.close();    return 0;}']","['FILE * freopen ( const char * filename, const char * mode, FILE * stream );', 'freopen (""text_file.txt"", ""w"", stdout);', '1) stream_object.rdbuf(): Returns pointer to the stream buffer of stream_object\n2) stream_object.rdbuf(streambuf * p): Sets the stream buffer to the object pointed by p', 'This line is written to screen\nContents of file cout.txt:\nThis line written to file', 'auto cout_buf = cout.rdbuf(file.rdbuf())\n\n// sets couts streambuffer and returns the old \nstreambuffer back to cout_buf']",[],['istream : Stream object of this type can only perform input operations from the stream|||ostream : These objects can only be used for output operations.|||iostream : Can be used for both input and output operations&&&&&&Get the stream buffer of A and store it somewhere|||Set the stream buffer of A to the stream buffer of B|||If needed to reset the stream buffer of A to its previous stream buffer&&&']
8,['Basic Input / Output in C++'],"['C++', 'C++', 'C++', 'C++']",[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113125616/C-basic-input-output.png'],['https://www.youtube.com/embed/I16GqVWJXKE?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/endl-vs-n/', 'https://www.geeksforgeeks.org/problem-with-scanf-when-there-is-fgetsgetsscanf-after-it/', 'https://www.geeksforgeeks.org/how-to-use-getline-in-c-when-there-are-black-lines-in-input/', 'https://www.geeksforgeeks.org/cincout-vs-scanfprintf/', 'https://www.facebook.com/harsh.agarwal.16752', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Header files available in C++ for Input/Output operations are:\xa0', '\xa0Related Articles: \xa0']","['C++ comes with libraries that provide us with many ways for performing input and output. In C++ input and output are performed in the form of a sequence of bytes or more commonly known as streams.', 'The two instances cout in C++ and cin in C++\xa0of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++. To use cin and cout in C++ one must include the header file iostream in the program.', 'This article mainly discusses the objects defined in the header file iostream like the cin and cout.\xa0\xa0', 'In the above program, the insertion operator(<<) inserts the value of the string variable sample followed by the string “A computer science portal for geeks” in the standard output stream cout which is then displayed on the screen.', 'The above program asks the user to input the age. The object cin is connected to the input device. The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.']","['This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['#include <iostream> using namespace std; int main(){    char sample[] = ""GeeksforGeeks"";     cout << sample << "" - A computer science portal for geeks"";     return 0;}', '#include <iostream>using namespace std; int main(){    int age;     cout << ""Enter your age:"";    cin >> age;    cout << ""\\nYour age is: "" << age;     return 0;}', '#include <iostream> using namespace std; int main(){    cerr << ""An error occurred"";    return 0;}', '#include <iostream> using namespace std; int main(){    clog << ""An error occurred"";     return 0;}']","['GeeksforGeeks - A computer science portal for geeks', '18', 'Enter your age:\nYour age is: 18', 'An error occurred', 'An error occurred']",[],"['Input Stream: If the direction of flow of bytes is from the device(for example, Keyboard) to the main memory then this process is called input.|||Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device( display screen ) then this process is called output.&&&Standard output stream (cout): Usually the standard output device is the display screen. The C++ cout statement is the instance of the ostream class. It is used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).&&&standard input stream (cin): Usually the input device in a computer is the keyboard. C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard.The extraction operator(>>) is used along with the object cin for reading inputs. The extraction operator extracts the data from the object cin which is entered using the keyboard.&&&Un-buffered standard error stream (cerr): The C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the ostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.|||The main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)&&&buffered standard error stream (clog): This is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.&&&cout << endl vs cout << “\\n” in C++|||Problem with scanf() when there is fgets()/gets()/scanf() after it|||How to use getline() in C++ when there are blank lines in input?|||Cin-Cout vs Scanf-Printf&&&&&&iostream: iostream stands for standard input-output stream. This header file contains definitions of objects like cin, cout, cerr, etc.|||iomanip: iomanip stands for input-output manipulators. The methods declared in these files are used for manipulating streams. This file contains definitions of setw, setprecision, etc.|||fstream: This header file mainly describes the file stream. This header file is used to handle the data being read from a file as input or data being written into the file as output.&&&']"
9,['Clearing\xa0The\xa0Input\xa0Buffer\xa0In\xa0C/C++'],"['C', 'C++', 'C', 'C++', 'C++', 'C++']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/c/', 'https://www.geeksforgeeks.org/c-plus-plus/', 'https://practice.geeksforgeeks.org/courses/ds-in-c??utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_DS_C']","['In the case of C Programming\xa0', 'In the case of C++\xa0', 'How can it be resolved?', 'In the case of C :\xa0\xa0', 'In the case of C++ :\xa0\xa0']","['What is a buffer?\xa0A temporary storage area is called a buffer. All standard input and output devices contain an input and output buffer. In standard C/C++, streams are buffered, for example in the case of standard input, when we press the key on the keyboard, it isn’t sent to your program, rather it is buffered by the operating system till the time is allotted to that program.', 'In both the above codes, the output is not printed as desired. The reason for this is an occupied Buffer. The “\\n” character goes remains there in buffer and is read as the next input.', '1. Using “ while ((getchar()) != ‘\\n’); ” : Typing “while ((getchar()) != ‘\\n’);” reads the buffer characters till the end and discards them(including newline) and using it after the “scanf()” statement clears the input buffer and allows the input in the desired container.', '2. Using “ fflush(stdin) ”: Typing “fflush(stdin)” after “scanf()” statement also clears the input buffer but use of it is avoided and is termed to be “undefined” for input stream as per the C++11 standards.', '1. Using “ cin.ignore(numeric_limits::max(),’\\n’); ” :- Typing “cin.ignore(numeric_limits::max(),’\\n’);” after the “cin” statement discards everything in the input stream including the newline.\xa0', '2. Using “ cin.sync() ”: Typing “cin.sync()” after the “cin” statement discards all that is left in the buffer. Though “cin.sync()” does not work in all implementations (According to C++11 and above standards).\xa0', '3. Using “ cin >> ws ”: Typing “cin>>ws” after “cin” statement tells the compiler to ignore buffer and also to discard all the whitespaces before the actual content of string or character array.\xa0', 'This article is contributed by Manjeet Singh. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['How does it affect Programming?\xa0On various occasions, you may need to clear the unwanted buffer so as to get the next input in the desired container and not in the buffer of the previous variable. For example, in the case of C after encountering “scanf()”, if we need to input a character array or character, and in the case of C++, after encountering the “cin” statement, we require to input a character array or a string, we require to clear the input buffer or else the desired input is occupied by a buffer of the previous variable, not by the desired container. On pressing “Enter” (carriage return) on the output screen after the first input, as the buffer of the previous variable was the space for a new container(as we didn’t clear it), the program skips the following input of the container.']","['// C Code to explain why not// clearing the input buffer// causes undesired outputs#include<stdio.h>int main(){    char str[80], ch;         // Scan input from user -    // GeeksforGeeks for example    scanf(""%s"", str);         // Scan character from user-    // \'a\' for example    ch = getchar();         // Printing character array,    // prints “GeeksforGeeks”)    printf(""%s\\n"", str);         // This does not print    // character \'a\'    printf(""%c"", ch);         return 0;}', '// C++ Code to explain why// not clearing the input// buffer causes undesired// outputs#include<iostream>#include<vector>using namespace std; int main(){    int a;    char ch[80];         // Enter input from user    // - 4 for example    cin >> a;         // Get input from user -    // ""GeeksforGeeks"" for example    cin.getline(ch,80);         // Prints 4    cout << a << endl;         // Printing string : This does    // not print string    cout << ch << endl;         return 0;}', '// C Code to explain why adding// ""while ( (getchar()) != \'\\n\');""// after ""scanf()"" statement// flushes the input buffer#include<stdio.h> int main(){    char str[80], ch;         // scan input from user -    // GeeksforGeeks for example    scanf(""%s"", str);         // flushes the standard input    // (clears the input buffer)    while ((getchar()) != \'\\n\');         // scan character from user -    // \'a\' for example    ch = getchar();         // Printing character array,    // prints “GeeksforGeeks”)    printf(""%s\\n"", str);         // Printing character a: It    // will print \'a\' this time    printf(""%c"", ch);     return 0;}', '// C++ Code to explain how// ""cin.ignore(numeric_limits// <streamsize>::max(),\'\\n\');""// discards the input buffer#include<iostream> // for <streamsize>#include<ios>     // for numeric_limits#include<limits>using namespace std; int main(){    int a;    char str[80];         // Enter input from user    // - 4 for example    cin >> a;         // discards the input buffer    cin.ignore(numeric_limits<streamsize>::max(),\'\\n\');         // Get input from user -    // GeeksforGeeks for example    cin.getline(str, 80);         // Prints 4    cout << a << endl;         // Printing string : This    // will print string now    cout << str << endl;     return 0;}', '// C++ Code to explain how "" cin.sync();""// discards the input buffer#include<iostream>#include<ios>    #include<limits>using namespace std; int main(){    int a;    char str[80];         // Enter input from user    // - 4 for example    cin >> a;         // Discards the input buffer    cin.sync();         // Get input from user -    // GeeksforGeeks for example    cin.getline(str, 80);         // Prints 4    cout << a << endl;         // Printing string - this    // will print string now    cout << str << endl;     return 0;}', '// C++ Code to explain how ""cin >> ws""// discards the input buffer along with// initial white spaces of string #include<iostream>#include<vector>using namespace std; int main(){    int a;    string s;         // Enter input from user -    // 4 for example    cin >> a;         // Discards the input buffer and    // initial white spaces of string    cin >> ws;         // Get input from user -    // GeeksforGeeks for example    getline(cin, s);         // Prints 4 and GeeksforGeeks :    // will execute print a and s    cout << a << endl;    cout << s << endl;     return 0;}']","['GeeksforGeeks\na', 'GeeksforGeeks', '4\nGeeksforGeeks', '4', 'GeeksforGeeks\na', 'GeeksforGeeks\na', '4\nGeeksforGeeks', '4\nGeeksforGeeks', '4\nGeeksforGeeks', '4', '4\nGeeksforGeeks', '4\nGeeksforGeeks']",[],[]
10,['Operators in C / C++'],[],['Operator Precedence Chart'],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/Operators-In-C.png'],['https://www.youtube.com/embed/WFy9SFJsAWQ?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/operators-in-c-set-2-relational-and-logical-operators/', 'https://www.geeksforgeeks.org/operators-in-c-set-2-relational-and-logical-operators/', 'https://www.geeksforgeeks.org/interesting-facts-bitwise-operators-c/', 'https://www.geeksforgeeks.org/sizeof-operator-c/', 'https://www.geeksforgeeks.org/sizeof-operator-c/', 'https://www.geeksforgeeks.org/comna-in-c-and-c/', 'https://www.geeksforgeeks.org/comna-in-c-and-c/', 'https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/', 'https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['The functionality of the C/C++ programming language is incomplete without the use of operators.', 'C/C++ has many built-in operators and can be classified into 6 types:', 'The above operators have been discussed in detail:\xa0', '1. Arithmetic Operators:\xa0', '2. Relational Operators:', '3. Logical Operators:', '4. Bitwise Operators:\xa0', '5. Assignment Operators:\xa0', '6. Other Operators:\xa0', 'a. sizeof operator:\xa0', 'b. Comma Operator:\xa0', 'c. Conditional Operator:\xa0']","['Operators are the foundation of any programming language. We can define operators as symbols that help us to perform specific mathematical and logical computations on operands. In other words, we can say that an operator operates the operands. For example, ‘+’ is an operator used for addition, as shown below: \xa0', 'Here, ‘+’ is the operator known as the addition operator and ‘a’ and ‘b’ are operands. The addition operator tells the compiler to add both of the operands ‘a’ and ‘b’.\xa0', 'These operators are used to perform arithmetic/mathematical operations on operands. Examples: (+, -, *, /, %,++,–). Arithmetic operators are of two types:\xa0', 'a) Unary Operators: Operators that operate or work with a single operand are unary operators. For example: Increment(++) and Decrement(–) Operators', 'b) Binary Operators: Operators that operate or work with two operands are binary operators. For example: Addition(+), Subtraction(-), multiplication(*), Division(/) operators', 'These are used for the comparison of the values of two operands. For example, checking if one operand is equal to the other operand or not, an operand is greater than the other operand or not, etc. Some of the relational operators are (==, >= , <= )(See this article for more reference).', 'Logical Operators are used to combining two or more conditions/constraints or to complement the evaluation of the original condition in consideration. The result of the operation of a logical operator is a Boolean value either true or false.\xa0', 'For example, the logical AND represented as ‘&&’ operator in C or C++ returns true when both the conditions under consideration are satisfied. Otherwise, it returns false. Therefore, a && b returns true when both a and b are true (i.e. non-zero)(See this article for more reference).', 'Assignment operators are used to assigning value to a variable. The left side operand of the assignment operator is a variable and the right side operand of the assignment operator is a value. The value on the right side must be of the same data type as the variable on the left side otherwise the compiler will raise an error.\xa0', 'Different types of assignment operators are shown below:\xa0a. “=”: This is the simplest assignment operator. This operator is used to assign the value on the right to the variable on the left.\xa0For example:\xa0', 'b. “+=”: This operator is combination of ‘+’ and ‘=’ operators. This operator first adds the current value of the variable on left to the value on the right and then assigns the result to the variable on the left.\xa0For example:', 'c. “-=”: This operator is a combination of ‘-‘ and ‘=’ operators. This operator first subtracts the value on the right from the current value of the variable on left and then assigns the result to the variable on the left.\xa0For example:\xa0', 'd. “*=”: This operator is a combination of ‘*’ and ‘=’ operators. This operator first multiplies the current value of the variable on left to the value on the right and then assigns the result to the variable on the left.\xa0For example:\xa0', 'e. “/=”: This operator is a combination of ‘/’ and ‘=’ operators. This operator first divides the current value of the variable on left by the value on the right and then assigns the result to the variable on the left.\xa0For example:', 'Apart from the above operators, there are some other operators available in C or C++ used to perform some specific tasks. Some of them are discussed here:\xa0', 'The below table describes the precedence order and associativity of operators in C / C++. The precedence of the operator decreases from top to bottom.\xa0\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['The Bitwise operators are used to perform bit-level operations on the operands. The operators are first converted to bit-level and then the calculation is performed on the operands. The mathematical operations such as addition, subtraction, multiplication, etc. can be performed at bit-level for faster processing. For example, the bitwise AND represented as & operator in C or C++ takes two numbers as operands and does AND on every bit of two numbers. The result of AND is 1 only if both bits are 1. (See this article for more reference).']",[],"['c = a + b;', 'int val = 5;\n++val;  // 6', 'int a = 7;\nint b = 2;\ncout<<a+b; // 9', 'int a = 3;\nint b = 5;\na < b;\n// operator to check if a is smaller than b', '(4 != 5) && (4 < 5);     // true', 'int a = 5, b = 9;   // a = 5(00000101), b = 9(00001001)\ncout << (a ^ b);   //  00001100\ncout <<(~a);       // 11111010', ""a = 10;\nb = 20;\nch = 'y';"", '(a += b) can be written as (a = a + b)\nIf initially value stored in a is 5. Then (a += 6) = 11.', '(a -= b) can be written as (a = a - b)\nIf initially value stored in a is 8. Then (a -= 6) = 2.', '(a *= b) can be written as (a = a * b)\nIf initially, the value stored in a is 5. Then (a *= 6) = 30.', '(a /= b) can be written as (a = a / b)\nIf initially, the value stored in a is 6. Then (a /= 2) = 3.']","['1|||()|||Parentheses (function call)|||left-to-right&&&[]|||Brackets (array subscript)|||\xa0&&&.|||Member selection via object name|||\xa0&&&->|||Member selection via a pointer|||\xa0&&&++/–|||Postfix increment/decrement|||\xa0&&&2|||++/–|||Prefix increment/decrement|||right-to-left&&&+/-|||Unary plus/minus|||\xa0&&&!~|||Logical negation/bitwise complement|||\xa0&&&(type)|||Cast (convert value to temporary value of type)|||\xa0&&&*|||Dereference|||\xa0&&&&|||Address (of operand)|||\xa0&&&sizeof|||Determine size in bytes on this implementation|||\xa0&&&3|||*,/,%|||Multiplication/division/modulus|||left-to-right&&&4|||+/-|||Addition/subtraction|||left-to-right&&&5|||<< , >>|||Bitwise shift left, Bitwise shift right|||left-to-right&&&6|||< , <=|||Relational less than/less than or equal to|||left-to-right&&&> , >=|||Relational greater than/greater than or equal to|||left-to-right&&&7|||== , !=|||Relational is equal to/is not equal to|||left-to-right&&&8|||&|||Bitwise AND|||left-to-right&&&9|||^|||Bitwise exclusive OR|||left-to-right&&&10|||||||Bitwise inclusive OR|||left-to-right&&&11|||&&|||Logical AND|||left-to-right&&&12||||||||Logical OR|||left-to-right&&&13|||?:|||Ternary conditional|||right-to-left&&&14|||=|||Assignment|||right-to-left&&&+= , -=|||Addition/subtraction assignment|||\xa0&&&*= , /=|||Multiplication/division assignment|||\xa0&&&%= , &=|||Modulus/bitwise AND assignment|||\xa0&&&^= , |=|||Bitwise exclusive/inclusive OR assignment|||\xa0&&&<>=|||Bitwise shift left/right assignment|||\xa0&&&15|||,|||expression separator|||left-to-right']","['sizeof is much used in the C/C++ programming language.|||It is a compile-time unary operator which can be used to compute the size of its operand.|||The result of sizeof is of the unsigned integral type which is usually denoted by size_t.|||Basically, the sizeof the operator is used to compute the size of the variable.(See this article for reference)&&&The comma operator (represented by the token) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type).|||The comma operator has the lowest precedence of any C operator.|||Comma acts as both operator and separator. (See this article for reference)&&&The conditional operator is of the form Expression1? Expression2: Expression3.|||Here, Expression1 is the condition to be evaluated. If the condition(Expression1) is True then we will execute and return the result of Expression2 otherwise if the condition(Expression1) is false then we will execute and return the result of Expression3.|||We may replace the use of if..else statements with conditional operators. (See this article for reference)&&&&&&Arithmetic Operators|||Relational Operators|||Logical Operators|||Bitwise Operators|||Assignment Operators|||Other Operators&&&']"
11,['Unary operators in C/C++'],[],[],[],[],"['https://www.geeksforgeeks.org/basic/', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Unary operator: are operators that act upon a single operand to produce a new value.', 'Types of unary operators:', 'unary minus is different from subtraction operator, as subtraction requires two operands.', 'C++ program for combination of prefix and postfix operations:', 'The above program shows how the postfix and prefix works.']","['This article is contributed by I. HARISH KUMAR. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// C++ program to demonstrate working of unary increment// and decrement operators#include <iostream>using namespace std;  int main(){    // Post increment    int a = 1;    cout << ""a value: "" << a << endl;    int b = a++;    cout << ""b value after a++ : "" << b << endl;    cout << ""a value after a++ : "" << a << endl;      // Pre increment    a = 1;    cout << ""a value:"" << a << endl;    b = ++a;    cout << ""b value after ++a : "" << b << endl;    cout << ""a value after ++a : ""<< a << endl;      // Post decrement    a = 5;    cout << ""a value before decrement: "" << a << endl;    b = a--;    cout << ""b value after a-- : "" << b << endl;    cout << ""a value after a-- : "" << a << endl;      // Pre decrement    a = 5;    cout << ""a value: ""<< a<<endl;    b = --a;    cout << ""b value after --a : "" << b << endl;    cout << ""a value after --a : "" << a << endl;      return 0;}', '#include <iostream>using namespace std;  int main(){   float n = 0;   cout << ""size of n: "" << sizeof(n);   return 1;}']","['int a = 10;\n int b = -a;  // b = -10', 'int a = 1;\n  int b = ++a;  // b = 2', 'int a = 1;\n int b = a++;   // b = 1\n int c = a;     // c = 2', 'int a = 1;\n  int b = --a;  // b = 0', 'int a = 1;\n int b = a--;   // b = 1\n int c = a;     // c = 0', 'a value: 1\nb value after a++ : 1\na value after a++ : 2\na value:1\nb value after ++a : 2\na value after ++a : 2\na value before decrement: 5\nb value after a-- : 5\na value after a-- : 4\na value: 5\nb value after --a : 4\na value after --a : 4', 'If x is true, then !x is false\n   If x is false, then !x is true', '& gives an address on variable n\nint a;\nint *ptr;\nptr = &a; // address of a is copied to the location ptr.', 'size of n: 4']",[],"['unary minus(-)|||increment(++)|||decrement(- -)|||NOT(!)|||Addressof operator(&)|||sizeof()&&&unary minusThe minus operator changes the sign of its argument. A positive number becomes negative, and a negative number becomes positive. int a = 10;\n int b = -a;  // b = -10\nunary minus is different from subtraction operator, as subtraction requires two operands.|||incrementIt is used to increment the value of the variable by 1. The increment can be done in two ways:prefix incrementIn this method, the operator precedes the operand (e.g., ++a). The value of operand will be altered before it is used.  int a = 1;\n  int b = ++a;  // b = 2\npostfix incrementIn this method, the operator follows the operand (e.g., a++). The value operand will be altered after it is used. int a = 1;\n int b = a++;   // b = 1\n int c = a;     // c = 2\n|||prefix incrementIn this method, the operator precedes the operand (e.g., ++a). The value of operand will be altered before it is used.  int a = 1;\n  int b = ++a;  // b = 2\n|||postfix incrementIn this method, the operator follows the operand (e.g., a++). The value operand will be altered after it is used. int a = 1;\n int b = a++;   // b = 1\n int c = a;     // c = 2\n|||decrementIt is used to decrement the value of the variable by 1. The decrement can be done in two ways:prefix decrementIn this method, the operator precedes the operand (e.g., – -a). The value of operand will be altered before it is used.  int a = 1;\n  int b = --a;  // b = 0\npostfix decrementIn this method, the operator follows the operand (e.g., a- -). The value of operand will be altered after it is used. int a = 1;\n int b = a--;   // b = 1\n int c = a;     // c = 0\nC++ program for combination of prefix and postfix operations:// C++ program to demonstrate working of unary increment// and decrement operators#include <iostream>using namespace std;int main(){// Post incrementint a = 1;cout << ""a value: "" << a << endl;int b = a++;cout << ""b value after a++ : "" << b << endl;cout << ""a value after a++ : "" << a << endl;// Pre incrementa = 1;cout << ""a value:"" << a << endl;b = ++a;cout << ""b value after ++a : "" << b << endl;cout << ""a value after ++a : ""<< a << endl;// Post decrementa = 5;cout << ""a value before decrement: "" << a << endl;b = a--;cout << ""b value after a-- : "" << b << endl;cout << ""a value after a-- : "" << a << endl;// Pre decrementa = 5;cout << ""a value: ""<< a<<endl;b = --a;cout << ""b value after --a : "" << b << endl;cout << ""a value after --a : "" << a << endl;return 0;}Output:a value: 1\nb value after a++ : 1\na value after a++ : 2\na value:1\nb value after ++a : 2\na value after ++a : 2\na value before decrement: 5\nb value after a-- : 5\na value after a-- : 4\na value: 5\nb value after --a : 4\na value after --a : 4\nThe above program shows how the postfix and prefix works.|||prefix decrementIn this method, the operator precedes the operand (e.g., – -a). The value of operand will be altered before it is used.  int a = 1;\n  int b = --a;  // b = 0\n|||postfix decrementIn this method, the operator follows the operand (e.g., a- -). The value of operand will be altered after it is used. int a = 1;\n int b = a--;   // b = 1\n int c = a;     // c = 0\n|||NOT(!): It is used to reverse the logical state of its operand. If a condition is true, then Logical NOT operator will make it false.   If x is true, then !x is false\n   If x is false, then !x is true\n|||Addressof operator(&): It gives an address of a variable. It is used to return the memory address of a variable. These addresses returned by the address-of operator are known as pointers because they “point” to the variable in memory.& gives an address on variable n\nint a;\nint *ptr;\nptr = &a; // address of a is copied to the location ptr. \n|||sizeof(): This operator returns the size of its operand, in bytes. The sizeof operator always precedes its operand.The operand is an expression, or it may be a cast.#include <iostream>using namespace std;int main(){float n = 0;cout << ""size of n: "" << sizeof(n);return 1;}Output:size of n: 4\nThis article is contributed by I. HARISH KUMAR. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.My Personal Notes\narrow_drop_upSave&&&prefix incrementIn this method, the operator precedes the operand (e.g., ++a). The value of operand will be altered before it is used.  int a = 1;\n  int b = ++a;  // b = 2\n|||postfix incrementIn this method, the operator follows the operand (e.g., a++). The value operand will be altered after it is used. int a = 1;\n int b = a++;   // b = 1\n int c = a;     // c = 2\n&&&prefix decrementIn this method, the operator precedes the operand (e.g., – -a). The value of operand will be altered before it is used.  int a = 1;\n  int b = --a;  // b = 0\n|||postfix decrementIn this method, the operator follows the operand (e.g., a- -). The value of operand will be altered after it is used. int a = 1;\n int b = a--;   // b = 1\n int c = a;     // c = 0\n']"
12,['Pre-increment (or pre-decrement) in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['For example, following program prints a = 20 (++a is used as l-value)', 'How ++a is different from a++ as lvalue?', 'That should help to understand why a++ = 20; won’t work.']","['In C++, pre-increment (or pre-decrement) can be used as l-value, but post-increment (or post-decrement) can not be used as l-value.', 'The above program works whereas the following program fails in compilation with error “non-lvalue in assignment” (a++ is used as l-value)', 'It is because ++a returns an lvalue, which is basically a reference to the variable to which we can further assign — just like an ordinary variable. It could also be assigned to a reference as follows:', 'Whereas if you recall how a++ works, it doesn’t immediately increment the value it holds. For brevity, you can think of it as getting incremented in the next statement. So what basically happens is that a++ returns an rvalue, which is basically just a value like the value of an expression which is not stored. You can think of a++ = 20; as follows after being processed:', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// CPP program to illustrate// Pre-increment (or pre-decrement)#include <cstdio>  int main(){    int a = 10;      ++a = 20; // works      printf(""a = %d"", a);    getchar();    return 0;}', '// CPP program to illustrate// Post-increment (or post-decrement)#include <cstdio>  int main(){    int a = 10;    a++ = 20; // error    printf(""a = %d"", a);    getchar();    return 0;}']","['a = 20', ""prog.cpp: In function 'int main()':\nprog.cpp:6:5: error: lvalue required as left operand of assignment\n a++ = 20; // error \n     ^"", 'int &ref = ++a; // valid\nint &ref = a++; // invalid', 'int a = 10;\n\n// On compilation, a++ is replaced by the value of a which is an rvalue:\n10 = 20; // Invalid\n\n// Value of a is incremented\na = a + 1;']",[],[]
13,['new and delete operators in C++ for dynamic memory'],['CPP'],[],['https://media.geeksforgeeks.org/wp-content/uploads/dynamic.png'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/memory-layout-of-c-program/', 'https://www.geeksforgeeks.org/variable-length-arrays-in-c-and-c/', 'https://www.geeksforgeeks.org/data-structures/linked-list/', 'https://www.geeksforgeeks.org/binary-tree-2/', 'https://www.geeksforgeeks.org/what-is-memory-leak-how-can-we-avoid/', 'https://www.geeksforgeeks.org/calloc-versus-malloc/', 'https://aticleworld.com/dynamic-memory-and-new-operator-c/', 'https://www.geeksforgeeks.org/c-plus-plus-gq/new-and-delete-gq/', 'https://www.geeksforgeeks.org/g-fact-30/', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['new operator', 'delete operator', 'Here, pointer-variable is the pointer that points to the data object created by new.\xa0Examples:\xa0\xa0', 'Related Articles:']","['Dynamic memory allocation in C/C++ refers to performing memory allocation manually by programmer. Dynamically allocated memory is allocated on Heap and non-static and local variables get memory allocated on Stack (Refer Memory Layout C Programs for details).What are applications?\xa0\xa0', 'The new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\xa0\xa0', 'Since it is programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator by C++ language.\xa0Syntax:\xa0\xa0', 'To free the dynamically allocated array pointed by pointer-variable, use following form of delete:\xa0\xa0']","['How is it different from memory allocated to normal variables?\xa0For normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is programmers responsibility to deallocate memory when no longer needed. If programmer doesn’t deallocate memory, it causes memory leak (memory is not deallocated until program terminates).\xa0How is memory allocated/deallocated in C++?\xa0C uses malloc() and calloc() function to allocate memory dynamically at run time and uses free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete that perform the task of allocating and freeing the memory in a better and easier way.This article is all about new and delete operators.\xa0\xa0', 'Normal Array Declaration vs Using new\xa0There is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, normal arrays are deallocated by compiler (If array is local, then deallocated when function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by programmer or program terminates.What if enough memory is not available during runtime?\xa0If enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be good idea to check for the pointer variable produced by new before using it program.\xa0\xa0', 'This article is contributed by Akash Gupta. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ program to illustrate dynamic allocation// and deallocation of memory using new and delete#include <iostream>using namespace std; int main (){    // Pointer initialization to null    int* p = NULL;     // Request memory for the variable    // using new operator    p = new(nothrow) int;    if (!p)        cout << ""allocation of memory failed\\n"";    else    {        // Store value at allocated address        *p = 29;        cout << ""Value of p: "" << *p << endl;    }     // Request block of memory    // using new operator    float *r = new float(75.25);     cout << ""Value of r: "" << *r << endl;     // Request block of memory of size n    int n = 5;    int *q = new(nothrow) int[n];     if (!q)        cout << ""allocation of memory failed\\n"";    else    {        for (int i = 0; i < n; i++)            q[i] = i+1;         cout << ""Value store in block of memory: "";        for (int i = 0; i < n; i++)            cout << q[i] << "" "";    }     // freed the allocated memory    delete p;    delete r;     // freed the block of allocated memory    delete[] q;     return 0;}']","['pointer-variable = new data-type;', '// Pointer initialized with NULL\n// Then request memory for the variable\nint *p = NULL; \np = new int;   \n\n            OR\n\n// Combine declaration of pointer \n// and their assignment\nint *p = new int;', ""pointer-variable = new data-type(value);\nExample:\nint *p = new int(25);\nfloat *q = new float(75.25);\n\n// Custom data type\nstruct cust\n{\n    int p;\n    cust(int q) : p(q) {}\n};\n\ncust* var1 = new cust;    // Works fine, doesn't require constructor\n\n        OR\n\ncust* var1 = new cust();        // Works fine, doesn't require constructor\n\n\ncust* var = new cust(25)        // Notice error if you comment this line"", 'pointer-variable = new data-type[size];', 'Example:\n        int *p = new int[10]', 'int *p = new(nothrow) int;\nif (!p)\n{\n   cout << ""Memory allocation failed\\n"";\n}', '// Release memory pointed by pointer-variable\ndelete pointer-variable;', 'delete p;\n  delete q;', '// Release block of memory \n// pointed by pointer-variable\ndelete[] pointer-variable;  \n\nExample:\n   // It will free the entire array\n   // pointed by p.\n   delete[] p;', 'Value of p: 29\nValue of r: 75.25\nValue store in block of memory: 1 2 3 4 5']",[],"['One use of dynamically allocated memory is to allocate memory of variable size which is not possible with compiler allocated memory except variable length arrays.|||The most important use is flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need and whenever we don’t need anymore. There are many cases where this flexibility helps. Examples of such cases are Linked List, Tree, etc.&&&Syntax to use new operator: To allocate memory of any data type, the syntax is:&&&Here, pointer-variable is the pointer of type data-type. Data-type could be any built-in data type including array or any user defined data types including structure and class.Example:&&&Initialize memory: We can also initialize the memory for built-in data types using new operator. For custom data types a constructor is required (with the data-type as input) for initializing the value. Here’s an example for the initialization of both data types :&&&Allocate block of memory: new operator is also used to allocate a block(an array) of memory of type data-type.&&&where size(a variable) specifies the number of elements in an array.&&&Dynamically allocates memory for 10 integers continuously of type int and returns pointer to the first element of the sequence, which is assigned to p(a pointer). p[0] refers to first element, p[1] refers to second element and so on.&&&&&&Quiz on new and delete|||delete vs free']"
14,['Arrays in C/C++'],"['C', 'C', 'C', 'C', 'C++', 'C', 'C++', 'C', 'C', 'C++', 'C++']",[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/05/Arrays.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/Array-Declaration-In-C.png']",['https://www.youtube.com/embed/eOdNhPwOInc?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/difference-pointer-array-c/', 'https://www.geeksforgeeks.org/vector-in-cpp-stl/', 'https://practice.geeksforgeeks.org/courses/ds-in-c??utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_DS_C']","['Note: In above image int a[3]={[0…1]=3}; this kind of declaration has been obsolete since GCC 2.5', 'Array declaration by specifying size\xa0', 'Array declaration by initializing elements', 'Array declaration by specifying size and initializing elements', 'Advantages of an Array in C/C++:\xa0', 'Disadvantages of an Array in C/C++:\xa0', 'Facts about Array in C/C++:\xa0', 'Warnings:\xa0', 'The elements are stored at contiguous memory locations\xa0Example:\xa0', 'Another way to traverse the array', 'To know more about functionalities provided by vector, please refer vector in C++ for more details.']","['Why do we need arrays?\xa0We can use normal variables (v1, v2, v3, ..) when we have a small number of objects, but if we want to store a large number of instances, it becomes difficult to manage them with normal variables. The idea of an array is to represent many instances in one variable.Array declaration in C/C++:\xa0\xa0', 'There are various ways in which we can declare an array. It can be done by specifying its type and size, by initializing it or both.', 'No Index Out of bound Checking:\xa0There is no index out of bounds checking in C/C++, for example, the following program compiles fine but may produce unexpected output when run.\xa0\xa0', 'In C, it is not a compiler error to initialize an array with more elements than the specified size. For example, the below program compiles fine and shows just Warning.']","['An array in C/C++ or be it in any programming language is a collection of similar data items stored at contiguous memory locations and elements can be accessed randomly using indices of an array. \xa0They can be used to store collection of primitive data types such as int, float, double, char, etc of any particular type. To add to it, an array in C/C++ can store derived data types such as the structures, pointers etc. Given below is the picture representation of an array.\xa0', 'Array vs Pointers\xa0Arrays and pointers are two different things (we can check by applying sizeof). The confusion happens because array name indicates the address of first element and arrays are always passed as pointers (even if we use square bracket). Please see Difference between pointer and array in C? for more details.What is vector in C++?\xa0A vector in C++ is a class in STL that represents an array. The advantages of vector over normal arrays are,\xa0']","['// Array declaration by specifying sizeint arr1[10];  // With recent C/C++ versions, we can also// declare an array of user specified sizeint n = 10;int arr2[n];', '// Array declaration by initializing elementsint arr[] = { 10, 20, 30, 40 }  // Compiler creates an array of size 4.// above is same as  ""int arr[4] = {10, 20, 30, 40}""', '// Array declaration by specifying size and initializing// elementsint arr[6] = { 10, 20, 30, 40 }  // Compiler creates an array of size 6, initializes first// 4 elements as specified by user and rest two elements as// 0. above is same as  ""int arr[] = {10, 20, 30, 40, 0, 0}""', '#include <stdio.h>  int main(){    int arr[5];    arr[0] = 5;    arr[2] = -10;    arr[3 / 2] = 2; // this is same as arr[1] = 2    arr[3] = arr[0];      printf(""%d %d %d %d"", arr[0],            arr[1], arr[2], arr[3]);      return 0;}', '#include <iostream>using namespace std;  int main(){    int arr[5];    arr[0] = 5;    arr[2] = -10;      // this is same as arr[1] = 2    arr[3 / 2] = 2;    arr[3] = arr[0];      cout << arr[0] << "" "" << arr[1] << "" "" << arr[2] << "" ""         << arr[3];      return 0;}', '// This C program compiles fine// as index out of bound// is not checked in C.  #include <stdio.h>  int main(){    int arr[2];      printf(""%d "", arr[3]);    printf(""%d "", arr[-2]);      return 0;}', '// This C++ program compiles fine// as index out of bound// is not checked in C.  #include <iostream>using namespace std;  int main(){    int arr[2];      cout << arr[3] << "" "";    cout << arr[-2] << "" "";      return 0;}', '#include <stdio.h>int main(){      // Array declaration by initializing it     // with more elements than specified size.    int arr[2] = { 10, 20, 30, 40, 50 };      return 0;}', '// C program to demonstrate that// array elements are stored// contiguous locations  #include <stdio.h>int main(){    // an array of 10 integers.      // If arr[0] is stored at    // address x, then arr[1] is    // stored at x + sizeof(int)    // arr[2] is stored at x +     // sizeof(int) + sizeof(int)    // and so on.    int arr[5], i;      printf(""Size of integer in this compiler is %lu\\n"",           sizeof(int));      for (i = 0; i < 5; i++)        // The use of \'&\' before a variable name, yields        // address of variable.        printf(""Address arr[%d] is %p\\n"", i, &arr[i]);      return 0;}', '// C++ program to demonstrate that array elements// are stored contiguous locations  #include <iostream>using namespace std;  int main(){    // an array of 10 integers.      // If arr[0] is stored at    // address x, then arr[1] is     // stored at x + sizeof(int)    // arr[2] is stored at x +     // sizeof(int) + sizeof(int)    // and so on.    int arr[5], i;      cout << ""Size of integer in this compiler is ""         << sizeof(int) << ""\\n"";      for (i = 0; i < 5; i++)        // The use of \'&\' before a variable name, yields        // address of variable.        cout << ""Address arr["" << i << ""] is "" << &arr[i]             << ""\\n"";      return 0;}', '#include<bits/stdc++.h>using namespace std;  int main(){    int arr[6]={11,12,13,14,15,16};    // Way 1    for(int i=0;i<6;i++)        cout<<arr[i]<<"" "";      cout<<endl;      // Way 2    cout<<""By Other Method:""<<endl;    for(int i=0;i<6;i++)           cout<<i[arr]<<"" "";        cout<<endl;      return 0;}  // Contributed by Akshay Pawar ( Username - akshaypawar4)']","['5 2 -10 5', '-449684907 4195777', ""prog.c: In function 'main':\nprog.c:7:25: warning: excess elements in array initializer\n  int arr[2] = { 10, 20, 30, 40, 50 };\n                         ^\nprog.c:7:25: note: (near initialization for 'arr')\nprog.c:7:29: warning: excess elements in array initializer\n  int arr[2] = { 10, 20, 30, 40, 50 };\n                             ^\nprog.c:7:29: note: (near initialization for 'arr')\nprog.c:7:33: warning: excess elements in array initializer\n  int arr[2] = { 10, 20, 30, 40, 50 };\n                                 ^\nprog.c:7:33: note: (near initialization for 'arr')"", 'Size of integer in this compiler is 4\nAddress arr[0] is 0x7ffe75c32210\nAddress arr[1] is 0x7ffe75c32214\nAddress arr[2] is 0x7ffe75c32218\nAddress arr[3] is 0x7ffe75c3221c\nAddress arr[4] is 0x7ffe75c32220', '11 12 13 14 15 16 \nBy Other Method:\n11 12 13 14 15 16']",[],"[""Accessing Array Elements:Array elements are accessed by using an integer index. Array index starts with 0 and goes till size of array minus 1.|||Name of the array is also a pointer to the first element of array.&&&Note: The program won’t compile in C++. If we save the above program as a .cpp, the program generates compiler error “error: too many initializers for ‘int [2]'”.&&&We do not need pass size as an extra parameter when we declare a vector i.e, Vectors support dynamic sizes (we do not have to initially specify size of a vector). We can also resize a vector.|||Vectors have many in-built functions like, removing an element, etc.&&&&&&Random access of elements using array index.|||Use of fewer line of code as it creates a single array of multiple elements.|||Easy access to all the elements.|||Traversal through the array becomes easy using a single loop.|||Sorting becomes easy as it can be accomplished by writing fewer line of code.&&&Allows a fixed number of elements to be entered which is decided at the time of declaration. Unlike a linked list, an array in C is not dynamic.|||Insertion and deletion of elements can be costly since the elements are needed to be managed in accordance with the new memory allocation.&&&""]"
15,['Multidimensional Arrays in C / C++'],"['CPP', 'CPP']","['Two-Dimensional Array', 'Three-Dimensional Array']",['https://media.geeksforgeeks.org/wp-content/uploads/two-d.png'],['https://www.youtube.com/embed/eVSbSeJPkDA?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/arrays-in-c-language-set-1-introduction/', 'https://www.facebook.com/harsh.agarwal.16752', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/courses/ds-in-c??utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_DS_C']","['Examples:\xa0\xa0', 'Size of multidimensional arrays', 'Better Method:\xa0\xa0', '?list=PLqM7alHXFySGg6GSRmE2INI4k8fPH5qVB\xa0\xa0']","['Array- Basics\xa0In C/C++, we can define multidimensional arrays in simple words as an array of arrays. Data in multidimensional arrays are stored in tabular form (in row-major order).\xa0The general form of declaring N-dimensional arrays:\xa0\xa0', 'The total number of elements that can be stored in a multidimensional array can be calculated by multiplying the size of all the dimensions.\xa0For example:\xa0The array int x[10][20] can store total (10*20) = 200 elements.\xa0Similarly array int x[5][10][20] can store total (5*10*20) = 1000 elements.\xa0', 'Two – dimensional array is the simplest form of a multidimensional array. We can see a two – dimensional array as an array of one – dimensional array for easier understanding.\xa0\xa0', 'Initializing Two – Dimensional Arrays: There are two ways in which a Two-Dimensional array can be initialized.\xa0First Method:\xa0\xa0', 'The above array has 3 rows and 4 columns. The elements in the braces from left to right are stored in the table also from left to right. The elements will be filled in the array in order, the first 4 elements from the left in the first row, the next 4 elements in the second row, and so on.Better Method:\xa0\xa0', 'This type of initialization makes use of nested braces. Each set of inner braces represents one row. In the above example, there is a total of three rows so there are three sets of inner braces.Accessing Elements of Two-Dimensional Arrays: Elements in Two-Dimensional arrays are accessed using the row indexes and column indexes.\xa0Example:\xa0\xa0', 'The above example represents the element present in the third row and second column.Note: In arrays, if the size of an array is N. Its index will be from 0 to N-1. Therefore, for row index 2 row number is 2+1 = 3.To output all the elements of a Two-Dimensional array we can use nested for loops. We will require two for loops. One to traverse the rows and another to traverse columns.\xa0\xa0', 'Initializing Three-Dimensional Array: Initialization in a Three-Dimensional array is the same as that of Two-dimensional arrays. The difference is as the number of dimensions increases so the number of nested braces will also increase.\xa0Method 1:\xa0\xa0', 'Accessing elements in Three-Dimensional Arrays: Accessing elements in Three-Dimensional Arrays is also similar to that of Two-Dimensional Arrays. The difference is we have to use three loops instead of two loops for one additional dimension in Three-dimensional Arrays.\xa0\xa0', 'In similar ways, we can create arrays with any number of dimensions. However, the complexity also increases as the number of dimensions increases.\xa0The most used multidimensional array is the Two-Dimensional Array.\xa0\xa0', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0\xa0']",[],"['// C++ Program to print the elements of a// Two-Dimensional array#include<iostream>using namespace std; int main(){    // an array with 3 rows and 2 columns.    int x[3][2] = {{0,1}, {2,3}, {4,5}};     // output each array element\'s value    for (int i = 0; i < 3; i++)    {        for (int j = 0; j < 2; j++)        {            cout << ""Element at x["" << i                 << ""]["" << j << ""]: "";            cout << x[i][j]<<endl;        }    }     return 0;}', '// C++ program to print elements of Three-Dimensional// Array#include<iostream>using namespace std; int main(){    // initializing the 3-dimensional array    int x[2][3][2] =    {        { {0,1}, {2,3}, {4,5} },        { {6,7}, {8,9}, {10,11} }    };     // output each element\'s value    for (int i = 0; i < 2; ++i)    {        for (int j = 0; j < 3; ++j)        {            for (int k = 0; k < 2; ++k)            {                cout << ""Element at x["" << i << ""]["" << j                     << ""]["" << k << ""] = "" << x[i][j][k]                     << endl;            }        }    }    return 0;}']","['data_type  array_name[size1][size2]....[sizeN];\n\ndata_type: Type of data to be stored in the array. \n           Here data_type is valid C/C++ data type\narray_name: Name of the array\nsize1, size2,... ,sizeN: Sizes of the dimensions', 'Two dimensional array:\nint two_d[10][20];\n\nThree dimensional array:\nint three_d[10][20][30];', 'data_type array_name[x][y];\ndata_type: Type of data to be stored. Valid C/C++ data type.', 'int x[10][20];', 'int x[3][4] = {0, 1 ,2 ,3 ,4 , 5 , 6 , 7 , 8 , 9 , 10 , 11}', 'int x[3][4] = {{0,1,2,3}, {4,5,6,7}, {8,9,10,11}};', 'int x[2][1];', 'Element at x[0][0]: 0\nElement at x[0][1]: 1\nElement at x[1][0]: 2\nElement at x[1][1]: 3\nElement at x[2][0]: 4\nElement at x[2][1]: 5', 'int x[2][3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \n                 11, 12, 13, 14, 15, 16, 17, 18, 19,\n                 20, 21, 22, 23};', 'int x[2][3][4] = \n { \n   { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} },\n   { {12,13,14,15}, {16,17,18,19}, {20,21,22,23} }\n };', 'Element at x[0][0][0] = 0\nElement at x[0][0][1] = 1\nElement at x[0][1][0] = 2\nElement at x[0][1][1] = 3\nElement at x[0][2][0] = 4\nElement at x[0][2][1] = 5\nElement at x[1][0][0] = 6\nElement at x[1][0][1] = 7\nElement at x[1][1][0] = 8\nElement at x[1][1][1] = 9\nElement at x[1][2][0] = 10\nElement at x[1][2][1] = 11']",[],"['The basic form of declaring a two-dimensional array of size x, y:Syntax:&&&We can declare a two-dimensional integer array say ‘x’ of size 10,20 as:&&&Elements in two-dimensional arrays are commonly referred to by x[i][j] where i is the row number and ‘j’ is the column number.|||A two – dimensional array can be seen as a table with ‘x’ rows and ‘y’ columns where the row number ranges from 0 to (x-1) and column number ranges from 0 to (y-1). A two – dimensional array ‘x’ with 3 rows and 3 columns is shown below:&&&']"
16,['How to print size of array parameter in C++?'],"['CPP', 'CPP', 'CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/using-sizof-operator-with-array-paratmeters/', 'https://www.geeksforgeeks.org/why-c-treats-array-parameters-as-pointers/', 'http://geeksquiz.com/templates-cpp/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['How to compute the size of an array parameter in a function?Consider below C++ program:\xa0', 'We can make a generic function as well:\xa0']","['The above program doesn’t look good as we have a hardcoded size of the array parameter. We can do it better using templates in C++.\xa0', 'Now the next step is to print the size of a dynamically allocated array. It’s your task man! I’m giving you a hint.\xa0', 'This article is contributed by Swarupananda Dhua Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above\xa0']","['The above output is for a machine where the size of an integer is 4 bytes and the size of a pointer is 8 bytes.The cout statement inside main prints 40, and cout in findSize prints 8. The reason is, arrays are always passed pointers in functions, i.e., findSize(int arr[]) and findSize(int *arr) mean exactly same thing. Therefore the cout statement inside findSize() prints the size of a pointer. See this and this for details.How to find the size of an array in function?\xa0We can pass a ‘reference to the array’.\xa0\xa0']","['// A C++ program to show that it is wrong to// compute size of an array parameter in a function#include <iostream>using namespace std; void findSize(int arr[]){    cout << sizeof(arr) << endl;} int main(){    int a[10];    cout << sizeof(a) << "" "";    findSize(a);    return 0;}', '// A C++ program to show that we can use reference to// find size of array#include <iostream>using namespace std; void findSize(int (&arr)[10]){    cout << sizeof(arr) << endl;} int main(){    int a[10];    cout << sizeof(a) << "" "";    findSize(a);    return 0;}', '// A C++ program to show that we use template and// reference to find size of integer array parameter#include <iostream>using namespace std; template <size_t n>void findSize(int (&arr)[n]){    cout << sizeof(int) * n << endl;} int main(){    int a[10];    cout << sizeof(a) << "" "";    findSize(a);    return 0;}', '// A C++ program to show that we use template and// reference to find size of any type array parameter#include <iostream>using namespace std; template <typename T, size_t n>void findSize(T (&arr)[n]){    cout << sizeof(T) * n << endl;} int main(){    int a[10];    cout << sizeof(a) << "" "";    findSize(a);     float f[20];    cout << sizeof(f) << "" "";    findSize(f);    return 0;}', '#include <iostream>#include <cstdlib>using namespace std; int main(){    int *arr = (int*)malloc(sizeof(int) * 20);    return 0;}']","['40 8', '40 40', '40 40', '40 40\n80 80']",[],[]
17,['std::string class in C++'],"['CPP', 'CPP', 'CPP', 'CPP']","['std:: string vs Character Array:', 'Operations on Strings']",[],['https://www.youtube.com/embed/3rDp0yOACZQ?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented/', 'https://www.geeksforgeeks.org/c-string-class-and-its-applications/', 'https://www.geeksforgeeks.org/c-string-class-applications-set-2/', 'https://auth.geeksforgeeks.org/profile.php?user=manjeet_04&list=practice', 'http://www.write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['1) Input Functions:', 'Let’s look at the following example,', '2) Capacity Functions:', 'Let’s look at the following example:', '3) Iterator Functions:', 'Let’s look at the following example:', '4) Manipulating Functions:', 'Let’s look at the following example:', 'Must Read:']",['C++ has in its definition a way to represent a sequence of characters as an object of the class. This class is called std:: string. String class stores the characters as a sequence of bytes with the functionality of allowing access to the single-byte character.\xa0\xa0'],"['This article is contributed by Manjeet Singh. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ Program to demonstrate the working of// getline(), push_back() and pop_back()#include <iostream>#include <string> // for string classusing namespace std; // Driver Codeint main(){    // Declaring string    string str;     // Taking string input using getline()    getline(cin, str);     // Displaying string    cout << ""The initial string is : "";    cout << str << endl;     // Inserting a character    str.push_back(\'s\');     // Displaying string    cout << ""The string after push_back operation is : "";    cout << str << endl;     // Deleting a character    str.pop_back();     // Displaying string    cout << ""The string after pop_back operation is : "";    cout << str << endl;     return 0;}', '// C++ Program to demonstrate the working of// capacity(), resize() and shrink_to_fit()#include <iostream>#include <string> // for string classusing namespace std; // Driver Codeint main(){    // Initializing string    string str = ""geeksforgeeks is for geeks"";     // Displaying string    cout << ""The initial string is : "";    cout << str << endl;     // Resizing string using resize()    str.resize(13);     // Displaying string    cout << ""The string after resize operation is : "";    cout << str << endl;     // Displaying capacity of string    cout << ""The capacity of string is : "";    cout << str.capacity() << endl;     // Displaying length of the string    cout << ""The length of the string is :"" << str.length()         << endl;     // Decreasing the capacity of string    // using shrink_to_fit()    str.shrink_to_fit();     // Displaying string    cout << ""The new capacity after shrinking is : "";    cout << str.capacity() << endl;     return 0;}', '// C++ Program to demonstrate the working of// begin(), end(), rbegin(), rend()#include <iostream>#include <string> // for string classusing namespace std; // Driver Codeint main(){    // Initializing string`    string str = ""geeksforgeeks"";     // Declaring iterator    std::string::iterator it;     // Declaring reverse iterator    std::string::reverse_iterator it1;     // Displaying string    cout << ""The string using forward iterators is : "";    for (it = str.begin(); it != str.end(); it++)        cout << *it;    cout << endl;     // Displaying reverse string    cout << ""The reverse string using reverse iterators is ""            "": "";    for (it1 = str.rbegin(); it1 != str.rend(); it1++)        cout << *it1;    cout << endl;     return 0;}', '// C++ Program to demonstrate the working of// copy() and swap()#include <iostream>#include <string> // for string classusing namespace std; // Driver Codeint main(){    // Initializing 1st string    string str1 = ""geeksforgeeks is for geeks"";     // Declaring 2nd string    string str2 = ""geeksforgeeks rocks"";     // Declaring character array    char ch[80];     // using copy() to copy elements into char array    // copies ""geeksforgeeks""    str1.copy(ch, 13, 0);     // Displaying char array    cout << ""The new copied character array is : "";    cout << ch << endl;     // Displaying strings before swapping    cout << ""The 1st string before swapping is : "";    cout << str1 << endl;    cout << ""The 2nd string before swapping is : "";    cout << str2 << endl;     // using swap() to swap string content    str1.swap(str2);     // Displaying strings after swapping    cout << ""The 1st string after swapping is : "";    cout << str1 << endl;    cout << ""The 2nd string after swapping is : "";    cout << str2 << endl;     return 0;}']","['geeksforgeek', 'The initial string is : geeksforgeek\nThe string after push_back operation is : geeksforgeeks\nThe string after pop_back operation is : geeksforgeek', 'The initial string is : geeksforgeeks is for geeks\nThe string after resize operation is : geeksforgeeks\nThe capacity of string is : 26\nThe length of the string is :13\nThe new capacity after shrinking is : 15', 'The string using forward iterators is : geeksforgeeks\nThe reverse string using reverse iterators is : skeegrofskeeg', 'The new copied character array is : geeksforgeeks\nThe 1st string before swapping is : geeksforgeeks is for geeks\nThe 2nd string before swapping is : geeksforgeeks rocks\nThe 1st string after swapping is : geeksforgeeks rocks\nThe 2nd string after swapping is : geeksforgeeks is for geeks']","['getline()|||This function is used to store a stream of characters as entered by the user in the object memory.&&&push_back()|||This function is used to input a character at the end of the string.&&&pop_back()|||Introduced from C++11(for strings), this function is used to delete the last character from the string.\xa0', 'capacity()|||This function returns the capacity allocated to the string, which can be equal to or more than the size of the string. Additional space is allocated so that when the new characters are added to the string, the operations can be done efficiently.&&&resize()|||This function changes the size of the string, the size can be increased or decreased.&&&length()|||This function finds the length of the string.&&&shrink_to_fit()|||This function decreases the capacity of the string and makes it equal to the minimum capacity of the string. This operation is useful to save additional memory if we are sure that no further addition of characters has to be made.', 'begin()|||This function returns an iterator to the beginning of the string.&&&end()|||This function returns an iterator to the end of the string.&&&rbegin()|||This function returns a reverse iterator pointing at the end of the string.&&&rend()|||This function returns a reverse iterator pointing at beginning of the string.', 'copy(“char array”, len, pos)\xa0|||This function copies the substring in the target character array mentioned in its arguments. It takes 3 arguments, target char array, length to be copied, and starting position in the string to start copying.&&&swap()|||This function swaps one string with other.']","['A character array is simply an array of characters that can be terminated by a null character. A string is a class that defines objects that be represented as a stream of characters.|||The size of the character array has to be allocated statically, more memory cannot be allocated at run time if required. Unused allocated memory is wasted in the case of the character array. In the case of strings, memory is allocated dynamically. More memory can be allocated at run time on demand. As no memory is preallocated, no memory is wasted.|||There is a threat of array decay in the case of the character array. As strings are represented as objects, no array decay occurs.|||Implementation of character array is faster than std:: string. Strings are slower when compared to implementation than character array.|||Character arrays do not offer many inbuilt functions to manipulate strings. String class defines a number of functionalities that allow manifold operations on strings.&&&C++ String Class and its Applications|||C++ String Class and its Applications | Set 2']"
18,['Raw String Literal in C++'],['CPP'],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'http://www.write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Syntax for Raw string Literal:', 'Ordinary String Literal\xa0', 'Raw String Literal\xa0', 'Let’s see an example to see raw string literal in C++:\xa0']","['A raw string literal is a string in which the escape characters like \\n, \\t or \\” \xa0of C++ are not processed. Hence, this was introduced in C++11, a raw string literal which starts with R”( and ends in )”.', 'Here, delimiter is optional and it can be a character except the backslash(/), whitespaces( ), and parentheses( () ).', 'These raw string literals allow a series of characters by writing precisely its contents like raw character sequence. Following is an example of an ordinary string literal and raw string literal:']","['This article is contributed by MAZHAR IMAM KHAN. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ program to demonstrate working of raw string literal#include <iostream>using namespace std; // Driver Codeint main(){    // A Normal string    string string1 = ""Geeks.\\nFor.\\nGeeks.\\n"";     // A Raw string    string string2 = R""(Geeks.\\nFor.\\nGeeks.\\n)"";     cout << string1 << endl;     cout << string2 << endl;     return 0;}']","['R ""delimiter( raw_characters )delimiter""', '""\\\\\\\\n""', 'R""(\\\\n)""', 'Geeks.\nFor.\nGeeks.\n\nGeeks.\\nFor.\\nGeeks.\\n']",[],[]
19,['Array of Strings in C++ (5 Different Ways to Create)'],"['1. Using Pointers:\xa0', 'CPP', '2. Using 2D array:', 'CPP', '3. Using the string class:', 'CPP', '4. Using the vector class:', 'CPP', '5. Using the array class:', 'C++', 'Notes:']",[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://en.cppreference.com/w/cpp/string/basic_string', 'https://en.cppreference.com/w/cpp/container/vector', 'https://en.cppreference.com/w/cpp/container/array', 'https://en.cppreference.com/w/cpp/container', 'https://write.geeksforgeeks.org/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['We create an array of string literals by creating an array of pointers.', 'This is supported by both C and C++.\xa0', 'This is supported in both C and C++.', 'This is supported only in C++, as C does not have classes.', 'The STL container Vector can be used to dynamically allocate an array that can vary in size.', 'This is supported only in C++.']","['In C and C++, a string is a 1-dimensional array of characters and an array of strings in C is a 2-dimensional array of characters. There are many ways to declare them, and a selection of useful ways are given here.', 'This method is useful when the length of all strings is known and a particular memory footprint is desired. Space for strings will be allocated in a single block', 'The STL string class may be used to create an array of mutable strings. In this method, the size of the string is not fixed, and the strings can be changed.\xa0', 'This is only usable in C++, as C does not have classes. Note that the initializer-list syntax here requires a compiler that supports the 2011 C++ standard, and though it is quite likely your compiler does, it is something to be aware of.', 'The STL container array can be used to allocate a fixed-size array. It may be used very similarly to vector, but the size is always fixed.', 'These are by no means the only ways to make a collection of strings. C++ offers several container classes, each of which has various tradeoffs and features, and all of them exist to fill requirements that you will have in your projects. Explore and have fun!\xa0', 'Conclusion: Out of all the methods, Vector seems to be the best way for creating an array of Strings in C++.', 'This article is contributed by Kartik Ahuja. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// C++ program to demonstrate array of strings using// 2D character array#include <iostream> int main(){    // Initialize array of pointer    const char *colour[4] = { ""Blue"", ""Red"",                             ""Orange"", ""Yellow"" };     // Printing Strings stored in 2D array    for (int i = 0; i < 4; i++)        std::cout << colour[i] << ""\\n"";     return 0;}', '// C++ program to demonstrate array of strings using// 2D character array#include <iostream> int main(){    // Initialize 2D array    char colour[4][10] = { ""Blue"", ""Red"", ""Orange"",                           ""Yellow"" };     // Printing Strings stored in 2D array    for (int i = 0; i < 4; i++)        std::cout << colour[i] << ""\\n"";     return 0;}', '// C++ program to demonstrate array of strings using// array of strings.#include <iostream>#include <string> int main(){    // Initialize String Array    std::string colour[4] = { ""Blue"", ""Red"",                              ""Orange"", ""Yellow"" };     // Print Strings    for (int i = 0; i < 4; i++)        std::cout << colour[i] << ""\\n"";}', '// C++ program to demonstrate vector of strings using#include <iostream>#include <vector>#include <string> int main(){    // Declaring Vector of String type    // Values can be added here using initializer-list syntax    std::vector<std::string> colour {""Blue"", ""Red"", ""Orange""};     // Strings can be added at any time with push_back    colour.push_back(""Yellow"");     // Print Strings stored in Vector    for (int i = 0; i < colour.size(); i++)        std::cout << colour[i] << ""\\n"";}', '#include <iostream>#include <array>#include <string> int main(){    // Initialize array    std::array<std::string, 4> colour { ""Blue"", ""Red"", ""Orange"",                                     ""Yellow"" };     // Printing Strings stored in array    for (int i = 0; i < 4; i++)        std::cout << colour[i] << ""\\n"";     return 0;}']","['Blue\nRed\nOrange\nYellow', 'Blue\nRed\nOrange\nYellow', 'Blue\nRed\nOrange\nYellow', 'Blue\nRed\nOrange\nYellow', 'Blue\nRed\nOrange\nYellow']",[],"['The number of strings is fixed, but needn’t be. The 4 may be omitted, and the compiler will compute the correct size.|||These strings are constants and their contents cannot be changed. Because string literals (literally, the quoted strings) exist in a read-only area of memory, we must specify “const” here to prevent unwanted accesses that may crash the program.&&&Both the number of strings and the size of strings are fixed. The 4, again, maybe left out, and the appropriate size will be computed by the compiler. The second dimension, however, must be given (in this case, 10), so that the compiler can choose an appropriate memory layout.|||Each string can be modified but will take up the full space given by the second dimension. Each will be laid out next to each other in memory, and can’t change size.|||Sometimes, control over the memory footprint is desirable, and this will allocate a region of memory with a fixed, regular layout.&&&The array is of fixed size, but needn’t be. Again, the 4 here may be omitted, and the compiler will determine the appropriate size of the array. The strings are also mutable, allowing them to be changed.&&&Vectors are dynamic arrays, and allow you to add and remove items at any time.|||Any type or class may be used in vectors, but a given vector can only hold one type.']"
20,['Tokenizing a string in C++'],"['C++', 'C++', 'C', 'C++', 'C++']","['Using stringstream', 'Using strtok()', 'Using strtok_r()', 'Using std::sregex_token_iterator']",[],[],"['https://www.geeksforgeeks.org/medium/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Below is the C++ implementation :\xa0', 'Below is the C++ implementation :\xa0', 'There are two ways we can call strtok_r()\xa0', 'Below is a simple C++ program to show the use of strtok_r() :\xa0', 'Below is a simple C++ program to show the use of std::sregex_token_iterator:']","['Tokenizing a string denotes splitting a string with respect to some delimiter(s). There are many ways to tokenize a string. In this article four of them are explained:', 'A stringstream associates a string object with a stream allowing you to read from the string as if it were a stream.', 'Just like strtok() function in C, strtok_r() does the same task of parsing a string into a sequence of tokens. strtok_r() is a reentrant version of strtok().', 'In this method the tokenization is done on the basis of regex matches. Better for use cases when multiple delimiters are needed.']",[],"['// Tokenizing a string using stringstream#include <bits/stdc++.h> using namespace std; int main(){         string line = ""GeeksForGeeks is a must try"";         // Vector of string to save tokens    vector <string> tokens;         // stringstream class check1    stringstream check1(line);         string intermediate;         // Tokenizing w.r.t. space \' \'    while(getline(check1, intermediate, \' \'))    {        tokens.push_back(intermediate);    }         // Printing the token vector    for(int i = 0; i < tokens.size(); i++)        cout << tokens[i] << \'\\n\';}', '// C/C++ program for splitting a string// using strtok()#include <stdio.h>#include <string.h> int main(){    char str[] = ""Geeks-for-Geeks"";     // Returns first token    char *token = strtok(str, ""-"");     // Keep printing tokens while one of the    // delimiters present in str[].    while (token != NULL)    {        printf(""%s\\n"", token);        token = strtok(NULL, ""-"");    }     return 0;}', '// C code to demonstrate working of// strtok#include <string.h>#include <stdio.h> // Driver functionint main(){ // Declaration of string    char gfg[100] = "" Geeks - for - geeks - Contribute"";     // Declaration of delimiter    const char s[4] = ""-"";    char* tok;     // Use of strtok    // get first token    tok = strtok(gfg, s);     // Checks for delimiter    while (tok != 0) {        printf("" %s\\n"", tok);         // Use of strtok        // go through other tokens        tok = strtok(0, s);    }     return (0);}', '// C/C++ program to demonstrate working of strtok_r()// by splitting string based on space character.#include<stdio.h>#include<string.h> int main(){    char str[] = ""Geeks for Geeks"";    char *token;    char *rest = str;     while ((token = strtok_r(rest, "" "", &rest)))        printf(""%s\\n"", token);     return(0);}', '// CPP program for above approach#include <iostream>#include <regex>#include <string>#include <vector> /** * @brief Tokenize the given vector   according to the regex * and remove the empty tokens. * * @param str * @param re * @return std::vector<std::string> */std::vector<std::string> tokenize(                     const std::string str,                          const std::regex re){    std::sregex_token_iterator it{ str.begin(),                             str.end(), re, -1 };    std::vector<std::string> tokenized{ it, {} };     // Additional check to remove empty strings    tokenized.erase(        std::remove_if(tokenized.begin(),                            tokenized.end(),                       [](std::string const& s) {                           return s.size() == 0;                       }),        tokenized.end());     return tokenized;} // Driver Codeint main(){    const std::string str = ""Break string                   a,spaces,and,commas"";    const std::regex re(R""([\\s|,]+)"");       // Function Call    const std::vector<std::string> tokenized =                           tokenize(str, re);       for (std::string token : tokenized)        std::cout << token << std::endl;    return 0;}']","['GeeksForGeeks\nis\na\nmust\ntry', '// Splits str[] according to given delimiters.\n// and returns next token. It needs to be called\n// in a loop to get all tokens. It returns NULL\n// when there are no more tokens.\nchar * strtok(char str[], const char *delims);', 'Geeks\nfor\nGeeks', 'Geeks \n  for \n  geeks \n  Contribute', '// The third argument saveptr is a pointer to a char * \n// variable that is used internally by strtok_r() in \n// order to maintain context between successive calls\n// that parse the same string.\nchar *strtok_r(char *str, const char *delim, char **saveptr);', 'Geeks\nfor\nGeeks', 'Break\nstring\na\nspaces\nand\ncommas']",[],[]
21,['strrchr() function in C/C++'],"['CPP', 'C', 'C']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://ide.geeksforgeeks.org/', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['C Examples :\xa0\xa0'],"['Here, str is the string and c is the character to be located. It is passed as its int promotion, but it is internally converted back to char.\xa0Application\xa0Given a string in C++, we need to find the last occurrence of a character, let’s say ‘a’.Examples:\xa0\xa0', 'Algorithm\xa01. Pass the given string in the strchr() function and mention the character you need to point to.\xa02. The function returns a value, print the value.\xa0', 'Practical Application: Since it returns the entire string after the last occurrence of a particular character, it can be used to extract the suffix of a string. For e.g to know the entire leading zeroes in a denomination when we know the first number. This example is demonstrated below.\xa0']","['strrchr() function\xa0In C++, strrchr() is a predefined function used for string handling. cstring is the header file required for string functions.This function returns a pointer to the last occurrence of a character in a string.\xa0The character whose last occurrence we want to find is passed as the second argument to the function and the string in which we have to find the character is passed as the first argument to the function.\xa0Syntax\xa0\xa0', 'This article is contributed by Ayush Saxena and Vaishnavi Tripathi. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ program to demonstrate working strchr()#include <iostream>#include <cstring>using namespace std; int main(){  char str[] = ""This is a string"";  char * ch = strrchr(str,\'a\');  cout << ch - str + 1;  return 0;}', '// C code to demonstrate the working of// strrchr() #include <stdio.h>#include <string.h> // Driver functionint main(){     // initializing variables    char st[] = ""GeeksforGeeks"";    char ch = \'e\';    char* val;     // Use of strrchr()    // returns ""ks""    val = strrchr(st, ch);     printf(""String after last %c is :  %s \\n"", ch, val);     char ch2 = \'m\';     // Use of strrchr()    // returns null    // test for null    val = strrchr(st, ch2);     printf(""String after last %c is :  %s "", ch2, val);     return (0);}', '// C code to demonstrate the application of// strrchr() #include <stdio.h>#include <string.h> // Driver functionint main(){     // initializing the denomination    char denom[] = ""Rs 10000000"";     // Printing original string    printf(""The original string is : %s"", denom);     // initializing the initial number    char first = \'1\';    char* entire;     // Use of strrchr()    // returns entire number    entire = strrchr(denom, first);     printf(""\\nThe denomination value is : %s "", entire);     return (0);}']","['char *strrchr(const char *str, int c)', ""Input : string = 'This is a string'\nOutput :9\n\nInput :string = 'My name is Ayush'\nOutput :12"", '9', 'String after last e is :  eks \nString after last m is :  (null)', 'The original string is : Rs 10000000\nThe denomination value is : 10000000']",[],[]
22,['stringstream in C++ and its applications'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/removing-spaces-string-using-stringstream/', 'https://www.geeksforgeeks.org/converting-strings-numbers-cc/', 'http://www.contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Basic methods are –', 'stringstream class is extremely useful in parsing input.', 'Applications :']","['A stringstream associates a string object with a stream allowing you to read from the string as if it were a stream (like cin).', 'clear() — to clear the streamstr() — to get and set string object whose content is present in stream.operator << — add a string to the stringstream object.operator >> — read something from the stringstream object,', 'This article is contributed by ASIPU PAWAN KUMAR. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// CPP program to count words in a string// using stringstream.#include <bits/stdc++.h>using namespace std;  int countWords(string str){    // breaking input into word using string stream    stringstream s(str); // Used for breaking words    string word; // to store individual words      int count = 0;    while (s >> word)        count++;    return count;}  // Driver codeint main(){    string s = ""geeks for geeks geeks ""               ""contribution placements"";    cout << "" Number of words are: "" << countWords(s);    return 0;}', '// CPP program to demonstrate use of stringstream// to count frequencies of words.#include <bits/stdc++.h>using namespace std;  void printFrequency(string st){    // each word it mapped to it\'s frequency    map<string, int> FW;    stringstream ss(st); // Used for breaking words    string Word; // To store individual words      while (ss >> Word)        FW[Word]++;      map<string, int>::iterator m;    for (m = FW.begin(); m != FW.end(); m++)        cout << m->first << "" -> ""             << m->second << ""\\n"";}  // Driver codeint main(){    string s = ""Geeks For Geeks Ide"";    printFrequency(s);    return 0;}']","['Examples:\nInput : Asipu Pawan Kumar\nOutput : 3\n\nInput : Geeks For Geeks Ide\nOutput : 4', 'Number of words are: 6', 'Input : Geeks For Geeks Quiz Geeks Quiz Practice Practice\nOutput : For -> 1\n         Geeks -> 3\n         Practice -> 2\n         Quiz -> 2\n\nInput : Word String Frequency String\nOutput : Frequency -> 1\n         String -> 2\n         Word -> 1', 'For -> 1\nGeeks -> 2\nIde -> 1']",[],"['Count number of words in a stringExamples:\nInput : Asipu Pawan Kumar\nOutput : 3\n\nInput : Geeks For Geeks Ide\nOutput : 4// CPP program to count words in a string// using stringstream.#include <bits/stdc++.h>using namespace std;int countWords(string str){// breaking input into word using string streamstringstream s(str); // Used for breaking wordsstring word; // to store individual wordsint count = 0;while (s >> word)count++;return count;}// Driver codeint main(){string s = ""geeks for geeks geeks """"contribution placements"";cout << "" Number of words are: "" << countWords(s);return 0;}Output:  Number of words are: 6|||Print frequencies of individual words in a stringInput : Geeks For Geeks Quiz Geeks Quiz Practice Practice\nOutput : For -> 1\n         Geeks -> 3\n         Practice -> 2\n         Quiz -> 2\n\nInput : Word String Frequency String\nOutput : Frequency -> 1\n         String -> 2\n         Word -> 1 \n// CPP program to demonstrate use of stringstream// to count frequencies of words.#include <bits/stdc++.h>using namespace std;void printFrequency(string st){// each word it mapped to it\'s frequencymap<string, int> FW;stringstream ss(st); // Used for breaking wordsstring Word; // To store individual wordswhile (ss >> Word)FW[Word]++;map<string, int>::iterator m;for (m = FW.begin(); m != FW.end(); m++)cout << m->first << "" -> ""<< m->second << ""\\n"";}// Driver codeint main(){string s = ""Geeks For Geeks Ide"";printFrequency(s);return 0;}Output:For -> 1\nGeeks -> 2\nIde -> 1\n|||Removing spaces from a string using Stringstream|||Converting Strings to Numbers in C/C++']"
23,['Functions in C/C++'],"['C', 'C++', 'C', 'C++', 'C', 'C++']",[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/Function-Prototype-in-c.png'],['https://www.youtube.com/embed/dfpCveipYRQ?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/', 'https://www.geeksforgeeks.org/g-fact-95/', 'https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/', 'https://www.geeksforgeeks.org/c-language-2-gq/functions-gq/', 'https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/', 'https://www.geeksforgeeks.org/functions-that-are-executed-before-and-after-main-in-c/', 'https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/', 'https://www.geeksforgeeks.org/how-to-count-variable-numbers-of-arguments-in-c/', 'https://www.geeksforgeeks.org/g-fact-20/', 'https://www.geeksforgeeks.org/does-c-support-function-overloading/', 'https://www.geeksforgeeks.org/how-can-i-return-multiple-values-from-a-function/', 'https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/', 'https://www.geeksforgeeks.org/what-are-static-functions-in-c/', 'https://www.geeksforgeeks.org/understanding-exit-abort-and-assert/', 'https://www.geeksforgeeks.org/implicit-return-type-int-c-language/', 'https://www.geeksforgeeks.org/g-fact-95/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['The general form of a function is:', '\xa0Example:Below is a simple C/C++ program to demonstrate functions.', 'Why do we need functions?', 'Types of main Function:', '1) The first type is – main function without parameters :', '2) Second type is main function with parameters :']","['A function is a set of statements that take inputs, do some specific computation and produces output.', 'The idea is to put some commonly or repeatedly done task together and make a function so that instead of writing the same code again and again for different inputs, we can call the function.', 'It is always recommended to declare a function before it is used (See this, this and this for details)', 'In C, we can do both declaration and definition at the same place, like done in the above example program.', 'C also allows to declare and define functions separately, this is especially needed in the case of library functions. The library functions are declared in header files and defined in library files. Below is an example declaration.', '\xa0Parameter Passing to functionsThe parameters passed to function are called actual parameters. For example, in the above program 10 and 20 are actual parameters.The parameters received by function are called formal parameters. For example, in the above program x and y are formal parameters.There are two most popular ways to pass parameters.', 'Pass by Value: In this parameter passing method, values of actual parameters are copied to function’s formal parameters and the two types of parameters are stored in different memory locations. So any changes made inside functions are not reflected in actual parameters of caller.', 'Pass by Reference Both actual and formal parameters refer to same locations, so any changes made inside the function are actually reflected in actual parameters of caller.', 'Parameters are always passed by value in C. For example. in the below code, value of x is not modified using the function fun().', '\xa0Following are some important points about functions in C.1) Every C program has a function called main() that is called by operating system when a user runs the program.', 'Main Function:The main function is a special function. Every C++ program must contain a function named main. It serves as the entry point for the program. The computer will start running the code from the beginning of the main function.', 'The reason for having the parameter option for the main function is to allow input from the command line.', 'When you use the main function with parameters, it saves every group of characters (separated by a space) after the program name as elements in an array named argv.', 'Since the main function has the return type of int, the programmer must always have a return statement in the code. The number that is returned is used to inform the calling program what the result of the program’s execution was. Returning 0 signals that there were no problems.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']","['Function DeclarationA function declaration tells the compiler about the number of parameters function takes, data-types of parameters, and return type of function. Putting parameter names in function declaration is optional in the function declaration, but it is necessary to put them in the definition. Below are an example of function declarations. (parameter names are not there in below declarations)', 'However, in C, we can use pointers to get the effect of pass-by reference. For example, consider the below program. The function fun() expects a pointer ptr to an integer (or an address of an integer). It modifies the value at the address ptr. The dereference operator * is used to access the value at an address. In the statement ‘*ptr = 30’, value at address ptr is changed to 30. The address operator & is used to get the address of a variable of any data type. In the function call statement ‘fun(&x)’, the address of x is passed so that x can be modified using its address.', '2) Every function has a return type. If a function doesn’t return any value, then void is used as a return type. Moreover, if the return type of the function is void, we still can use return statement in the body of function definition by not specifying any constant, variable, etc. with it, by only mentioning the ‘return;’ statement which would symbolize the termination of the function as shown below:', '3) In C, functions can return any type except arrays and functions. We can get around this limitation by returning pointer to array or pointer to function.4) Empty parameter list in C means that the parameter list is not specified and function can be called with any parameters. In C, it is not a good idea to declare a function like fun(). To declare a function that can only be called without any parameter, we should use “void fun(void)”.As a side note, in C++, an empty list means a function can only be called without any parameter. In C++, both void fun() and void fun(void) are same.5)If in a C program, a function is called before its declaration then the C compiler automatically assumes the declaration of that function in the following way:int function name();And in that case, if the return type of that function is different than INT, compiler would show an error.']","['return_type function_name([ arg1_type arg1_name, ... ]) { code }', '#include <stdio.h>  // An example function that takes two parameters \'x\' and \'y\'// as input and returns max of two input numbersint max(int x, int y){    if (x > y)      return x;    else      return y;}  // main function that doesn\'t receive any parameter and// returns integer.int main(void){    int a = 10, b = 20;      // Calling above function to find max of \'a\' and \'b\'    int m = max(a, b);      printf(""m is %d"", m);    return 0;}', '#include <iostream>using namespace std;  int max(int x, int y) {     if (x > y)     return x;     else    return y; }   int main() {    int a = 10, b = 20;       // Calling above function to find max of \'a\' and \'b\'     int m = max(a, b);       cout << ""m is "" << m;     return 0; }', '// A function that takes two integers as parameters// and returns an integerint max(int, int);  // A function that takes an int pointer and an int variable as parameters// and returns a pointer of type intint *swap(int*,int);  // A function that takes a charas parameters// and returns an reference variablechar *call(char b);  // A function that takes a char and an int as parameters// and returns an integerint fun(char, int);', '#include <stdio.h>void fun(int x){   x = 30;}  int main(void){    int x = 20;    fun(x);    printf(""x = %d"", x);    return 0;}', '#include <iostream>using namespace std;  void fun(int x) {    x = 30;}  int main() {    int x = 20;    fun(x);    cout << ""x = "" << x;    return 0;}', '# include <stdio.h>void fun(int *ptr){    *ptr = 30;}   int main(){  int x = 20;  fun(&x);  printf(""x = %d"", x);     return 0;}', '#include <iostream>using namespace std;  void fun(int *ptr){    *ptr = 30;}  int main() {    int x = 20;    fun(&x);    cout << ""x = "" << x;          return 0;}', 'void function name(int a){.......  //Function Bodyreturn;  //Function execution would get terminated}', '// Without Parametersint main(){   ...   return 0;}', '// With Parametersint main(int argc, char * const argv[]){   ...   return 0;}']","['m is 20', 'x = 20', 'x = 30']",[],"['Functions help us in reducing code redundancy. If functionality is performed at multiple places in software, then rather than writing the same code, again and again, we create a function and call it everywhere. This also helps in maintenance as we have to change at one place if we make future changes to the functionality.|||Functions make code modular. Consider a big file having many lines of code. It becomes really simple to read and use the code if the code is divided into functions.|||Functions provide abstraction. For example, we can use library functions without worrying about their internal working.&&&Quiz on function in C|||Importance of function prototype in C|||Functions that are executed before and after main() in C|||return statement vs exit() in main()|||How to Count Variable Numbers of Arguments in C?,|||What is evaluation order of function parameters in C?|||Does C support function overloading?|||How can we return multiple values from a function?|||What is the purpose of a function prototype?|||Static functions in C|||exit(), abort() and assert()|||Implicit return type int in C|||What happens when a function is called before its declaration in C?']"
24,['Default Arguments in C++'],"['CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/basic/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Key Points:\xa0\xa0', 'Advantages of Default Arguments:', 'Disadvantages of Default Arguments:']","['A default argument is a value provided in a function declaration that is automatically assigned by the compiler if the caller of the function doesn’t provide a value for the argument with a default value. In case any value is passed the default value is overridden.', '1) Following is a simple C++ example to demonstrate the use of default arguments. Here, we don’t have to write 3 sum functions, only one function works by using default values for 3rd and 4th arguments.\xa0', 'Explanation: In statement 1, only two values are passed, hence the variables z and w take the default values as 0. In statement 2, three values are passed, so the value of z is over-ridden with 25. In statement 3, four values are passed, so the value of z and w are over-ridden with 25 and 30 respectively.', '2) When Function overloading is done along with default values. Then we need to make sure it will not be ambiguous.\xa0The compiler will throw an error, if ambiguous. Following is the modified version of above program,']",[],"['// CPP Program to demonstrate Default Arguments#include <iostream>using namespace std; // A function with default arguments,// it can be called with// 2 arguments or 3 arguments or 4 arguments.int sum(int x, int y, int z = 0, int w = 0){    return (x + y + z + w);} // Driver Codeint main(){    // Statement 1    cout << sum(10, 15) << endl;       // Statement 2    cout << sum(10, 15, 25) << endl;       // Statement 3    cout << sum(10, 15, 25, 30) << endl;    return 0;}', '// CPP Program to demonstrate Function overloading in// Default Arguments#include <iostream>using namespace std; // A function with default arguments, it can be called with// 2 arguments or 3 arguments or 4 arguments.int sum(int x, int y, int z = 0, int w = 0){    return (x + y + z + w);}int sum(int x, int y, float z = 0, float w = 0){    return (x + y + z + w);}// Driver Codeint main(){    cout << sum(10, 15) << endl;    cout << sum(10, 15, 25) << endl;    cout << sum(10, 15, 25, 30) << endl;    return 0;}']","['25\n50\n80', ""prog.cpp: In function 'int main()':\nprog.cpp:17:20: error: call of overloaded \n'sum(int, int)' is ambiguous\n  cout << sum(10, 15) << endl; \n                    ^\nprog.cpp:6:5: note: candidate: \nint sum(int, int, int, int)\n int sum(int x, int y, int z=0, int w=0) \n     ^\nprog.cpp:10:5: note: candidate: \nint sum(int, int, float, float)\n int sum(int x, int y, float z=0, float w=0) \n     ^"", ""// Invalid because z has default value, but w after it doesn't have a default value\nint sum(int x, int y, int z = 0, int w).""]",[],"['Default arguments are different from constant arguments as constant arguments can’t be changed whereas default arguments can be overwritten if required.|||Default arguments are overwritten when calling function provides values for them. For example, calling of function sum(10, 15, 25, 30) overwrites the value of z and w to 25 and 30 respectively.|||During the calling of function, arguments from calling function to called function are copied from left to right. Therefore, sum(10, 15, 25) will assign 10, 15, and 25 to x, y, and z. Therefore, the default value is used for w only.|||Once the default value is used for an argument in the function definition, all subsequent arguments to it must have a default value. It can also be stated as default arguments are assigned from right to left. For example, the following function definition is invalid as the subsequent argument of default variable z is not default.&&&Default arguments are useful when we want to increase the capabilities of an existing function by adding another default arguments.|||It helps in reducing the size of program.|||Default arguments improves consistency of program.&&&It increase the execution time as compiler need to replace the omitted arguments by there default values in the function call.']"
25,['Inline Functions in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'http://www.flipkart.com/effective-c-55-specific-ways-improve-your-programs-designs-3rd/p/itmczzfe2gfvfuch?pid=9788131714805&affid=sandeepgfg', 'http://www.parashift.com/c++-faq/inline-and-perf.html', 'http://www.cplusplus.com/forum/articles/20600/', 'http://www.flipkart.com/thinking-c-volume-1-with-cd/p/itmdwuafcz75hzjy?pid=9788131706619&affid=sandeepgfg', 'http://www.flipkart.com/c-complete-reference/p/itmdwxz7nyaxabtj?pid=9780070532465&affid=sandeepgfg', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']","['The following program demonstrates the use of use of inline function.', 'The following program demonstrates this concept:']","['Inline function is one of the important feature of C++. So, let’s first understand why inline functions are used and what is the purpose of inline function?', '2) If you use too many inline functions then the size of the binary executable file will be large, because of the duplication of same code.', '3) Too much inlining can also reduce your instruction cache hit rate, thus reducing the speed of instruction fetch from that of cache memory to that of primary memory.', '4) Inline function may increase compile time overhead if someone changes the code inside the inline function then all the calling location has to be recompiled because compiler would require to replace all the code once again to reflect the changes, otherwise it will continue with old functionality.', '5) Inline functions may not be useful for many embedded systems. Because in embedded systems code size is more important than speed.', '6) Inline functions might cause thrashing because inlining might increase size of the binary executable file. Thrashing in memory causes performance of computer to degrade.', 'The above style is considered as a bad programming style. The best programming style is to just write the prototype of function inside the class and specify it as an inline in the function definition.For example:', 'C++ compiler checks the argument types of inline functions and necessary conversions are performed correctly. Preprocessor macro is not capable for doing this. One other thing is that the macros are managed by preprocessor and inline functions are managed by C++ compiler.', 'One other thing to remember is that it is only useful to make the function inline if the time spent during a function call is more compared to the function body execution time. An example where inline function has no effect at all:', 'The above function relatively takes a long time to execute. In general function which performs input output (I/O) operation shouldn’t be defined as inline because it spends a considerable amount of time. Technically inlining of show() function is of limited value because the amount of time the I/O statement will take far exceeds the overhead of a function call.', 'Last thing to keep in mind that inline functions are the valuable feature of C++. An appropriate use of inline function can provide performance enhancement but if inline functions are used arbitrarily then they can’t provide better result. In other words don’t expect better performance of program. Don’t make every function inline. It is better to keep inline functions as small as possible.', 'References:1) Effective C++ , Scott Meyers2) http://www.parashift.com/c++-faq/inline-and-perf.html3) http://www.cplusplus.com/forum/articles/20600/4) Thinking in C++, Volume 1, Bruce Eckel.5) C++ the complete reference, Herbert Schildt', 'This article is contributed by Meet Pravasi. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['When the program executes the function call instruction the CPU stores the memory address of the instruction following the function call, copies the arguments of the function on the stack and finally transfers control to the specified function. The CPU then executes the function code, stores the function return value in a predefined memory location/register and returns control to the calling function. This can become overhead if the execution time of function is less than the switching time from the caller function to called function (callee). For functions that are large and/or perform complex tasks, the overhead of the function call is usually insignificant compared to the amount of time the function takes to run. However, for small, commonly-used functions, the time needed to make the function call is often a lot more than the time needed to actually execute the function’s code. This overhead occurs for small functions because execution time of small function is less than the switching time.', 'C++ provides an inline functions to reduce the function call overhead. Inline function is a function that is expanded in line when it is called. When the inline function is called whole code of the inline function gets inserted or substituted at the point of inline function call. This substitution is performed by the C++ compiler at compile time. Inline function may increase efficiency if it is small.The syntax for defining the function inline is:', 'Remember, inlining is only a request to the compiler, not a command. Compiler can ignore the request for inlining. Compiler may not perform inlining in such circumstances like:1) If a function contains a loop. (for, while, do-while)2) If a function contains static variables.3) If a function is recursive.4) If a function return type is other than void, and the return statement doesn’t exist in function body.5) If a function contains switch or goto statement.', 'Inline functions provide following advantages:1) Function call overhead doesn’t occur.2) It also saves the overhead of push/pop variables on the stack when function is called.3) It also saves overhead of a return call from a function.4) When you inline a function, you may enable compiler to perform context specific optimization on the body of function. Such optimizations are not possible for normal function calls. Other optimizations can be obtained by considering the flows of calling context and the called context.5) Inline function may be useful (if it is small) for embedded systems because inline can yield less code than the function call preamble and return.', 'Inline function disadvantages:1) The added variables from the inlined function consumes additional registers, After in-lining function if variables number which are going to use register increases than they may create overhead on register variable resource utilization. This means that when inline function body is substituted at the point of function call, total number of variables used by the function also gets inserted. So the number of register going to be used for the variables will also get increased. So if after function inlining variable numbers increase drastically then it would surely cause an overhead on register utilization.', 'Inline function and classes:It is also possible to define the inline function inside the class. In fact, all the functions defined inside the class are implicitly inline. Thus, all the restrictions of inline functions are also applied here. If you need to explicitly declare inline function in the class then just declare the function inside the class and define it outside the class using inline keyword.For example:', 'What is wrong with macro?Readers familiar with the C language knows that C language uses macro. The preprocessor replace all macro calls directly within the macro code. It is recommended to always use inline function instead of macro. According to Dr. Bjarne Stroustrup the creator of C++ that macros are almost never necessary in C++ and they are error prone. There are some problems with the use of macros in C++. Macro cannot access private members of class. Macros looks like function call but they are actually not.Example:', 'Remember: It is true that all the functions defined inside the class are implicitly inline and C++ compiler will perform inline call of these functions, but C++ compiler cannot perform inlining if the function is virtual. The reason is call to a virtual function is resolved at runtime instead of compile time. Virtual means wait until runtime and inline means during compilation, if the compiler doesn’t know which function will be called, how it can perform inlining?', 'Depending upon the compiler you are using the compiler may show you warning if the function is not expanded inline. Programming languages like Java & C# doesn’t support inline functions.But in Java, the compiler can perform inlining when the small final method is called, because final methods can’t be overridden by sub classes and call to a final method is resolved at compile time. In C# JIT compiler can also optimize code by inlining small function calls (like replacing body of a small function when it is called in a loop).']","['#include <iostream>using namespace std;inline int cube(int s){    return s*s*s;}int main(){    cout << ""The cube of 3 is: "" << cube(3) << ""\\n"";    return 0;} //Output: The cube of 3 is: 27', 'class S{public:    inline int square(int s) // redundant use of inline    {        // this function is automatically inline        // function body    }};', 'class S{public:    int square(int s); // declare the function};  inline int S::square(int s) // use inline prefix{  }', '#include <iostream>using namespace std;class operation{    int a,b,add,sub,mul;    float div;public:    void get();    void sum();    void difference();    void product();    void division();};inline void operation :: get(){    cout << ""Enter first value:"";    cin >> a;    cout << ""Enter second value:"";    cin >> b;}  inline void operation :: sum(){    add = a+b;    cout << ""Addition of two numbers: "" << a+b << ""\\n"";}  inline void operation :: difference(){    sub = a-b;    cout << ""Difference of two numbers: "" << a-b << ""\\n"";}  inline void operation :: product(){    mul = a*b;    cout << ""Product of two numbers: "" << a*b << ""\\n"";}  inline void operation ::division(){    div=a/b;    cout<<""Division of two numbers: ""<<a/b<<""\\n"" ;}  int main(){    cout << ""Program using inline function\\n"";    operation s;    s.get();    s.sum();    s.difference();    s.product();    s.division();    return 0;}', '#include <iostream>using namespace std;class S{    int m;public:#define MAC(S::m)    // error};', 'inline void show(){    cout << ""value of S = "" << S << endl;}']","['inline return-type function-name(parameters)\n{\n    // function code\n}', 'Enter first value: 45\nEnter second value: 15\nAddition of two numbers: 60\nDifference of two numbers: 30\nProduct of two numbers: 675\nDivision of two numbers: 3']",[],[]
26,['Return From Void Functions in C++'],"['CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/easy/', 'http://www.write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']",[],"['2) A void fun() can return another void function:\xa0A void function can also call another void function while it is terminating. For example,\xa0', 'The above code explains how void() can actually be useful to return void functions without giving errors.\xa03) A void() can return a void value: A void() cannot return a value that can be used. But it can return a value that is void without giving an error. For example,']","['Void functions are known as Non-Value Returning functions. They are “void” due to the fact that they are not supposed to return values. True, but not completely. We cannot return values but there is something we can surely return from void functions. Void functions do not have a return type, but they can do return values. Some of the cases are listed below:\xa01) A Void Function Can Return: We can simply write a return statement in a void fun(). In fact, it is considered a good practice (for readability of code) to write a return; statement to indicate the end of the function.\xa0', 'This article is contributed by Manjeet Singh. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['// CPP Program to demonstrate void functions#include <iostream>using namespace std;  void fun(){    cout << ""Hello"";      // We can write return in void    return;}  // Driver Codeint main(){    fun();    return 0;}', '// C++ code to demonstrate void()// returning void()#include <iostream>using namespace std;  // A sample void functionvoid work(){    cout << ""The void function has returned ""            "" a void() !!! \\n"";}  // Driver void() returning void work()void test(){    // Returning void function    return work();}  // Driver Codeint main(){    // Calling void function    test();    return 0;}', '// C++ code to demonstrate void()// returning a void value#include <iostream>using namespace std;  // Driver void() returning a void valuevoid test(){    cout << ""Hello"";      // Returning a void value    return (void)""Doesn\'t Print"";}  // Driver Codeint main(){    test();    return 0;}']","['Hello', 'The void function has returned  a void() !!!', 'Hello']",[],[]
27,['Functors in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/transform-c-stl-perform-operation-elements/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Please note that the title is Functors (Not Functions)!!', 'Below program uses transform() in STL to add 1 to all elements of arr[].', 'Let’s delve deeper and understand how this can actually be used in conjunction with STLs.', 'Thus, here, Increment is a functor, a c++ class that acts as a function.']","['Consider a function that takes only one argument. However, while calling this function we have a lot more information that we would like to pass to this function, but we cannot as it accepts only one parameter. What can be done?', 'One obvious answer might be global variables. However, good coding practices do not advocate the use of global variables and say they must be used only when there is no other alternative.', 'Functors are objects that can be treated as though they are a function or function pointer. Functors are most commonly used along with STLs in a scenario like following:', 'This code snippet adds only one value to the contents of the arr[]. Now suppose, that we want to add 5 to contents of arr[].', 'See what’s happening? As transform requires a unary function(a function taking only one argument) for an array, we cannot pass a number to increment(). And this would, in effect, make us write several different functions to add each number. What a mess. This is where functors come into use.', 'A functor (or function object) is a C++ class that acts like a function. Functors are called using the same old function call syntax. To create a functor, we create a object that overloads the operator().', 'Thus, an object a is created that overloads the operator(). Hence, functors can be used effectively in conjunction with C++ STLs.', 'This article is contributed by Supriya Srivatsa. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']",[],"['// A C++ program uses transform() in STL to add // 1 to all elements of arr[]#include <bits/stdc++.h>using namespace std;   int increment(int x) {  return (x+1); }   int main(){    int arr[] = {1, 2, 3, 4, 5};    int n = sizeof(arr)/sizeof(arr[0]);       // Apply increment to all elements of    // arr[] and store the modified elements    // back in arr[]    transform(arr, arr+n, arr, increment);       for (int i=0; i<n; i++)        cout << arr[i] <<"" "";       return 0;}', '// C++ program to demonstrate working of// functors.#include <bits/stdc++.h>using namespace std;  // A Functorclass increment{private:    int num;public:    increment(int n) : num(n) {  }      // This operator overloading enables calling    // operator function () on objects of increment    int operator () (int arr_num) const {        return num + arr_num;    }};  // Driver codeint main(){    int arr[] = {1, 2, 3, 4, 5};    int n = sizeof(arr)/sizeof(arr[0]);    int to_add = 5;      transform(arr, arr+n, arr, increment(to_add));      for (int i=0; i<n; i++)        cout << arr[i] << "" "";}']","['2 3 4 5 6', 'The line,\nMyFunctor(10);\n\nIs same as\nMyFunctor.operator()(10);', '6 7 8 9 10', 'The line,\ntransform(arr, arr+n, arr, increment(to_add));\n\nis the same as writing below two lines,\n// Creating object of increment\nincrement obj(to_add); \n\n// Calling () on object\ntransform(arr, arr+n, arr, obj);']",[],[]
28,"['Pointers in C and C++ | Set 1 (Introduction, Arithmetic and Array)']","['C', 'C', 'C++', 'C', 'CPP', 'CPP']",[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/How-Pointer-Works-In-C.png', 'https://media.geeksforgeeks.org/wp-content/uploads/pointers-in-c.png', 'https://media.geeksforgeeks.org/wp-content/uploads/Untitled-presentation-31.png', 'https://media.geeksforgeeks.org/wp-content/uploads/PointersInC.png']",[],"['https://www.geeksforgeeks.org/easy/', 'https://media.geeksforgeeks.org/wp-content/uploads/Untitled-presentation-31.png', 'https://www.geeksforgeeks.org/applications-of-pointers-in-c-cpp/', 'https://www.geeksforgeeks.org/c-language-2-gq/pointers-gq/', 'https://www.geeksforgeeks.org/c-language-2-gq/advanced-pointer-c-gq/', 'https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Pointers store address of variables or a memory location.\xa0\xa0', 'Using a Pointer:\xa0', 'To use pointers in C, we must understand below two operators.\xa0\xa0', 'In general, nums[i][j] is equivalent to *(*(nums+i)+j)']","['\xa0Pointer Expressions and Pointer Arithmetic\xa0A limited set of arithmetic operations can be performed on pointers. A pointer may be:\xa0\xa0', 'Pointer arithmetic is meaningless unless performed on an array.\xa0Note : Pointers contain addresses. Adding two addresses makes no sense, because there is no idea what it would point to. Subtracting two addresses lets you compute the offset between these two addresses.\xa0', '\xa0Array Name as Pointers\xa0An array name acts like a pointer constant. The value of this pointer constant is the address of the first element.\xa0For example, if we have an array named val then val and &val[0] can be used interchangeably.\xa0\xa0', 'Now if this ptr is sent to a function as an argument then the array val can be accessed in a similar fashion.\xa0\xa0Pointers and Multidimensional Arrays\xa0Consider pointer notation for the two-dimensional numeric arrays. consider the following declaration\xa0\xa0']","['Applications of pointers in C/C++.\xa0Quizzes – Quiz on Pointer Basics , Quiz on Advanced PointerReference:\xa0https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.htmlThis article is contributed by Abhirav Kariya. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0\xa0']","['// The output of this program can be different// in different runs. Note that the program// prints address of a variable and a variable// can be assigned different address in different// runs.#include <stdio.h> int main(){    int x;     // Prints address of x    printf(""%p"", &x);     return 0;}', '// C program to demonstrate declaration of// pointer variables.#include <stdio.h>int main(){    int x = 10;     // 1) Since there is * in declaration, ptr    // becomes a pointer variable (a variable    // that stores address of another variable)    // 2) Since there is int before *, ptr is    // pointer to an integer type variable    int *ptr;     // & operator before x is used to get address    // of x. The address of x is assigned to ptr.    ptr = &x;     return 0;}', '// C++ program to demonstrate use of * for pointers in C++#include <iostream>using namespace std; int main(){    // A normal integer variable    int Var = 10;     // A pointer variable that holds address of var.    int *ptr = &Var;     // This line prints value at address stored in ptr.    // Value stored is value of variable ""var""    cout << ""Value of Var = ""<< *ptr << endl;     // The output of this line may be different in different    // runs even on same machine.    cout << ""Address of Var = "" <<  ptr << endl;     // We can also use ptr as lvalue (Left hand    // side of assignment)    *ptr = 20; // Value at address is now 20     // This prints 20    cout << ""After doing *ptr = 20, *ptr is ""<< *ptr << endl;     return 0;} // This code is contributed by// shubhamsingh10', '// C program to demonstrate use of * for pointers in C#include <stdio.h> int main(){    // A normal integer variable    int Var = 10;     // A pointer variable that holds address of var.    int *ptr = &Var;     // This line prints value at address stored in ptr.    // Value stored is value of variable ""var""    printf(""Value of Var = %d\\n"", *ptr);     // The output of this line may be different in different    // runs even on same machine.    printf(""Address of Var = %p\\n"", ptr);     // We can also use ptr as lvalue (Left hand    // side of assignment)    *ptr = 20; // Value at address is now 20     // This prints 20    printf(""After doing *ptr = 20, *ptr is %d\\n"", *ptr);     return 0;}', '// C++ program to illustrate Pointer Arithmetic// in C/C++#include <bits/stdc++.h> // Driver programint main(){    // Declare an array    int v[3] = {10, 100, 200};     // Declare pointer variable    int *ptr;     // Assign the address of v[0] to ptr    ptr = v;     for (int i = 0; i < 3; i++)    {        printf(""Value of *ptr = %d\\n"", *ptr);        printf(""Value of ptr = %p\\n\\n"", ptr);         // Increment pointer ptr by 1        ptr++;    }}', '// C++ program to illustrate Array Name as Pointers in C++#include <bits/stdc++.h>using namespace std; void geeks(){    // Declare an array    int val[3] = { 5, 10, 15};     // Declare pointer variable    int *ptr;     // Assign address of val[0] to ptr.    // We can use ptr=&val[0];(both are same)    ptr = val ;    cout << ""Elements of the array are: "";    cout << ptr[0] << "" "" << ptr[1] << "" "" << ptr[2];     return;} // Driver programint main(){    geeks();    return 0;}']","['// General syntax\ndatatype *var_name; \n\n// An example pointer ""ptr"" that holds\n// address of an integer variable or holds\n// address of a memory whose value(s) can\n// be accessed as integer values through ""ptr""\nint *ptr;', 'Value of Var = 10\nAddress of Var = 0x7fffa057dd4\nAfter doing *ptr = 20, *ptr is 20', 'Output:Value of *ptr = 10\nValue of ptr = 0x7ffcae30c710\n\nValue of *ptr = 100\nValue of ptr = 0x7ffcae30c714\n\nValue of *ptr = 200\nValue of ptr = 0x7ffcae30c718', 'Output:\nElements of the array are: 5 10 15', 'int nums[2][3]  =  { {16, 18, 20}, {25, 26, 27} };']",['*(*nums)|||nums[0][0]|||16&&&*(*nums + 1)|||nums[0][1]|||18&&&*(*nums + 2)|||nums[0][2]|||20&&&*(*(nums + 1))|||nums[1][0]|||25&&&*(*(nums + 1) + 1)|||nums[1][1]|||26&&&*(*(nums + 1) + 2)|||nums[1][2]|||27'],"['To access address of a variable to a pointer, we use the unary operator & (ampersand) that returns the address of that variable. For example &x gives us address of variable x.&&&|||One more operator is unary * (Asterisk) which is used for two things :To declare a pointer variable: When a pointer variable is declared in C/C++, there must be a * before its name.|||To declare a pointer variable: When a pointer variable is declared in C/C++, there must be a * before its name.&&&To declare a pointer variable: When a pointer variable is declared in C/C++, there must be a * before its name.&&&To access the value stored in the address we use the unary operator (*) that returns the value of the variable located at the address specified by its operand. This is also called Dereferencing.&&&Output :&&&Below is pictorial representation of above program:&&&incremented ( ++ )|||decremented ( — )|||an integer may be added to a pointer ( + or += )|||an integer may be subtracted from a pointer ( – or -= )']"
29,['Opaque Pointer'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://about.me/aashishbarnwal?promo=email_sig&utm_source=email_sig&utm_medium=external_link&utm_campaign=chrome_ext', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['It is safe to assign NULL to an opaque pointer.', 'Image.h : A header file to store class declaration.', 'Image.cpp : Code that will be shared across different end-points', 'Image_windows.cpp : Code specific to Windows will reside here', 'Image_apple.cpp : Code specific to Apple will reside here', 'Questions? Keep them coming. We would love to answer.']","['What is an opaque pointer?Opaque as the name suggests is something we can’t see through. e.g. wood is opaque. Opaque pointer is a pointer which points to a data structure whose contents are not exposed at the time of its definition.', 'Following pointer is opaque. One can’t know the data contained in STest structure by looking at the definition.', 'Why Opaque pointer?There are places where we just want to hint the compiler that “Hey! This is some data structure which will be used by our clients. Don’t worry, clients will provide its implementation while preparing compilation unit”. Such type of design is robust when we deal with shared code. Please see below example:', 'Please note that the above explained example is one way of doing this. Design is all about discussion and requirement. A good design is decided taking many factors into account. We can also have platform specific classes like CImageWindows, CImageApple and put all platform specific code there.', 'This article is contributed by Aashish Barnwal. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']","['Let’s say we are working on an app to deal with images. Since we are living in a world where everything is moving to cloud and devices are very affordable to buy, we want to develop apps for windows, android and apple platforms. So, it would be nice to have a good design which is robust, scalable and flexible as per our requirements. We can have shared code which would be used by all platforms and then different end-point can have platform specific code.To deal with images, we have a CImage class exposing APIs to deal with various image operations (scale, rotate, move, save etc).Since all the platforms will be providing same operations, we would define this class in a header file. But the way an image is handled might differ across platforms. Like Apple can have different mechanism to access pixels of an image than Windows does. This means that APIs might demand different set of info to perform operations. So to work on shared code, this is what we would like to do:', 'As it can be seen from the above example, while defining blueprint of the CImage class we are only mentioning that there is a SImageInfo data structure.The content of SImageInfo is unknown. Now it is the responsibility of clients(windows, apple, android) to define that data structure and use it as per their requirement. If in future we want to develop app for a new end-point ‘X’, the design is already there. We only need to define SImageInfo for end-point ‘X’ and use it accordingly.']","['// This class provides API to deal with various// image operations. Different platforms can // implement these operations in different ways.class CImage{public:    CImage();    ~CImage();    struct SImageInfo* pImageInfo;    void Rotate(double angle);    void Scale(double scaleFactorX,                double scaleFactorY);    void Move(int toX, int toY);    private:    void InitImageInfo();};', '// Constructor and destructor for CImageCImage::CImage(){    InitImageInfo();}  CImage::~CImage(){    // Destroy stuffs here}', 'struct SImageInfo{   // Windows specific DataSet};  void CImage::InitImageInfo(){    pImageInfo = new SImageInfo;    // Initialize windows specific info here}  void CImage::Rotate(){    // Make use of windows specific SImageInfo}', 'struct SImageInfo{    // Apple specific DataSet};void CImage::InitImageInfo(){    pImageInfo = new SImageInfo;          // Initialize apple specific info here}void CImage::Rotate(){    // Make use of apple specific SImageInfo}']","['struct STest* pSTest;', 'pSTest = NULL;']",[],[]
30,['References in C++'],"['CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'C++', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/what-are-wild-pointers-how-can-we-avoid/', 'https://www.geeksforgeeks.org/pointers-vs-references-cpp/', 'https://www.geeksforgeeks.org/when-do-we-pass-arguments-by-reference-or-pointer/', 'https://www.geeksforgeeks.org/g-fact-25/', 'https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Applications :\xa0\xa0', 'References vs Pointers:', '1. A pointer can be declared as void but a reference can never be void For example', '3.Reference variable cannot be updated.', '4.Reference variable is an internal pointer .', 'Question 2\xa0', 'Question 3\xa0', 'Question 4\xa0', 'Question 5\xa0', 'Question 6\xa0', 'Related Articles :\xa0']","['When a variable is declared as a reference, it becomes an alternative name for an existing variable. A variable can be declared as a reference by putting ‘&’ in the declaration.\xa0', 'Both references and pointers can be used to change local variables of one function inside another function. Both of them can also be used to save copying of big objects when passed as arguments to functions or returned from functions, to get efficiency gain. Despite the above similarities, there are the following differences between references and pointers.', '2. The pointer variable has n-levels/multiple levels of indirection i.e. single-pointer, double-pointer, triple-pointer. Whereas, the reference variable has only one/single level of indirection. The following code reveals the mentioned points: \xa0', '5.Declaration of Reference variable is preceded with ‘&’ symbol ( but do not read it as “address of”).', 'Exercise:\xa0Predict the output of the following programs. If there are compilation errors, then fix them.Question 1\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above\xa0']",[],"['#include<iostream>using namespace std;  int main(){  int x = 10;    // ref is a reference to x.  int& ref = x;    // Value of x is now changed to 20  ref = 20;  cout << ""x = "" << x << endl ;    // Value of x is now changed to 30  x = 30;  cout << ""ref = "" << ref << endl ;    return 0;}', '#include<iostream>using namespace std;  void swap (int& first, int& second){    int temp = first;    first = second;    second = temp;}  int main(){    int a = 2, b = 3;    swap( a, b );    cout << a << "" "" << b;    return 0;}', 'struct Student {   string name;   string address;   int rollNo;}  // If we remove & in below function, a new// copy of the student object is created. // We use const to avoid accidental updates// in the function as the purpose of the function// is to print s only.void print(const Student &s){    cout << s.name << ""  "" << s.address << ""  "" << s.rollNo;}', '#include <bits/stdc++.h> using namespace std;   int main() {     vector<int> vect{ 10, 20, 30, 40 };       // We can modify elements if we     // use reference    for (int &x : vect)         x = x + 5;      // Printing elements    for (int x : vect)        cout << x << "" "";       return 0; }', '#include <bits/stdc++.h> using namespace std;   int main() {     vector<string> vect{""geeksforgeeks practice"",                      ""geeksforgeeks write"",                     ""geeksforgeeks ide""};       // We avoid copy of the whole string    // object by using reference.    for (const auto &x : vect)        cout << x << endl;       return 0; }', '#include <iostream>using namespace std;  int main() {    int i=10; //simple or ordinary variable.    int *p=&i; //single pointer    int **pt=&p; //double pointer    int ***ptr=&pt; //triple pointer    // All the above pointers differ in the value they store or point to.    cout << ""i="" << i << ""\\t"" << ""p="" << p << ""\\t""          << ""pt="" << pt << ""\\t"" << ""ptr="" << ptr << ""\\n"";    int a=5; //simple or ordinary variable     int &S=a;     int &S0=S;    int &S1=S0;    cout << ""a="" << a << ""\\t"" << ""S="" << S << ""\\t""          << ""S0="" << S0 << ""\\t"" << ""S1="" << S1 << ""\\n"";    // All the above references do not differ in their values     // as they all refer to the same variable. }', '#include<iostream>using namespace std;  int &fun(){    static int x = 10;    return x;}int main(){    fun() = 30;    cout << fun();    return 0;}', '#include<iostream>using namespace std;  int fun(int &x){    return x;}int main(){    cout << fun(10);    return 0;}', '#include<iostream>using namespace std;  void swap(char * &str1, char * &str2){  char *temp = str1;  str1 = str2;  str2 = temp;}  int main(){  char *str1 = ""GEEKS"";  char *str2 = ""FOR GEEKS"";  swap(str1, str2);  cout<<""str1 is ""<<str1<<endl;  cout<<""str2 is ""<<str2<<endl;  return 0;}', '#include<iostream>using namespace std;  int main(){   int x = 10;   int *ptr = &x;   int &*ptr1 = ptr;}', '#include<iostream>using namespace std;  int main(){   int *ptr = NULL;   int &ref = *ptr;   cout << ref;}', '#include<iostream>using namespace std;  int &fun(){    int x = 10;    return x;}int main(){    fun() = 30;    cout << fun();    return 0;}']","['x = 20\nref = 30', '3 2', 'int a = 10;\nvoid* aa = &a;. //it is valid\nvoid &ar = a; // it is not valid']",[],"['References are less powerful than pointers1) Once a reference is created, it cannot be later made to reference another object; it cannot be reset. This is often done with pointers.2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.3) A reference must be initialized when declared. There is no such restriction with pointers.Due to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don’t have the above restrictions and can be used to implement all data structures. References being more powerful in Java is the main reason Java doesn’t need pointers.|||References are safer and easier to use:1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don’t refer to a valid location (See questions 5 and 6 in the below exercise )2) Easier to use: References don’t need a dereferencing operator to access the value. They can be used like normal variables. ‘&’ operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (‘.’), unlike pointers where arrow operator (->) is needed to access members.|||Together with the above reasons, there are few places like the copy constructor argument where pointer cannot be used. Reference must be used to pass the argument in the copy constructor. Similarly, references must be used for overloading some operators like ++.&&&Pointers vs References in C++|||When do we pass arguments by reference or pointer?|||Can references refer to invalid location in C++?|||Passing by pointer Vs Passing by Reference in C++&&&&&&Modify the passed parameters in a function: If a function receives a reference to a variable, it can modify the value of the variable. For example, the following program variables are swapped using references.CPP#include<iostream>using namespace std;void swap (int& first, int& second){int temp = first;first = second;second = temp;}int main(){int a = 2, b = 3;swap( a, b );cout << a << "" "" << b;return 0;}Output: 3 2 |||Avoiding a copy of large structures: Imagine a function that has to receive a large object. If we pass it without reference, a new copy of it is created which causes wastage of CPU time and memory. We can use references to avoid this.CPPstruct Student {string name;string address;int rollNo;}// If we remove & in below function, a new// copy of the student object is created.// We use const to avoid accidental updates// in the function as the purpose of the function// is to print s only.void print(const Student &s){cout << s.name << "" "" << s.address << "" "" << s.rollNo;}|||In For Each Loops to modify all objects : We can use references in for each loops to modify all elements.CPP#include <bits/stdc++.h>using namespace std;int main(){vector<int> vect{ 10, 20, 30, 40 };// We can modify elements if we// use referencefor (int &x : vect)x = x + 5;// Printing elementsfor (int x : vect)cout << x << "" "";return 0;}|||For Each Loop to avoid the copy of objects: We can use references in each loop to avoid a copy of individual objects when objects are large. CPP#include <bits/stdc++.h>using namespace std;int main(){vector<string> vect{""geeksforgeeks practice"",""geeksforgeeks write"",""geeksforgeeks ide""};// We avoid copy of the whole string// object by using reference.for (const auto &x : vect)cout << x << endl;return 0;}&&&']"
31,['‘this’ pointer in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/g-fact-77/', 'https://www.geeksforgeeks.org/when-do-we-use-initializer-list-in-c/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Following are the situations where ‘this’ pointer is used:', '1) When local variable’s name is same as member’s name', 'For constructors, initializer list can also be used when parameter name is same as member’s name.', '2) To return reference to the calling object', 'Exercise:Predict the output of following programs. If there are compilation errors, then fix them.', 'Question 1', 'Question 2', 'Question 3', 'Question 4']","['To understand ‘this’ pointer, it is important to know how objects look at functions and data members of a class.', 'In the early version of C++ would let ‘this’ pointer to be changed; by doing so a programmer could change which object a method was working on. This feature was eventually removed, and now this in C++ is an r-value.C++ lets object destroy themselves by calling the following code :', 'As Stroustrup said ‘this’ could be the reference than the pointer, but the reference was not present in the early version of C++. If ‘this’ is implemented as a reference then, the above problem could be avoided and it could be safer than the pointer.', 'When a reference to a local object is returned, the returned reference can be used to chain function calls on a single object.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']","['Meaning each object gets its own copy of data members and all objects share a single copy of member functions.Then now question is that if only one copy of each member function exists and is used by multiple objects, how are the proper data members are accessed and updated?The compiler supplies an implicit pointer along with the names of the functions as ‘this’.The ‘this’ pointer is passed as a hidden argument to all nonstatic member function calls and is available as a local variable within the body of all nonstatic functions. ‘this’ pointer is not available in static member functions as static member functions can be called without any object (with class name).For a class X, the type of this pointer is ‘X* ‘. Also, if a member function of X is declared as const, then the type of this pointer is ‘const X *’ (see this GFact)']","['delete this;', '#include<iostream>using namespace std;  /* local variable is same as a member\'s name */class Test{private:   int x;public:   void setX (int x)   {       // The \'this\' pointer is used to retrieve the object\'s x       // hidden by the local variable \'x\'       this->x = x;   }   void print() { cout << ""x = "" << x << endl; }};  int main(){   Test obj;   int x = 20;   obj.setX(x);   obj.print();   return 0;}', '/* Reference to the calling object can be returned */ Test& Test::func (){   // Some processing   return *this;}', '#include<iostream>using namespace std;  class Test{private:  int x;  int y;public:  Test(int x = 0, int y = 0) { this->x = x; this->y = y; }  Test &setX(int a) { x = a; return *this; }  Test &setY(int b) { y = b; return *this; }  void print() { cout << ""x = "" << x << "" y = "" << y << endl; }};  int main(){  Test obj1(5, 5);    // Chained function calls.  All calls modify the same object  // as the same object is returned by reference  obj1.setX(10).setY(20);    obj1.print();  return 0;}', '#include<iostream>using namespace std;  class Test{private:  int x;public:  Test(int x = 0) { this->x = x; }  void change(Test *t) { this = t; }  void print() { cout << ""x = "" << x << endl; }};  int main(){  Test obj(5);  Test *ptr = new Test (10);  obj.change(ptr);  obj.print();  return 0;}', '#include<iostream>using namespace std;  class Test{private:  int x;  int y;public:  Test(int x = 0, int y = 0) { this->x = x; this->y = y; }  static void fun1() { cout << ""Inside fun1()""; }  static void fun2() { cout << ""Inside fun2()""; this->fun1(); }};  int main(){  Test obj;  obj.fun2();  return 0;}', '#include<iostream>using namespace std;  class Test{private:  int x;  int y;public:  Test (int x = 0, int y = 0) { this->x = x; this->y = y; }  Test setX(int a) { x = a; return *this; }  Test setY(int b) { y = b; return *this; }  void print() { cout << ""x = "" << x << "" y = "" << y << endl; }};  int main(){  Test obj1;  obj1.setX(10).setY(20);  obj1.print();  return 0;}', '#include<iostream>using namespace std;  class Test{private:  int x;  int y;public:  Test(int x = 0, int y = 0) { this->x = x; this->y = y; }  void setX(int a) { x = a; }  void setY(int b) { y = b; }  void destroy()  { delete this; }  void print() { cout << ""x = "" << x << "" y = "" << y << endl; }};  int main(){  Test obj;  obj.destroy();  obj.print();  return 0;}']","['x = 20', 'x = 10 y = 20']",[],['Each object gets its own copy of the data member.|||All-access the same function definition as present in the code segment.']
32,['Smart Pointers in C++ and How to Use Them'],"['Problems with Normal Pointers', 'C++', 'Introduction of Smart Pointers', 'C++', 'C++', 'Types of Smart Pointers', 'C++14', 'C++14']","['1. unique_ptr', '2. shared_ptr', '3. weak_ptr\xa0']","['https://media.geeksforgeeks.org/wp-content/uploads/20191202223147/uniquePtr.png', 'https://media.geeksforgeeks.org/wp-content/uploads/20191202231341/shared_ptr.png', 'https://media.geeksforgeeks.org/wp-content/uploads/20191202233339/weakPtr.png']",[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/destructors-c/', 'https://www.geeksforgeeks.org/operator-overloading-c/', 'https://', 'https://www.geeksforgeeks.org/templates-cpp/', 'http://en.wikipedia.org/wiki/Auto_ptr', 'http://en.wikipedia.org/wiki/Smart_pointer#unique_ptr', 'http://en.wikipedia.org/wiki/Smart_pointer#shared_ptr_and_weak_ptr', 'http://en.wikipedia.org/wiki/Smart_pointer', 'https://www.facebook.com/amiyaranjan.rout.50', 'https://auth.geeksforgeeks.org/user/aashakil50', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Take a look at the code below.', 'References:\xa0http://en.wikipedia.org/wiki/Smart_pointer']","['In this article, we will be discussing smart pointers in C++. What are Smart Pointers, why, and how to use them properly?', 'In function main, fun is called in an infinite loop. That means it’ll keep creating p. It’ll allocate more and more memory but won’t free them as we didn’t deallocate it. The memory that’s wasted can’t be used again. Which is a memory leak. The entire heap memory may become useless for this reason. C++11 comes up with a solution to this problem, Smart Pointer.', 'A Smart Pointer is a wrapper class over a pointer with an operator like * and -> overloaded. The objects of the smart pointer class look like normal pointers. But, unlike Normal Pointers it can deallocate and free destroyed object memory.', 'The idea is to take a class with a pointer, destructor and overloaded operators like * and ->. Since the destructor is automatically called when an object goes out of scope, the dynamically allocated memory would automatically be deleted (or reference count can be decremented). Consider the following simple SmartPtr class.', 'This only works for int. So, we’ll have to create Smart Pointer for every object? No, there’s a solution, Template. In the code below as you can see T can be of any type. Read more about Template here.', 'Note: Smart pointers are also useful in the management of resources, such as file handles or network sockets.', 'unique_ptr stores one pointer only. We can assign a different object by removing the current object from the pointer. Notice the code below. First, the unique_pointer is pointing to P1. But, then we remove P1 and assign P2 so the pointer now points to P2.', 'By using shared_ptr more than one pointer can point to this one object at a time and it’ll maintain a Reference Counter using use_count() method.\xa0', 'It’s much more similar to shared_ptr except it’ll not maintain a Reference Counter. In this case, a pointer will not have a stronghold on the object. The reason is if suppose pointers are holding the object and requesting for other objects then they may form a Deadlock.\xa0', 'C++ libraries provide implementations of smart pointers in the form of auto_ptr, unique_ptr, shared_ptr and weak_ptr', 'This article is improved by AmiyaRanjanRout. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0It had been improved again by AAShakil50.']","['Pointers are used for accessing the resources which are external to the program – like heap memory. So, for accessing the heap memory (if anything is created inside heap memory), pointers are used. When accessing any external resource we just use a copy of the resource. If we make any change to it, we just change it in the copied version. But, if we use a pointer to the resource, we’ll be able to change the original resource.', 'In function fun, it creates a pointer that is pointing to the Rectangle object. The object Rectangle contains two integers, length and breadth. When the function fun ends, p will be destroyed as it is a local variable. But, the memory it consumed won’t be deallocated because we forgot to use delete p; at the end of the function. That means the memory won’t be free to be used by other resources. But, we don’t need the variable anymore, but we need the memory.', 'As we’ve known unconsciously not deallocating a pointer causes a memory leak that may lead to crash of the program. Languages Java, C# has Garbage Collection Mechanisms to smartly deallocate unused memory to be used again. The programmer doesn’t have to worry about any memory leak. C++11 comes up with its own mechanism that’s Smart Pointer. When the object is destroyed it frees the memory as well. So, we don’t need to delete it as Smart Pointer does will handle it.']","['#include <iostream>using namespace std; class Rectangle {private:    int length;    int breadth;}; void fun(){    // By taking a pointer p and    // dynamically creating object    // of class rectangle    Rectangle* p = new Rectangle();} int main(){    // Infinite Loop    while (1) {        fun();    }}', ""#include <iostream>using namespace std; class SmartPtr {    int* ptr; // Actual pointerpublic:    // Constructor: Refer https:// www.geeksforgeeks.org/g-fact-93/    // for use of explicit keyword    explicit SmartPtr(int* p = NULL) { ptr = p; }     // Destructor    ~SmartPtr() { delete (ptr); }     // Overloading dereferencing operator    int& operator*() { return *ptr; }}; int main(){    SmartPtr ptr(new int());    *ptr = 20;    cout << *ptr;     // We don't need to call delete ptr: when the object    // ptr goes out of scope, the destructor for it is automatically    // called and destructor does delete ptr.     return 0;}"", '#include <iostream>using namespace std; // A generic smart pointer classtemplate <class T>class SmartPtr {    T* ptr; // Actual pointerpublic:    // Constructor    explicit SmartPtr(T* p = NULL) { ptr = p; }     // Destructor    ~SmartPtr() { delete (ptr); }     // Overloading dereferencing operator    T& operator*() { return *ptr; }     // Overloading arrow operator so that    // members of T can be accessed    // like a pointer (useful if T represents    // a class or struct or union type)    T* operator->() { return ptr; }}; int main(){    SmartPtr<int> ptr(new int());    *ptr = 20;    cout << *ptr;    return 0;}', ""#include <iostream>using namespace std;#include <memory> class Rectangle {    int length;    int breadth; public:    Rectangle(int l, int b){        length = l;        breadth = b;    }     int area(){        return length * breadth;    }}; int main(){     unique_ptr<Rectangle> P1(new Rectangle(10, 5));    cout << P1->area() << endl; // This'll print 50     // unique_ptr<Rectangle> P2(P1);    unique_ptr<Rectangle> P2;    P2 = move(P1);     // This'll print 50    cout << P2->area() << endl;     // cout<<P1->area()<<endl;    return 0;}"", ""#include <iostream>using namespace std;#include <memory> class Rectangle {    int length;    int breadth; public:    Rectangle(int l, int b)    {        length = l;        breadth = b;    }     int area()    {        return length * breadth;    }}; int main(){     shared_ptr<Rectangle> P1(new Rectangle(10, 5));    // This'll print 50    cout << P1->area() << endl;     shared_ptr<Rectangle> P2;    P2 = P1;     // This'll print 50    cout << P2->area() << endl;     // This'll now not give an error,    cout << P1->area() << endl;     // This'll also print 50 now    // This'll print 2 as Reference Counter is 2    cout << P1.use_count() << endl;    return 0;}""]","['20', '20', '50\n50', '50\n50\n50\n2']",[],[]
33,['Pointers vs References in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/', 'https://www.geeksforgeeks.org/references-in-c/', 'https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/', 'https://www.geeksforgeeks.org/references-in-c/', 'https://isocpp.org/wiki/faq/references#refs-vs-ptrs', 'https://www.geeksforgeeks.org/when-do-we-pass-arguments-by-reference-or-pointer/', 'http://contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']","['Prerequisite:\xa0Pointers, References\xa0', 'Differences :\xa0\xa0', '1. Initialization: A pointer can be initialized in this way:\xa0', '2. While in references,\xa0\xa0', '5. On the other hand, a reference cannot be re-assigned, and must be assigned at initialization.', 'When to use What', 'Related Article:\xa0When do we pass arguments as Reference or Pointers?\xa0']","['C and C++ support pointers which are different from most of the other programming languages. Other languages including C++, Java, Python, Ruby, Perl and PHP support references.\xa0', 'On the surface, both references and pointers are very similar, both are used to have one variable provide access to another. With both providing lots of the same capabilities, it’s often unclear what is different between these different mechanisms. In this article, I will try to illustrate the differences between pointers and references.\xa0', 'Pointers: A pointer is a variable that holds memory address of another variable. A pointer needs to be dereferenced with * operator to access the memory location it points to.\xa0', 'References : A reference variable is an alias, that is, another name for an already existing variable. A reference, like a pointer, is also implemented by storing the address of an object.\xa0A reference can be thought of as a constant pointer (not to be confused with a pointer to a constant value!) with automatic indirection, i.e the compiler will apply the * operator for you.\xa0', '3. NOTE: This differences may vary from compiler to compiler.The above differences is with respect to turbo IDE.\xa0', '4. Reassignment: A pointer can be re-assigned. This property is useful for implementation of data structures like linked list, tree, etc. See the following examples:\xa0', '6. Memory Address: A pointer has its own memory address and size on the stack whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.', '7. NULL value: Pointer can be assigned NULL directly, whereas reference cannot.\xa0The constraints associated with references (no NULL, no reassignment) ensure that the underlying operations do not run into exception situation.', '8. Indirection: You can have pointers to pointers offering extra levels of indirection. Whereas references only offer one level of indirection.I.e,\xa0', '9. Arithmetic operations: Various arithmetic operations can be performed on pointers whereas there is no such thing called Reference Arithmetic.(but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in &obj + 5).)\xa0', 'The performances are exactly the same, as references are implemented internally as pointers. But still you can keep some points in your mind to decide when to use what :\xa0\xa0', 'Quoted in C++ FAQ Lite : Use references when you can, and pointers when you have to. References are usually preferred over pointers whenever you don’t need “reseating”. This usually means that references are most useful in a class’s public\xa0interface. References typically appear on the skin of an object, and pointers on the inside.\xa0', 'The exception to the above is where a function’s parameter or return value needs a “sentinel” reference — a reference that does not refer to an object. This is usually best done by returning/taking a pointer, and giving the NULL pointer this special significance (references must always alias objects, not a dereferenced null pointer).\xa0', 'This article is contributed by Rishav Raj. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],[],"['int i = 3; \n\n// A pointer to variable i (or stores\n// address of i)\nint *ptr = &i; \n\n// A reference (or alias) for i.\nint &ref = i;', 'int a = 10;        \n  int *p = &a;    \n         OR \n     int *p;\n   p = &a;\nwe can declare and initialize pointer at same step or in multiple line.', 'int a=10;\nint &p=a;  //it is correct\n   but\nint &p;\n p=a;    // it is incorrect as we should declare and initialize references at single step.', 'int a = 5;\nint b = 6;\nint *p;\np =  &a;\np = &b;', 'int a = 5;\nint b = 6;\nint &p = a;\nint &p = b;  //At this line it will show error as ""multiple declaration is not allowed"".\n\nHowever it is valid statement,\nint &q=p;', 'int &p = a;\n   cout << &p << endl << &a;', 'In Pointers,\nint a = 10;\nint *p;\nint **q;  //it is valid.\np = &a;\nq = &p;\n\nWhereas in references,\n\nint &p = a;\nint &&q = p; //it is reference to reference, so it is an error.']",[],"['Use referencesIn function parameters and return types.|||In function parameters and return types.|||Use pointers:Use pointers if pointer arithmetic or passing NULL-pointer is needed. For example for arrays (Note that array access is implemented using pointer arithmetic).To implement data structures like linked list, tree, etc and their algorithms because to point different cell, we have to use the concept of pointers.|||Use pointers if pointer arithmetic or passing NULL-pointer is needed. For example for arrays (Note that array access is implemented using pointer arithmetic).|||To implement data structures like linked list, tree, etc and their algorithms because to point different cell, we have to use the concept of pointers.&&&In function parameters and return types.&&&Use pointers if pointer arithmetic or passing NULL-pointer is needed. For example for arrays (Note that array access is implemented using pointer arithmetic).|||To implement data structures like linked list, tree, etc and their algorithms because to point different cell, we have to use the concept of pointers.']"
34,['Object Oriented Programming in C++'],[],[],"['https://media.geeksforgeeks.org/wp-content/uploads/OOPs-Concepts.jpg', 'https://media.geeksforgeeks.org/wp-content/uploads/Encapsulation-in-C-1.jpg', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190501131135/polymorphism_example.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190501121513/inheritance.png']",[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/#intro', 'https://www.geeksforgeeks.org/#class', 'https://www.geeksforgeeks.org/#obj', 'https://www.geeksforgeeks.org/#encapsulation', 'https://www.geeksforgeeks.org/#abstraction', 'https://www.geeksforgeeks.org/#polymorphism', 'https://www.geeksforgeeks.org/#inheritance', 'https://www.geeksforgeeks.org/#db', 'https://www.geeksforgeeks.org/#mp', 'https://www.geeksforgeeks.org/#objects', 'https://www.geeksforgeeks.org/c-classes-and-objects/', 'https://www.geeksforgeeks.org/c-classes-and-objects/', 'https://www.geeksforgeeks.org/encapsulation-in-c/', 'https://www.geeksforgeeks.org/abstraction-in-c/', 'https://www.geeksforgeeks.org/polymorphism-in-c/', 'https://www.geeksforgeeks.org/inheritance-in-c/', 'https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/', 'https://www.geeksforgeeks.org/c-classes-and-objects/', 'https://www.geeksforgeeks.org/inheritance-in-c/', 'https://www.geeksforgeeks.org/access-modifiers-in-c/', 'https://www.geeksforgeeks.org/abstraction-in-c/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['TABLE OF CONTENT:', 'Characteristics of an Object Oriented Programming language', 'When a program is executed the objects interact by sending messages to one another.', 'Encapsulation in C++', 'C++ supports operator overloading and function overloading.', 'Example: Dog, Cat, Cow can be Derived Class of Animal Base Class.', 'Related Articles:']","['Object-oriented programming – As the name suggests uses objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc in programming. The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.', 'Class: The building block of C++ that leads to Object-Oriented programming is a Class. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.', 'For Example: Consider the Class of Cars. There may be many cars with different names and brand but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range etc. So here, Car is the class and wheels, speed limits, mileage are their properties.', 'We can say that a Class in C++ is a blue-print representing a group of objects which shares some common properties and behaviours.', 'Object: An Object is an identifiable entity with some characteristics and behaviour. An Object is an instance of a Class. When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is allocated.', 'Object take up space in memory and have an associated address like a record in pascal or structure or union in C.', 'Each object contains data and code to manipulate the data. Objects can interact without having to know details of each other’s data or code, it is sufficient to know the type of message accepted and type of response returned by the objects.', 'Encapsulation: In normal terms, Encapsulation is defined as wrapping up of data and information under a single unit. In Object-Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.', 'Encapsulation also leads to data abstraction or hiding. As using encapsulation also hides the data. In the above example, the data of any of the section like sales, finance or accounts are hidden from any other section.', 'Abstraction: Data abstraction is one of the most essential and important features of object-oriented programming in C++. Abstraction means displaying only essential information and hiding the details. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation.', 'Polymorphism: The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.', 'A person at the same time can have different characteristic. Like a man at the same time is a father, a husband, an employee. So the same person posses different behaviour in different situations. This is called polymorphism.', 'An operation may exhibit different behaviours in different instances. The behaviour depends upon the types of data used in the operation.', 'Example: Suppose we have to write a function to add some integers, some times there are 2 integers, some times there are 3 integers. We can write the Addition Method with the same name having different parameters, the concerned method will be called according to parameters.', 'Inheritance: The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object-Oriented Programming.', 'Dynamic Binding: In dynamic binding, the code to be executed in response to function call is decided at runtime. C++ has virtual functions to support this.', 'Message Passing: Objects communicate with one another by sending and receiving information to each other. A message for an object is a request for execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. Message passing involves specifying the name of the object, the name of the function and the information to be sent.', 'This article is contributed by Vankayala Karunakar. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['Consider a real-life example of encapsulation, in a company, there are different sections like the accounts section, finance section, sales section etc. The finance section handles all the financial transactions and keeps records of all the data related to finance. Similarly, the sales section handles all the sales-related activities and keeps records of all the sales. Now there may arise a situation when for some reason an official from the finance section needs all the data about sales in a particular month. In this case, he is not allowed to directly access the data of the sales section. He will first have to contact some other officer in the sales section and then request him to give the particular data. This is what encapsulation is. Here the data of the sales section and the employees that can manipulate them are wrapped under a single name “sales section”.', 'Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of the car or applying brakes will stop the car but he does not know about how on pressing accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.']",['class person{    char name[20];    int id;public:    void getdetails(){}};  int main(){   person p1; // p1 is a object }'],[],[],"['A Class is a user-defined data-type which has data members and member functions.|||Data members are the data variables and member functions are the functions used to manipulate these variables and together these data members and member functions define the properties and behaviour of the objects in a Class.|||In the above example of class Car, the data member will be speed limit, mileage etc and member functions can apply brakes, increase speed etc.&&&Abstraction using Classes: We can implement Abstraction in C++ using classes. The class helps us to group data members and member functions using available access specifiers. A Class can decide which data member will be visible to the outside world and which is not.|||Abstraction in Header files: One more type of abstraction in C++ can be header files. For example, consider the pow() method present in math.h header file. Whenever we need to calculate the power of a number, we simply call the function pow() present in the math.h header file and pass the numbers as arguments without knowing the underlying algorithm according to which the function is actually calculating the power of numbers.&&&Operator Overloading: The process of making an operator to exhibit different behaviours in different instances is known as operator overloading.|||Function Overloading: Function overloading is using a single function name to perform different types of tasks.Polymorphism is extensively used in implementing inheritance.&&&Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.|||Super Class:The class whose properties are inherited by sub class is called Base Class or Super class.|||Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.&&&Classes and Objects|||Inheritance|||Access Modifiers|||Abstraction&&&&&&Introduction|||Class|||Objects|||Encapsulation|||Abstraction|||Polymorphism|||Inheritance|||Dynamic Binding|||Message Passing&&&']"
35,['C++ Classes and Objects'],[],[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/Classes-and-Objects-in-C.png'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/access-modifiers-in-c/', 'https://www.geeksforgeeks.org/friend-class-function-cpp/', 'https://www.geeksforgeeks.org/constructors-c/', 'https://www.geeksforgeeks.org/constructors-c/', 'https://www.geeksforgeeks.org/copy-constructor-in-cpp/', 'https://www.geeksforgeeks.org/destructors-c/', 'https://www.geeksforgeeks.org/pure-virtual-destructor-c/', 'https://www.geeksforgeeks.org/multiple-inheritance-in-c/', 'https://www.geeksforgeeks.org/quiz-corner-gq/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Defining Class and Declaring Objects', 'Accessing Data Members', 'Member Functions in Classes', 'There are 2 ways to define a member function:', 'Note: Declaring a friend function is a way to give private access to a non-member function.', 'Constructors', 'Destructors', 'Pure Virtual Destructor', 'Related Articles:']","['An Object is an instance of a Class. When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is allocated.', 'A class is defined in C++ using keyword class followed by the name of class. The body of class is defined inside the curly brackets and terminated by a semicolon at the end.', 'Declaring Objects: When a class is defined, only the specification for the object is defined; no memory or storage is allocated. To use the data and access functions defined in the class, you need to create objects.', 'Accessing data members and member functions: The data members and member functions of class can be accessed using the dot(‘.’) operator with the object. For example if the name of object is obj and you want to access the member function with the name printName() then you will have to write obj.printName() .', 'The public data members are also accessed in the same way given however the private data members are not allowed to be accessed directly by the object. Accessing a data member depends solely on the access control of that data member.This access control is given by Access modifiers in C++. There are three access modifiers : public, private and protected.', 'To define a member function outside the class definition we have to use the scope resolution :: operator along with class name and function name.', 'Note that all the member functions defined inside the class definition are by default inline, but you can also make any non-class function inline by using keyword inline with them. Inline functions are actual functions, which are copied everywhere during compilation, like pre-processor macro, so the overhead of function calling is reduced.', 'Constructors are special class members which are called by the compiler every time an object of that class is instantiated. Constructors have the same name as the class and may be defined inside or outside the class definition.There are 3 types of constructors:', 'A Copy Constructor creates a new object, which is exact copy of the existing object. The compiler provides a default Copy Constructor to all the classes.Syntax:', 'Destructor is another special member function that is called by the compiler when the scope of the object ends.', 'This article is contributed by Abhirav Kariya. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['Class: A class in C++ is the building block that leads to Object-Oriented programming. It is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A C++ class is like a blueprint for an object.For Example: Consider the Class of Cars. There may be many cars with different names and brand but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range etc. So here, Car is the class and wheels, speed limits, mileage are their properties.']","['// C++ program to demonstrate// accessing of data members #include <bits/stdc++.h>using namespace std;class Geeks{    // Access specifier    public:     // Data Members    string geekname;     // Member Functions()    void printname()    {       cout << ""Geekname is: "" << geekname;    }}; int main() {     // Declare an object of class geeks    Geeks obj1;     // accessing data member    obj1.geekname = ""Abhi"";     // accessing member function    obj1.printname();    return 0;}', '// C++ program to demonstrate function// declaration outside class #include <bits/stdc++.h>using namespace std;class Geeks{    public:    string geekname;    int id;         // printname is not defined inside class definition    void printname();         // printid is defined inside class definition    void printid()    {        cout << ""Geek id is: "" << id;    }}; // Definition of printname using scope resolution operator ::void Geeks::printname(){    cout << ""Geekname is: "" << geekname;}int main() {         Geeks obj1;    obj1.geekname = ""xyz"";    obj1.id=15;         // call printname()    obj1.printname();    cout << endl;         // call printid()    obj1.printid();    return 0;}', '// C++ program to demonstrate constructors #include <bits/stdc++.h>using namespace std;class Geeks{    public:    int id;         //Default Constructor    Geeks()    {        cout << ""Default Constructor called"" << endl;        id=-1;    }         //Parameterized Constructor    Geeks(int x)    {        cout << ""Parameterized Constructor called"" << endl;        id=x;    }};int main() {         // obj1 will call Default Constructor    Geeks obj1;    cout << ""Geek id is: "" <<obj1.id << endl;         // obj1 will call Parameterized Constructor    Geeks obj2(21);    cout << ""Geek id is: "" <<obj2.id << endl;    return 0;}', '// C++ program to explain destructors #include <bits/stdc++.h>using namespace std;class Geeks{    public:    int id;         //Definition for Destructor    ~Geeks()    {        cout << ""Destructor called for id: "" << id <<endl;    }}; int main()  {    Geeks obj1;    obj1.id=7;    int i = 0;    while ( i < 5 )    {        Geeks obj2;        obj2.id=i;        i++;           } // Scope for obj2 ends here     return 0;  } // Scope for obj1 ends here']","['ClassName ObjectName;', 'Geekname is: Abhi', 'Geekname is: xyz\nGeek id is: 15', 'Default Constructor called\nGeek id is: -1\nParameterized Constructor called\nGeek id is: 21', 'class-name (class-name &){}', 'Destructor called for id: 0\nDestructor called for id: 1\nDestructor called for id: 2\nDestructor called for id: 3\nDestructor called for id: 4\nDestructor called for id: 7']",[],"['A Class is a user defined data-type which has data members and member functions.|||Data members are the data variables and member functions are the functions used to manipulate these variables and together these data members and member functions defines the properties and behavior of the objects in a Class.|||In the above example of class Car, the data member will be speed limit, mileage etc and member functions can be apply brakes, increase speed etc.&&&Inside class definition|||Outside class definition&&&Default constructors|||Parameterized constructors|||Copy constructors&&&Multiple Inheritance in C++|||C++ Quiz']"
36,['Inheritance in C++'],"['CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP']",[],"['https://media.geeksforgeeks.org/wp-content/uploads/inheritance.png', 'https://media.geeksforgeeks.org/wp-content/uploads/inheritance2.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/table-class.png', 'https://media.geeksforgeeks.org/wp-content/uploads/single-inheritance.png', 'https://media.geeksforgeeks.org/wp-content/uploads/multiple-inheritance.png', 'https://media.geeksforgeeks.org/wp-content/uploads/multilevel-inheritance.png', 'https://media.geeksforgeeks.org/wp-content/uploads/hierarchical-inheritance.png', 'https://media.geeksforgeeks.org/wp-content/uploads/Hybrid-Inheritance.png', 'http://www.tutorialdost.com/Cpp-Programming-Tutorial/Images/Multipath-Inheritance-Ambiguity-In-Cpp.png']",[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/#Why and when to use inheritance?', 'https://www.geeksforgeeks.org/#Modes of Inheritance', 'https://www.geeksforgeeks.org/#Types of Inheritance', 'https://www.geeksforgeeks.org/multiple-inheritance-in-c/', 'https://www.facebook.com/harsh.agarwal.16752', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Why and when to use inheritance?', 'Types of Inheritance in C++', 'Consider the following program:\xa0\xa0']","['Consider a group of vehicles. You need to create classes for Bus, Car and Truck. The methods fuelAmount(), capacity(), applyBrakes() will be same for all of the three classes. If we create these classes avoiding inheritance then we have to write all of these functions in each of the three classes as shown in below figure:\xa0\xa0', '\xa0Using inheritance, we have to write the functions only one time instead of three times as we have inherited rest of the three classes from base class(Vehicle).Implementing inheritance in C++: For creating a sub-class which is inherited from the base class we have to follow the below syntax.\xa0Syntax:\xa0', 'In the above program the ‘Child’ class is publicly inherited from the ‘Parent’ class so the public data members of the class ‘Parent’ will also be inherited by the class ‘Child’.\xa0Modes of Inheritance', 'Note : The private members in the base class cannot be directly accessed in the derived class, while protected members can be directly accessed. For example, Classes B, C and D all contain the variables x, y and z in below example. It is just question of access.\xa0\xa0', 'The below table summarizes the above three modes and shows the access specifier of the members of base class in the sub class when derived in public, protected and private modes:\xa0', '1. Single Inheritance: In single inheritance, a class is allowed to inherit from only one class. i.e. one sub class is inherited by one base class only.', '2. Multiple Inheritance: Multiple Inheritance is a feature of C++ where a class can inherit from more than one classes. i.e one sub class is inherited from more than one base classes.', 'Here, the number of base classes will be separated by a comma (‘, ‘) and access mode for every base class must be specified.\xa0', 'Please visit this link to learn multiple inheritance in details.\xa03. Multilevel Inheritance: In this type of inheritance, a derived class is created from another derived class.', '4. Hierarchical Inheritance: In this type of inheritance, more than one sub class is inherited from a single base class. i.e. more than one derived class is created from a single base class.', '5. Hybrid (Virtual) Inheritance: Hybrid Inheritance is implemented by combining more than one type of inheritance. For example: Combining Hierarchical inheritance and Multiple Inheritance.\xa0Below image shows the combination of hierarchical and multiple inheritance:', '6. A special case of hybrid inheritance : Multipath inheritance:\xa0A derived class with two base classes and these two base classes have one common base class is called multipath inheritance. An ambiguity can arrise in this type of inheritance.\xa0\xa0', 'Note : Still, there are two copies of ClassA in ClassD.Avoiding ambiguity using virtual base class:\xa0']","['The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important feature of Object Oriented Programming.\xa0Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.\xa0Super Class:The class whose properties are inherited by sub class is called Base Class or Super class.\xa0The article is divided into following subtopics:\xa0', 'You can clearly see that above process results in duplication of same code 3 times. This increases the chances of error and data redundancy. To avoid this type of situation, inheritance is used. If we create a class Vehicle and write these three functions in it and inherit the rest of the classes from the vehicle class, then we can simply avoid the duplication of data and increase re-usability. Look at the below diagram in which the three classes are inherited from vehicle class:', 'Here, subclass_name is the name of the sub class, access_mode is the mode in which you want to inherit this sub class for example: public, private etc. and base_class_name is the name of the base class from which you want to inherit the sub class.\xa0Note: A derived class doesn’t inherit access to private data members. However, it does inherit a full parent object, which contains any private members which that class declares.', 'In the above example, both ClassB & ClassC inherit ClassA, they both have single copy of ClassA. However ClassD inherit both ClassB & ClassC, therefore ClassD have two copies of ClassA, one from ClassB and another from ClassC.\xa0If we need to access the data member a of ClassA through the object of ClassD, we must specify the path from which a will be accessed, whether it is from ClassB or ClassC, bco’z compiler can’t differentiate between two copies of ClassA in ClassD.There are 2 ways to avoid this ambiguity:\xa0Avoiding ambiguity using scope resolution operator:\xa0Using scope resolution operator we can manually specify the path from which data member a will be accessed, as shown in statement 3 and 4, in the above example.\xa0', 'According to the above example, ClassD has only one copy of ClassA, therefore, statement 4 will overwrite the value of a, given at statement 3.This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.']","['// C++ program to demonstrate implementation// of Inheritance  #include <bits/stdc++.h>using namespace std; //Base classclass Parent{    public:      int id_p;};  // Sub class inheriting from Base Class(Parent)class Child : public Parent{    public:      int id_c;}; //main functionint main()   {              Child obj1;                  // An object of class child has all data members        // and member functions of class parent        obj1.id_c = 7;        obj1.id_p = 91;        cout << ""Child id is "" <<  obj1.id_c << endl;        cout << ""Parent id is "" <<  obj1.id_p << endl;                 return 0;   }', ""// C++ Implementation to show that a derived class// doesn’t inherit access to private data members.// However, it does inherit a full parent objectclass A{public:    int x;protected:    int y;private:    int z;}; class B : public A{    // x is public    // y is protected    // z is not accessible from B}; class C : protected A{    // x is protected    // y is protected    // z is not accessible from C}; class D : private A    // 'private' is default for classes{    // x is private    // y is private    // z is not accessible from D};"", '// C++ program to explain// Single inheritance#include <iostream>using namespace std; // base classclass Vehicle {  public:    Vehicle()    {      cout << ""This is a Vehicle"" << endl;    }}; // sub class derived from a single base classesclass Car: public Vehicle{ }; // main functionint main(){      // creating object of sub class will    // invoke the constructor of base classes    Car obj;    return 0;}', '// C++ program to explain// multiple inheritance#include <iostream>using namespace std; // first base classclass Vehicle {  public:    Vehicle()    {      cout << ""This is a Vehicle"" << endl;    }}; // second base classclass FourWheeler {  public:    FourWheeler()    {      cout << ""This is a 4 wheeler Vehicle"" << endl;    }}; // sub class derived from two base classesclass Car: public Vehicle, public FourWheeler { }; // main functionint main(){      // creating object of sub class will    // invoke the constructor of base classes    Car obj;    return 0;}', '// C++ program to implement// Multilevel Inheritance#include <iostream>using namespace std; // base classclass Vehicle{  public:    Vehicle()    {      cout << ""This is a Vehicle"" << endl;    }}; // first sub_class derived from class vehicleclass fourWheeler: public Vehicle{  public:    fourWheeler()    {      cout<<""Objects with 4 wheels are vehicles""<<endl;    }};// sub class derived from the derived base class fourWheelerclass Car: public fourWheeler{   public:     Car()     {       cout<<""Car has 4 Wheels""<<endl;     }}; // main functionint main(){      //creating object of sub class will    //invoke the constructor of base classes    Car obj;    return 0;}', '// C++ program to implement// Hierarchical Inheritance#include <iostream>using namespace std; // base classclass Vehicle{  public:    Vehicle()    {      cout << ""This is a Vehicle"" << endl;    }};  // first sub classclass Car: public Vehicle{ }; // second sub classclass Bus: public Vehicle{     }; // main functionint main(){      // creating object of sub class will    // invoke the constructor of base class    Car obj1;    Bus obj2;    return 0;}', '// C++ program for Hybrid Inheritance #include <iostream>using namespace std; // base classclass Vehicle{  public:    Vehicle()    {      cout << ""This is a Vehicle"" << endl;    }}; //base classclass Fare{    public:    Fare()    {        cout<<""Fare of Vehicle\\n"";    }}; // first sub classclass Car: public Vehicle{ }; // second sub classclass Bus: public Vehicle, public Fare{     }; // main functionint main(){      // creating object of sub class will    // invoke the constructor of base class    Bus obj2;    return 0;}', '// C++ program demonstrating ambiguity in Multipath// Inheritance #include <conio.h>#include <iostream.h>class ClassA {public:    int a;}; class ClassB : public ClassA {public:    int b;};class ClassC : public ClassA {public:    int c;}; class ClassD : public ClassB, public ClassC {public:    int d;}; void main(){     ClassD obj;     // obj.a = 10;                   //Statement 1, Error    // obj.a = 100;                 //Statement 2, Error     obj.ClassB::a = 10; // Statement 3    obj.ClassC::a = 100; // Statement 4     obj.b = 20;    obj.c = 30;    obj.d = 40;     cout << ""\\n A from ClassB  : "" << obj.ClassB::a;    cout << ""\\n A from ClassC  : "" << obj.ClassC::a;     cout << ""\\n B : "" << obj.b;    cout << ""\\n C : "" << obj.c;    cout << ""\\n D : "" << obj.d;}', 'obj.ClassB::a = 10;        //Statement 3obj.ClassC::a = 100;      //Statement 4', '#include<iostream.h>     #include<conio.h>      class ClassA     {            public:            int a;     };      class ClassB : virtual public ClassA     {            public:            int b;     };     class ClassC : virtual public ClassA     {            public:            int c;     };      class ClassD : public ClassB, public ClassC     {            public:            int d;     };      void main()     {             ClassD obj;             obj.a = 10;        //Statement 3            obj.a = 100;      //Statement 4             obj.b = 20;            obj.c = 30;            obj.d = 40;             cout<< ""\\n A : ""<< obj.a;            cout<< ""\\n B : ""<< obj.b;            cout<< ""\\n C : ""<< obj.c;            cout<< ""\\n D : ""<< obj.d;      }']","['class subclass_name : access_mode base_class_name\n{\n  //body of subclass\n};', 'Child id is 7\nParent id is 91', 'class subclass_name : access_mode base_class\n{\n  //body of subclass\n};', 'This is a Vehicle', 'class subclass_name : access_mode base_class1, access_mode base_class2, ....\n{\n  //body of subclass\n};', 'This is a Vehicle\nThis is a 4 wheeler Vehicle', 'This is a Vehicle\nObjects with 4 wheels are vehicles\nCar has 4 Wheels', 'This is a Vehicle\nThis is a Vehicle', 'This is a Vehicle\nFare of Vehicle', 'A from ClassB  : 10\nA from ClassC  : 100\nB : 20\nC : 30\nD : 40', 'A : 100\nB : 20\nC : 30\nD : 40']",[],['Why and when to use inheritance?|||Modes of Inheritance|||Types of Inheritance&&&Public mode: If we derive a sub class from a public base class. Then the public member of the base class will become public in the derived class and protected members of the base class will become protected in derived class.|||Protected mode: If we derive a sub class from a Protected base class. Then both public member and protected members of the base class will become protected in derived class.|||Private mode: If we derive a sub class from a Private base class. Then both public member and protected members of the base class will become Private in derived class.']
37,['Polymorphism in C++'],[],[],['https://media.geeksforgeeks.org/wp-content/uploads/20200703160531/Polymorphism-in-CPP.png'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/function-overloading-c/', 'https://www.geeksforgeeks.org/function-overloading-in-c/', 'https://www.geeksforgeeks.org/operator-overloading-c/', 'https://www.geeksforgeeks.org/operator-overloading-c/', 'https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/', 'https://www.geeksforgeeks.org/override-keyword-c/', 'https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/', 'https://www.facebook.com/harsh.agarwal.16752', 'http://www.contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['In C++ polymorphism is mainly divided into two types:', 'To learn runtime polymorphism in details visit this link.']","['In the above example, a single function named func acts differently in three different situations which is the property of polymorphism.', 'In the above example the operator ‘+’ is overloaded. The operator ‘+’ is an addition operator and can add two numbers(integers or floating point) but here the operator is made to perform addition of two imaginary or complex numbers. To learn operator overloading in details visit this link.', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form. A real-life example of polymorphism, a person at the same time can have different characteristics. Like a man at the same time is a father, a husband, an employee. So the same person posses different behavior in different situations. This is called polymorphism. Polymorphism is considered as one of the important features of Object Oriented Programming.']","['// C++ program for function overloading#include <bits/stdc++.h>  using namespace std;class Geeks{    public:          // function with 1 int parameter    void func(int x)    {        cout << ""value of x is "" << x << endl;    }          // function with same name but 1 double parameter    void func(double x)    {        cout << ""value of x is "" << x << endl;    }          // function with same name and 2 int parameters    void func(int x, int y)    {        cout << ""value of x and y is "" << x << "", "" << y << endl;    }};  int main() {          Geeks obj1;          // Which function is called will depend on the parameters passed    // The first \'func\' is called     obj1.func(7);          // The second \'func\' is called    obj1.func(9.132);          // The third \'func\' is called    obj1.func(85,64);    return 0;}', '// CPP program to illustrate// Operator Overloading#include<iostream>using namespace std;   class Complex {private:    int real, imag;public:    Complex(int r = 0, int i =0)  {real = r;   imag = i;}           // This is automatically called when \'+\' is used with    // between two Complex objects    Complex operator + (Complex const &obj) {         Complex res;         res.real = real + obj.real;         res.imag = imag + obj.imag;         return res;    }    void print() { cout << real << "" + i"" << imag << endl; }};   int main(){    Complex c1(10, 5), c2(2, 4);    Complex c3 = c1 + c2; // An example call to ""operator+""    c3.print();}', '// C++ program for function overriding  #include <bits/stdc++.h>using namespace std;  class base{public:    virtual void print ()    { cout<< ""print base class"" <<endl; }       void show ()    { cout<< ""show base class"" <<endl; }};   class derived:public base{public:    void print () //print () is already virtual function in derived class, we could also declared as virtual void print () explicitly    { cout<< ""print derived class"" <<endl; }       void show ()    { cout<< ""show derived class"" <<endl; }};  //main functionint main() {    base *bptr;    derived d;    bptr = &d;           //virtual function, binded at runtime (Runtime polymorphism)    bptr->print();            // Non-virtual function, binded at compile time    bptr->show();       return 0;}']","['value of x is 7\nvalue of x is 9.132\nvalue of x and y is 85, 64', '12 + i9', 'print derived class\nshow base class']",[],"['Compile time Polymorphism|||Runtime Polymorphism&&&Function Overloading: When there are multiple functions with same name but different parameters then these functions are said to be overloaded. Functions can be overloaded by change in number of arguments or/and change in type of arguments.Rules of Function Overloading// C++ program for function overloading#include <bits/stdc++.h>using namespace std;class Geeks{public:// function with 1 int parametervoid func(int x){cout << ""value of x is "" << x << endl;}// function with same name but 1 double parametervoid func(double x){cout << ""value of x is "" << x << endl;}// function with same name and 2 int parametersvoid func(int x, int y){cout << ""value of x and y is "" << x << "", "" << y << endl;}};int main() {Geeks obj1;// Which function is called will depend on the parameters passed// The first \'func\' is calledobj1.func(7);// The second \'func\' is calledobj1.func(9.132);// The third \'func\' is calledobj1.func(85,64);return 0;}Output:value of x is 7\nvalue of x is 9.132\nvalue of x and y is 85, 64\nIn the above example, a single function named func acts differently in three different situations which is the property of polymorphism.|||Operator Overloading: C++ also provide option to overload operators. For example, we can make the operator (‘+’) for string class to concatenate two strings. We know that this is the addition operator whose task is to add two operands. So a single operator ‘+’ when placed between integer operands , adds them and when placed between string operands, concatenates them.Example:// CPP program to illustrate// Operator Overloading#include<iostream>using namespace std;class Complex {private:int real, imag;public:Complex(int r = 0, int i =0) {real = r; imag = i;}// This is automatically called when \'+\' is used with// between two Complex objectsComplex operator + (Complex const &obj) {Complex res;res.real = real + obj.real;res.imag = imag + obj.imag;return res;}void print() { cout << real << "" + i"" << imag << endl; }};int main(){Complex c1(10, 5), c2(2, 4);Complex c3 = c1 + c2; // An example call to ""operator+""c3.print();}Output:12 + i9\nIn the above example the operator ‘+’ is overloaded. The operator ‘+’ is an addition operator and can add two numbers(integers or floating point) but here the operator is made to perform addition of two imaginary or complex numbers. To learn operator overloading in details visit this link.&&&Function overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.// C++ program for function overriding#include <bits/stdc++.h>using namespace std;class base{public:virtual void print (){ cout<< ""print base class"" <<endl; }void show (){ cout<< ""show base class"" <<endl; }};class derived:public base{public:void print () //print () is already virtual function in derived class, we could also declared as virtual void print () explicitly{ cout<< ""print derived class"" <<endl; }void show (){ cout<< ""show derived class"" <<endl; }};//main functionint main(){base *bptr;derived d;bptr = &d;//virtual function, binded at runtime (Runtime polymorphism)bptr->print();// Non-virtual function, binded at compile timebptr->show();return 0;}Output:print derived class\nshow base class\nTo learn runtime polymorphism in details visit this link.&&&&&&Compile time polymorphism: This type of polymorphism is achieved by function overloading or operator overloading.Function Overloading: When there are multiple functions with same name but different parameters then these functions are said to be overloaded. Functions can be overloaded by change in number of arguments or/and change in type of arguments.Rules of Function Overloading// C++ program for function overloading#include <bits/stdc++.h>using namespace std;class Geeks{public:// function with 1 int parametervoid func(int x){cout << ""value of x is "" << x << endl;}// function with same name but 1 double parametervoid func(double x){cout << ""value of x is "" << x << endl;}// function with same name and 2 int parametersvoid func(int x, int y){cout << ""value of x and y is "" << x << "", "" << y << endl;}};int main() {Geeks obj1;// Which function is called will depend on the parameters passed// The first \'func\' is calledobj1.func(7);// The second \'func\' is calledobj1.func(9.132);// The third \'func\' is calledobj1.func(85,64);return 0;}Output:value of x is 7\nvalue of x is 9.132\nvalue of x and y is 85, 64\nIn the above example, a single function named func acts differently in three different situations which is the property of polymorphism.Operator Overloading: C++ also provide option to overload operators. For example, we can make the operator (‘+’) for string class to concatenate two strings. We know that this is the addition operator whose task is to add two operands. So a single operator ‘+’ when placed between integer operands , adds them and when placed between string operands, concatenates them.Example:// CPP program to illustrate// Operator Overloading#include<iostream>using namespace std;class Complex {private:int real, imag;public:Complex(int r = 0, int i =0) {real = r; imag = i;}// This is automatically called when \'+\' is used with// between two Complex objectsComplex operator + (Complex const &obj) {Complex res;res.real = real + obj.real;res.imag = imag + obj.imag;return res;}void print() { cout << real << "" + i"" << imag << endl; }};int main(){Complex c1(10, 5), c2(2, 4);Complex c3 = c1 + c2; // An example call to ""operator+""c3.print();}Output:12 + i9\nIn the above example the operator ‘+’ is overloaded. The operator ‘+’ is an addition operator and can add two numbers(integers or floating point) but here the operator is made to perform addition of two imaginary or complex numbers. To learn operator overloading in details visit this link.|||Function Overloading: When there are multiple functions with same name but different parameters then these functions are said to be overloaded. Functions can be overloaded by change in number of arguments or/and change in type of arguments.Rules of Function Overloading// C++ program for function overloading#include <bits/stdc++.h>using namespace std;class Geeks{public:// function with 1 int parametervoid func(int x){cout << ""value of x is "" << x << endl;}// function with same name but 1 double parametervoid func(double x){cout << ""value of x is "" << x << endl;}// function with same name and 2 int parametersvoid func(int x, int y){cout << ""value of x and y is "" << x << "", "" << y << endl;}};int main() {Geeks obj1;// Which function is called will depend on the parameters passed// The first \'func\' is calledobj1.func(7);// The second \'func\' is calledobj1.func(9.132);// The third \'func\' is calledobj1.func(85,64);return 0;}Output:value of x is 7\nvalue of x is 9.132\nvalue of x and y is 85, 64\nIn the above example, a single function named func acts differently in three different situations which is the property of polymorphism.|||Operator Overloading: C++ also provide option to overload operators. For example, we can make the operator (‘+’) for string class to concatenate two strings. We know that this is the addition operator whose task is to add two operands. So a single operator ‘+’ when placed between integer operands , adds them and when placed between string operands, concatenates them.Example:// CPP program to illustrate// Operator Overloading#include<iostream>using namespace std;class Complex {private:int real, imag;public:Complex(int r = 0, int i =0) {real = r; imag = i;}// This is automatically called when \'+\' is used with// between two Complex objectsComplex operator + (Complex const &obj) {Complex res;res.real = real + obj.real;res.imag = imag + obj.imag;return res;}void print() { cout << real << "" + i"" << imag << endl; }};int main(){Complex c1(10, 5), c2(2, 4);Complex c3 = c1 + c2; // An example call to ""operator+""c3.print();}Output:12 + i9\nIn the above example the operator ‘+’ is overloaded. The operator ‘+’ is an addition operator and can add two numbers(integers or floating point) but here the operator is made to perform addition of two imaginary or complex numbers. To learn operator overloading in details visit this link.|||Runtime polymorphism: This type of polymorphism is achieved by Function Overriding.Function overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.// C++ program for function overriding#include <bits/stdc++.h>using namespace std;class base{public:virtual void print (){ cout<< ""print base class"" <<endl; }void show (){ cout<< ""show base class"" <<endl; }};class derived:public base{public:void print () //print () is already virtual function in derived class, we could also declared as virtual void print () explicitly{ cout<< ""print derived class"" <<endl; }void show (){ cout<< ""show derived class"" <<endl; }};//main functionint main(){base *bptr;derived d;bptr = &d;//virtual function, binded at runtime (Runtime polymorphism)bptr->print();// Non-virtual function, binded at compile timebptr->show();return 0;}Output:print derived class\nshow base class\nTo learn runtime polymorphism in details visit this link.|||Function overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.// C++ program for function overriding#include <bits/stdc++.h>using namespace std;class base{public:virtual void print (){ cout<< ""print base class"" <<endl; }void show (){ cout<< ""show base class"" <<endl; }};class derived:public base{public:void print () //print () is already virtual function in derived class, we could also declared as virtual void print () explicitly{ cout<< ""print derived class"" <<endl; }void show (){ cout<< ""show derived class"" <<endl; }};//main functionint main(){base *bptr;derived d;bptr = &d;//virtual function, binded at runtime (Runtime polymorphism)bptr->print();// Non-virtual function, binded at compile timebptr->show();return 0;}Output:print derived class\nshow base class\nTo learn runtime polymorphism in details visit this link.&&&']"
38,['Encapsulation in C++'],[],[],['https://media.geeksforgeeks.org/wp-content/uploads/Encapsulation-in-C-1.jpg'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/access-modifiers-in-c/', 'https://www.facebook.com/harsh.agarwal.16752', 'https://write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']",['Role of access specifiers in encapsulation'],"['Encapsulation also lead to data abstraction or hiding. As using encapsulation also hides the data. In the above example the data of any of the section like sales, finance or accounts is hidden from any other section.', 'In C++ encapsulation can be implemented using Class and access modifiers. Look at the below program:', 'In the above program the variable x is made private. This variable can be accessed and manipulated only using the functions get() and set() which are present inside the class. Thus we can say that here, the variable x and the functions get() and set() are binded together which is nothing but encapsulation.', 'As we have seen in above example, access specifiers plays an important role in implementing encapsulation in C++. The process of implementing encapsulation can be sub-divided into two steps:', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['In normal terms Encapsulation is defined as wrapping up of data and information under a single unit. In Object Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulates them.Consider a real life example of encapsulation, in a company there are different sections like the accounts section, finance section, sales section etc. The finance section handles all the financial transactions and keep records of all the data related to finance. Similarly the sales section handles all the sales related activities and keep records of all the sales. Now there may arise a situation when for some reason an official from finance section needs all the data about sales in a particular month. In this case, he is not allowed to directly access the data of sales section. He will first have to contact some other officer in the sales section and then request him to give the particular data. This is what encapsulation is. Here the data of sales section and the employees that can manipulate them are wrapped under a single name “sales section”.']",['// c++ program to explain// Encapsulation  #include<iostream>using namespace std;  class Encapsulation{    private:        // data hidden from outside world        int x;              public:        // function to set value of         // variable x        void set(int a)        {            x =a;        }                  // function to return value of        // variable x        int get()        {            return x;        }};  // main functionint main(){    Encapsulation obj;          obj.set(5);          cout<<obj.get();    return 0;}'],['5'],[],['The data members should be labeled as private using the private access specifiers|||The member function which manipulates the data members should be labeled as public using the public access specifier']
39,['Abstraction in C++'],[],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.facebook.com/harsh.agarwal.16752', 'http://contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']","['Abstraction using access specifiers', 'Advantages of Data Abstraction:']","['Data abstraction is one of the most essential and important feature of object oriented programming in C++. Abstraction means displaying only essential information and hiding the details. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation.', 'Access specifiers are the main pillar of implementing abstraction in C++. We can use access specifiers to enforce restrictions on class members. For example:', 'We can easily implement abstraction using the above two features provided by access specifiers. Say, the members that defines the internal implementation can be marked as private in a class. And the important information needed to be given to the outside world can be marked as public. And these public members can access the private members as they are inside the class.', 'You can see in the above program we are not allowed to access the variables a and b directly, however one can call the function set() to set the values in a and b and the function display() to display the values of a and b.', 'This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['Consider a real life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of car or applying brakes will stop the car but he does not know about how on pressing accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.Abstraction using Classes: We can implement Abstraction in C++ using classes. Class helps us to group data members and member functions using available access specifiers. A Class can decide which data member will be visible to outside world and which is not.', 'Abstraction in Header files: One more type of abstraction in C++ can be header files. For example, consider the pow() method present in math.h header file. Whenever we need to calculate power of a number, we simply call the function pow() present in the math.h header file and pass the numbers as arguments without knowing the underlying algorithm according to which the function is actually calculating power of numbers.']","['#include <iostream>using namespace std;  class implementAbstraction{    private:        int a, b;      public:              // method to set values of         // private members        void set(int x, int y)        {            a = x;            b = y;        }                  void display()        {            cout<<""a = "" <<a << endl;            cout<<""b = "" << b << endl;        }};  int main() {    implementAbstraction obj;    obj.set(10, 20);    obj.display();    return 0;}']",['a = 10\nb = 20'],[],"['Members declared as public in a class, can be accessed from anywhere in the program.|||Members declared as private in a class, can be accessed only from within the class. They are not allowed to be accessed from any part of code outside the class.&&&Helps the user to avoid writing the low level code|||Avoids code duplication and increases reusability.|||Can change internal implementation of class independently without affecting the user.|||Helps to increase security of an application or program as only important details are provided to the user.']"
40,['Function Overloading in C++'],"['CPP', 'How \xa0Function Overloading works?']",[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/g-fact-75/', 'https://www.geeksforgeeks.org/function-overloading-in-c/', 'https://www.geeksforgeeks.org/function-overloading-and-const-functions/', 'https://www.geeksforgeeks.org/function-overloading-vs-function-overriding-in-cpp/', 'https://www.geeksforgeeks.org/tag/cpp-overloading/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['When a function name is overloaded with different jobs it is called Function Overloading.', 'In Function Overloading “Function” name should be the same and the arguments should be different.', 'Function overloading can be considered as an example of polymorphism feature in C++.', 'Following is a simple C++ example to demonstrate function overloading.', '\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0->Char, Unsigned char, and short are promoted to an int.', '\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0->Float is promoted to double', '\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0->C++ tries to find a match through the standard conversion.']","['Function overloading is a feature of object oriented programming where two or more functions can have the same name but different parameters.', 'Recent articles on function overloading in C++Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']",[],"['#include <iostream>using namespace std; void print(int i) {  cout << "" Here is int "" << i << endl;}void print(double  f) {  cout << "" Here is float "" << f << endl;}void print(char const *c) {  cout << "" Here is char* "" << c << endl;} int main() {  print(10);  print(10.10);  print(""ten"");  return 0;}']",['Here is int 10 \nHere is float 10.1 \nHere is char* ten'],[],['Exact match:- (Function name and Parameter)|||If a not exact match is found:–&&&If no match found:&&&ELSE ERROR 🙁&&&&&&Function overloading and return type|||Functions that cannot be overloaded in C++|||Function overloading and const keyword|||Function Overloading vs Function Overriding in C++&&&']
41,['Operator Overloading in C++'],"['CPP', 'CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'http://www.stroustrup.com/bs_faq2.html#overload-dot', 'https://www.geeksforgeeks.org/assignment-operator-overloading-in-c/', 'https://www.geeksforgeeks.org/c-plus-plus-gq/operator-overloading-gq/', 'http://en.wikipedia.org/wiki/Operator_overloading', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['A simple and complete example\xa0\xa0'],"['What is the difference between operator functions and normal functions?\xa0Operator functions are same as normal functions. The only differences are, name of an operator function is always operator keyword followed by symbol of operator and operator functions are called when the corresponding operator is used.\xa0Following is an example of global operator function.\xa0\xa0', 'Can we overload all operators?\xa0Almost all operators can be overloaded except few. Following is the list of operators that cannot be overloaded.\xa0', 'Overloaded conversion operators must be a member method. Other operators can either be member method or global method.4) Any constructor that can be called with a single argument works as a conversion constructor, means it can also be used for implicit conversion to the class being constructed.\xa0\xa0', 'We will soon be discussing overloading of some important operators like new, delete, comma, function call, arrow, etc.Quiz on Operator OverloadingReferences:\xa0http://en.wikipedia.org/wiki/Operator_overloadingPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['In C++, we can make operators to work for user defined classes. This means C++ has the ability to provide the operators with a special meaning for a data type, this ability is known as operator overloading. For example, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +. Other example classes where arithmetic operators may be overloaded are Complex Number, Fractional Number, Big Integer, etc.', 'Why can’t . (dot), ::, ?: and sizeof be overloaded?\xa0See this for answers from Stroustrup himself.\xa0Important points about operator overloading\xa01) For operator overloading to work, at least one of the operands must be a user defined class object.2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment operator does assign all members of right side to the left side and works fine most of the cases (this behavior is same as copy constructor). See this for more details.\xa03) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.\xa0\xa0']","['#include <iostream>using namespace std; class Complex {private:    int real, imag;public:    Complex(int r = 0, int i = 0)  {real = r;   imag = i;}         // This is automatically called when \'+\' is used with    // between two Complex objects    Complex operator + (Complex const &obj) {         Complex res;         res.real = real + obj.real;         res.imag = imag + obj.imag;         return res;    }    void print() { cout << real << "" + i"" << imag << endl; }}; int main(){    Complex c1(10, 5), c2(2, 4);    Complex c3 = c1 + c2;    c3.print();}', '#include<iostream>using namespace std; class Complex {private:    int real, imag;public:    Complex(int r = 0, int i = 0)  {real = r;   imag = i;}    void print() { cout << real << "" + i"" << imag << endl; } // The global operator function is made friend of this class so// that it can access private membersfriend Complex operator + (Complex const &, Complex const &);};  Complex operator + (Complex const &c1, Complex const &c2){     return Complex(c1.real + c2.real, c1.imag + c2.imag);}  int main(){    Complex c1(10, 5), c2(2, 4);    Complex c3 = c1 + c2;    c3.print();    return 0;}', '#include <iostream>using namespace std;class Fraction{    int num, den;public:    Fraction(int n, int d) { num = n; den = d; }     // conversion operator: return float value of fraction    operator float() const {        return float(num) / float(den);    }}; int main() {    Fraction f(2, 5);    float val = f;    cout << val << endl;    return 0;}', '#include <iostream>using namespace std; class Point{private:    int x, y;public:    Point(int i = 0, int j = 0) {        x = i;  y = j;    }    void print() {        cout << "" x = "" <<  x << "", y = "" << y << endl;    }}; int main() {    Point t(20, 20);    t.print();    t = 30;   // Member x of t becomes 30    t.print();    return 0;}']","['12 + i9', '12 + i9', '. (dot) \n   :: \n   ?: \n   sizeof', '0.4', 'x = 20, y = 20\n x = 30, y = 0']",[],[]
42,['Constructors in C++'],"['CPP', 'CPP', 'CPP']",[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191128195435/CPP-Constructors.png'],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/c-internals-default-constructors-set-1/', 'https://www.geeksforgeeks.org/constructor-overloading-c/', 'https://www.geeksforgeeks.org/copy-constructor-in-cpp/', 'https://www.geeksforgeeks.org/destructors-c/', 'https://www.geeksforgeeks.org/c-plus-plus-gq/constructors-gq/', 'https://www.geeksforgeeks.org/output-c-programs-set-26-constructors/', 'https://www.geeksforgeeks.org/output-c-programs-set-27-constructors-destructors/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['A constructor is different from normal functions in following ways:\xa0', 'Related Articles :\xa0']","['What is constructor?\xa0A constructor is a special type of member function of a class which initializes objects of a class. In C++, Constructor is automatically called when object(instance of class) create. It is special member function of the class because it does not have any return type.How constructors are different from a normal member function?', '1. Default Constructors: Default constructor is the constructor which doesn’t take any argument. It has no parameters.', 'Note: Even if we do not define any constructor explicitly, the compiler will automatically provide a default constructor implicitly.', '2. Parameterized Constructors: It is possible to pass arguments to constructors. Typically, these arguments help initialize an object when it is created. To create a parameterized constructor, simply add parameters to it the way you would to any other function. When you define the constructor’s body, use the parameters to initialize the object.\xa0', 'When an object is declared in a parameterized constructor, the initial values have to be passed as arguments to the constructor function. The normal way of object declaration may not work. The constructors can be called explicitly or implicitly.', '3. Copy Constructor: A copy constructor is a member function which initializes an object using another object of the same class. Detailed article on Copy Constructor.', 'Whenever we define one or more non-default constructors( with parameters ) for a class, a default constructor( without parameters ) should also be explicitly defined as the compiler will not provide a default constructor in this case. However, it is not necessary but it’s considered to be the best practice to always define a default constructor.\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']","['Let us understand the types of constructors in C++ by taking a real-world example. Suppose you went to a shop to buy a marker. When you want to buy a marker, what are the options? The first one you go to a shop and say give me a marker. So just saying give me a marker mean that you did not set which brand name and which color, you didn’t mention anything just say you want a marker. So when we said just I want a marker so whatever the frequently sold marker is there in the market or in his shop he will simply hand over that. And this is what a default constructor is! The second method you go to a shop and say I want a marker a red in color and XYZ brand. So you are mentioning this and he will give you that marker. So in this case you have given the parameters. And this is what a parameterized constructor is! Then the third one you go to a shop and say I want a marker like this(a physical marker on your hand). So the shopkeeper will see that marker. Okay, and he will give a new marker for you. So copy of that marker. And that’s what copy constructor is!Types of Constructors']","['// Cpp program to illustrate the// concept of Constructors#include <iostream>using namespace std; class construct{public:    int a, b;     // Default Constructor    construct()    {        a = 10;        b = 20;    }}; int main(){    // Default constructor called automatically    // when the object is created    construct c;    cout << ""a: "" << c.a << endl         << ""b: "" << c.b;    return 1;}', '// CPP program to illustrate// parameterized constructors#include <iostream>using namespace std; class Point{private:    int x, y; public:    // Parameterized Constructor    Point(int x1, int y1)    {        x = x1;        y = y1;    }     int getX()    {        return x;    }    int getY()    {        return y;    }}; int main(){    // Constructor called    Point p1(10, 15);     // Access values assigned by constructor    cout << ""p1.x = "" << p1.getX() << "", p1.y = "" << p1.getY();     return 0;}', '// Illustration#include <iostream>using namespace std; class point{private:  double x, y; public:     // Non-default Constructor &  // default Constructor  point (double px, double py)  {    x = px, y = py;  }}; int main(void){   // Define an array of size  // 10 & of type point  // This line will cause error  point a[10];   // Remove above line and program  // will compile without error  point b = point(5, 6);}']","['a: 10\nb: 20', 'p1.x = 10, p1.y = 15', 'Example e = Example(0, 50); // Explicit call\n\n Example e(0, 50);           // Implicit call', 'Error: point (double px, double py): expects 2 arguments, 0 provided']",[],"['Constructor has same name as the class itself|||Constructors don’t have return type|||A constructor is automatically called when an object is created.|||It must be placed in public section of class.|||If we do not specify a constructor, C++ compiler generates a default constructor for object (expects no parameters and has an empty body).&&&Uses of Parameterized constructor:It is used to initialize the various data elements of different objects with different values when they are created.It is used to overload constructors.|||It is used to initialize the various data elements of different objects with different values when they are created.|||It is used to overload constructors.|||Can we have more than one constructor in a class?   Yes, It is called Constructor Overloading.&&&Destructors in C++|||quiz on constructors in C++|||Output of C++ programs | Set 26 (Constructors)|||Output of C++ programs | Set 27(Constructors and Destructors)&&&&&&It is used to initialize the various data elements of different objects with different values when they are created.|||It is used to overload constructors.&&&']"
43,['Copy Constructor in C++'],"['CPP', 'CPP', 'CPP', 'CPP']",[],"['https://media.geeksforgeeks.org/wp-content/uploads/copy-constructor.png', 'https://media.geeksforgeeks.org/wp-content/uploads/copy-constructor1.png']",[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/constructors-c/', 'http://en.wikipedia.org/wiki/Return_value_optimization', 'https://www.geeksforgeeks.org/g-fact-13/', 'https://www.geeksforgeeks.org/copy-constructor-vs-assignment-operator-in-c/', 'https://www.geeksforgeeks.org/copy-constructor-argument-const/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['Following is a simple example of copy constructor.\xa0'],"['We have discussed an introduction to Constructors in C++. In this post, the copy constructor is discussed.What is a copy constructor?\xa0A copy constructor is a member function that initializes an object using another object of the same class. A copy constructor has the following general function prototype:\xa0', 'Deep copy is possible only with user defined copy constructor. In user defined copy constructor, we make sure that pointers (or references) of copied object point to new memory locations.\xa0\xa0', 'Copy constructor vs Assignment Operator\xa0Which of the following two statements call copy constructor and which one calls assignment operator?\xa0', 'What would be the problem if we remove copy constructor from above code?\xa0If we remove copy constructor from the above program, we don’t get the expected output. The changes made to str2 reflect in str1 as well which is never expected.\xa0\xa0']","['When is\xa0 copy constructor called?\xa0In C++, a Copy Constructor may be called in the following cases:\xa01. When an object of the class is returned by value.\xa02. When an object of the class is passed (to a function) by value as an argument.\xa03. When an object is constructed based on another object of the same class.\xa04. When the compiler generates a temporary object.It is, however, not guaranteed that a copy constructor will be called in all these cases, because the C++ Standard allows the compiler to optimize the copy away in certain cases, one example is the return value optimization (sometimes referred to as RVO).\xa0Source: https://www.geeksforgeeks.org/g-fact-13/\xa0\xa0When is a user-defined copy constructor needed?\xa0If we don’t define our own copy constructor, the C++ compiler creates a default copy constructor for each class which does a member-wise copy between objects. The compiler created copy constructor works fine in general. We need to define our own copy constructor only if an object has pointers or any runtime allocation of the resource like filehandle, a network connection..etc.The default constructor does only shallow copy.\xa0', 'Copy constructor is called when a new object is created from an existing object, as a copy of the existing object. Assignment operator is called when an already initialized object is assigned a new value from another existing object. In the above example (1) calls copy constructor and (2) calls assignment operator. See this for more details.Write an example class where copy constructor is needed?\xa0Following is a complete C++ program to demonstrate use of Copy constructor. In the following String class, we must write copy constructor.\xa0', 'Can we make copy constructor private?\xa0Yes, a copy constructor can be made private. When we make a copy constructor private in a class, objects of that class become non-copyable. This is particularly useful when our class has pointers or dynamically allocated resources. In such situations, we can either write our own copy constructor like above String example or make a private copy constructor so that users get compiler errors rather than surprises at runtime.\xa0Why argument to a copy constructor must be passed as a reference?\xa0A copy constructor is called when an object is passed by value. Copy constructor itself is a function. So if we pass an argument by value in a copy constructor, a call to copy constructor would be made to call copy constructor which becomes a non-terminating chain of calls. Therefore compiler doesn’t allow parameters to be passed by value.Why argument to a copy constructor should be const?\xa0See https://www.geeksforgeeks.org/copy-constructor-argument-const/\xa0This article is contributed by Shubham Agrawal. If you like GeeksforGeeks and would like to contribute, you can also mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['#include<iostream>using namespace std; class Point{private:    int x, y;public:    Point(int x1, int y1) { x = x1; y = y1; }     // Copy constructor    Point(const Point &p1) {x = p1.x; y = p1.y; }     int getX()            {  return x; }    int getY()            {  return y; }}; int main(){    Point p1(10, 15); // Normal constructor is called here    Point p2 = p1; // Copy constructor is called here     // Let us access values assigned by constructors    cout << ""p1.x = "" << p1.getX() << "", p1.y = "" << p1.getY();    cout << ""\\np2.x = "" << p2.getX() << "", p2.y = "" << p2.getY();     return 0;}', 'MyClass t1, t2;MyClass t3 = t1;  // ----> (1)t2 = t1;          // -----> (2)', '#include<iostream>#include<cstring>using namespace std; class String{private:    char *s;    int size;public:    String(const char *str = NULL); // constructor    ~String() { delete [] s;  }// destructor    String(const String&); // copy constructor    void print() { cout << s << endl; } // Function to print string    void change(const char *);  // Function to change}; String::String(const char *str){    size = strlen(str);    s = new char[size+1];    strcpy(s, str);} void String::change(const char *str){    delete [] s;    size = strlen(str);    s = new char[size+1];    strcpy(s, str);} String::String(const String& old_str){    size = old_str.size;    s = new char[size+1];    strcpy(s, old_str.s);} int main(){    String str1(""GeeksQuiz"");    String str2 = str1;     str1.print(); // what is printed ?    str2.print();     str2.change(""GeeksforGeeks"");     str1.print(); // what is printed now ?    str2.print();    return 0;}', '#include<iostream>#include<cstring>using namespace std; class String{private:    char *s;    int size;public:    String(const char *str = NULL); // constructor    ~String() { delete [] s;  }// destructor    void print() { cout << s << endl; }    void change(const char *);  // Function to change}; String::String(const char *str){    size = strlen(str);    s = new char[size+1];    strcpy(s, str);} void String::change(const char *str){    delete [] s;    size = strlen(str);    s = new char[size+1];    strcpy(s, str);} int main(){    String str1(""GeeksQuiz"");    String str2 = str1;     str1.print(); // what is printed ?    str2.print();     str2.change(""GeeksforGeeks"");     str1.print(); // what is printed now ?    str2.print();    return 0;}']","['ClassName (const ClassName &old_obj);', 'p1.x = 10, p1.y = 15\np2.x = 10, p2.y = 15', 'GeeksQuiz\nGeeksQuiz\nGeeksQuiz\nGeeksforGeeks', 'GeeksQuiz\nGeeksQuiz\nGeeksforGeeks\nGeeksforGeeks']",[],[]
44,['Destructors in C++'],['CPP'],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/g-fact-37/', 'https://www.geeksforgeeks.org/c-plus-plus-gq/destructors-gq/', 'https://www.geeksforgeeks.org/constructors-c/', 'https://www.geeksforgeeks.org/virtual-destructor/', 'https://www.geeksforgeeks.org/pure-virtual-destructor-c/', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']",['Properties of Destructor:'],"['What is a destructor?\xa0Destructor is an instance member function which is invoked automatically whenever an object is going to be destroyed. Meaning, a destructor is the last function that is going to be called before an object is destroyed.', 'The thing is to be noted here, if the object is created by using new or the constructor uses new to allocate memory which resides in the heap memory or the free store, the destructor should use delete to free the memory. \xa0\xa0', 'When is destructor called?\xa0A destructor function is called automatically when the object goes out of scope:\xa0(1) the function ends\xa0(2) the program ends\xa0(3) a block containing local variables ends\xa0(4) a delete operator is called\xa0\xa0', 'How are destructors different from a normal member function?\xa0Destructors have same name as the class preceded by a tilde (~)\xa0Destructors don’t take any argument and don’t return anything', 'Can there be more than one destructor in a class?\xa0No, there can only one destructor in a class with classname preceded by ~, no parameters and no return type.', 'Can a destructor be virtual?\xa0Yes, In fact, it is always a good idea to make destructors virtual in base class when we have a virtual function. See virtual destructor for more details.\xa0You may like to take a quiz on destructors.', 'Related Articles :\xa0Constructors in C++\xa0Virtual Destructor\xa0Pure virtual destructor in C++Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['When do we need to write a user-defined destructor?\xa0If we do not write our own destructor in class, compiler creates a default destructor for us. The default destructor works fine unless we have dynamically allocated memory or pointer in class. When a class contains a pointer to memory allocated in class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leak.']","['class String {private:    char* s;    int size; public:    String(char*); // constructor    ~String(); // destructor}; String::String(char* c){    size = strlen(c);    s = new char[size + 1];    strcpy(s, c);}String::~String() { delete[] s; }']",['~constructor-name();'],[],['Destructor function is automatically invoked when the objects are destroyed.|||It cannot be declared static or const.|||The destructor does not have arguments.|||It has no return type not even void.|||An object of a class with a Destructor cannot become a member of the union.|||A destructor should be declared in the public section of the class.|||The programmer cannot access the address of destructor.']
45,['Default Constructors in C++'],['C++'],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['What is the significance of the default constructor?\xa0', 'They are used to create objects, which do not have any having specific initial value.\xa0', 'Is a default constructor automatically provided?']","['A constructor without any arguments or with the default value for every argument is said to be\xa0the Default constructor.\xa0', 'If no constructors are explicitly declared in the class, a default constructor is provided automatically.\xa0', 'Will there be any code inserted by the compiler to the user implemented default constructor behind the scenes?', 'Consider a class derived from another class with the default constructor, or a class containing another class object with the default constructor. The compiler needs to insert code to call the default constructors of the base class/embedded object.', 'There are different scenarios in which the compiler needs to insert code to ensure some necessary\xa0initialization as per language requirements. We will have them in upcoming posts. Our objective is to be aware of C++ internals, not to use them incorrectly.\xa0Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['The compiler will implicitly declare the default constructor if not provided by the programmer, will define it when in need. The compiler-defined default constructor is required to do certain\xa0initialization\xa0of class internals. It will not touch the\xa0data members or plain old data types (aggregates like an array, structures, etc…). However, the compiler generates code for the default constructor based on the situation.']","['// CPP program to demonstrate Default constructors#include <iostream>using namespace std;  class Base {public:    // compiler ""declares"" constructor};  class A {public:    // User defined constructor    A() { cout << ""A Constructor"" << endl; }      // uninitialized    int size;};  class B : public A {    // compiler defines default constructor of B, and    // inserts stub to call A constructor      // compiler won\'t initialize any data of A};  class C : public A {public:    C()    {        // User defined default constructor of C        // Compiler inserts stub to call A\'s constructor        cout << ""C Constructor"" << endl;          // compiler won\'t initialize any data of A    }};  class D {public:    D()    {        // User defined default constructor of D        // a - constructor to be called, compiler inserts        // stub to call A constructor        cout << ""D Constructor"" << endl;          // compiler won\'t initialize any data of \'a\'    }  private:    A a;};  // Driver Codeint main(){    Base base;      B b;    C c;    D d;      return 0;}']",['A Constructor\nA Constructor\nC Constructor\nA Constructor\nD Constructor'],[],[]
46,['Private Destructor in C++'],"['CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/access-modifiers-in-c/', 'https://www.geeksforgeeks.org/can-constructor-private-cpp/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['What is the use of private destructor?', 'Predict the Output of the Following Programs:\xa0', 'Now, What do you say about the below program?\xa0', 'Now, What about the Below Program?\xa0', 'Next, What about the below program?\xa0', 'Must Read: Can a Constructor be Private in C++?\xa0']","['Destructors with the access modifier as private are known as Private Destructors. Whenever we want to prevent the destruction of an object, we can make the destructor private.', 'Whenever we want to control the destruction of objects of a class, we make the destructor private. For dynamically created objects, it may happen that you pass a pointer to the object to a function and the function deletes the object. If the object is referred after the function call, the reference will become dangling.', 'The above program compiles and runs fine. Hence, we can say that: It is not a compiler error to create private destructors.\xa0', 'The above program fails in the compilation. The compiler notices that the local variable ‘t’ cannot be destructed because the destructor is private.\xa0', 'The above program works fine. There is no object being constructed, the program just creates a pointer of type “Test *”, so nothing is destructed.', 'The above program also works fine. When something is created using dynamic memory allocation, it is the programmer’s responsibility to delete it. So compiler doesn’t bother.\xa0', 'In the case where the destructor is declared private, an instance of the class can also be created using the malloc() function. The same is implemented in the below program.\xa0', 'The above program also works fine. However, The below program fails in the compilation. When we call delete, destructor is called.\xa0', 'We noticed in the above programs when a class has a private destructor, only dynamic objects of that class can be created. Following is a way to create classes with private destructors and have a function as a friend of the class. The function can only delete the objects.\xa0\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']",[],"['// CPP program to illustrate// Private Destructor#include <iostream>using namespace std;  class Test {private:    ~Test() {}};int main() {}', '// CPP program to illustrate// Private Destructor#include <iostream>using namespace std;  class Test {private:    ~Test() {}};int main() { Test t; }', '// CPP program to illustrate// Private Destructor#include <iostream>using namespace std;  class Test {private:    ~Test() {}};int main() { Test* t; }', '// CPP program to illustrate// Private Destructor#include <iostream>using namespace std;  class Test {private:    ~Test() {}};int main() { Test* t = new Test; }', '// CPP program to illustrate// Private Destructor  #include <bits/stdc++.h>using namespace std;  class Test {public:    Test() // Constructor    {        cout << ""Constructor called\\n"";    }  private:    ~Test() // Private Destructor    {        cout << ""Destructor called\\n"";    }};  int main(){    Test* t = (Test*)malloc(sizeof(Test));    return 0;}', '// CPP program to illustrate// Private Destructor#include <iostream>using namespace std;  class Test {private:    ~Test() {}};  // Driver Codeint main(){    Test* t = new Test;    delete t;}', '// CPP program to illustrate// Private Destructor#include <iostream>  // A class with private destructorclass Test {private:    ~Test() {}  public:    friend void destructTest(Test*);};  // Only this function can destruct objects of Testvoid destructTest(Test* ptr) { delete ptr; }  int main(){    // create an object    Test* ptr = new Test;      // destruct the object    destructTest(ptr);      return 0;}']",['prog.cpp: In function ‘int main()’:\nprog.cpp:8:5: error: ‘Test::~Test()’ is private\n    ~Test() {}\n    ^\nprog.cpp:10:19: error: within this context\nint main() { Test t; }'],[],[]
47,['Exception Handling in C++'],"['CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Fcplr162.htm', 'https://www.geeksforgeeks.org/g-fact-60/', 'http://www.cplusplus.com/reference/exception/exception/', 'https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/', 'https://www.geeksforgeeks.org/c-plus-plus-gq/exception-handling-gq/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['C++ Exceptions:', 'C++ try and catch:', 'Exception handling in C++ consists of three keywords: try, throw and catch:', 'The try and catch keywords come in pairs:', 'Exception Handling in C++', 'A better way to write above code\xa0', '8) In C++, try-catch blocks can be nested. Also, an exception can be re-thrown using “throw; ”\xa0']","['Why Exception Handling?\xa0Following are main advantages of exception handling over traditional error handling.', '1) Separation of Error Handling code from Normal Code: In traditional error handling codes, there are always if else conditions to handle errors. These conditions and the code to handle errors get mixed up with the normal flow. This makes the code less readable and maintainable. With try catch blocks, the code for error handling becomes separate from the normal flow.', '3) Grouping of Error Types: In C++, both basic types and objects can be thrown as exception. We can create a hierarchy of exception objects, group exceptions in namespaces or classes, categorize them according to types.\xa0', 'When executing C++ code, different errors can occur: coding errors made by the programmer, errors due to wrong input, or other unforeseeable things.', 'When an error occurs, C++ will normally stop and generate an error message. The technical term for this is: C++ will throw an exception (throw an error).', 'The try statement allows you to define a block of code to be tested for errors while it is being executed.', 'The throw keyword throws an exception when a problem is detected, which lets us create a custom error.', 'The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.', 'We use the try block to test some code: If the age variable is less than 18, we will throw an exception, and handle it in our catch block.', 'In the catch block, we catch the error and do something about it. The catch statement takes a parameter: in our example we use an int variable (myNum) (because we are throwing an exception of int type in the try block (age)), to output the value of age.', 'If no error occurs (e.g. if age is 20 instead of 15, meaning it will be be greater than 18), the catch block is skipped:', '1) Following is a simple example to show exception handling in C++. The output of program explains flow of execution of try/catch blocks.\xa0', '2) There is a special catch block called ‘catch all’ catch(…) that can be used to catch all types of exceptions. For example, in the following program, an int is thrown as an exception, but there is no catch block for int, so catch(…) block will be executed.\xa0', '3) Implicit type conversion doesn’t happen for primitive types. For example, in the following program ‘a’ is not implicitly converted to int\xa0', '4) If an exception is thrown and not caught anywhere, the program terminates abnormally. For example, in the following program, a char is thrown, but there is no catch block to catch a char.\xa0\xa0', 'A function can also re-throw a function using same “throw; “. A function can handle a part and can ask the caller to handle remaining.9) When an exception is thrown, all objects created inside the enclosing try block are destructed before the control is transferred to catch block.', '10) You may like to try Quiz on Exception Handling in C++.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['One of the advantages of C++ over C is Exception Handling. Exceptions are run-time anomalies or abnormal conditions that a program encounters during its execution. There are two types of exceptions: a)Synchronous, b)Asynchronous(Ex:which are beyond the program’s control, Disc failure etc). C++ provides following specialized keywords for this purpose.try: represents a block of code that can throw an exception.catch: represents a block of code that is executed when a particular exception is thrown.throw: Used to throw an exception. Also used to list the exceptions that a function throws, but doesn’t handle itself.', '2) Functions/Methods can handle any exceptions they choose: A function can throw many exceptions, but may choose to handle some of them. The other exceptions which are thrown, but not caught can be handled by caller. If the caller chooses not to catch them, then the exceptions are handled by caller of the caller.\xa0In C++, a function can specify the exceptions that it throws using the throw keyword. The caller of this function must handle the exception in some way (either by specifying it again or catching it)', 'We can change this abnormal termination behavior by writing our own unexpected function.5) A derived class exception should be caught before a base class exception. See this for more details.6) Like Java, C++ library has a standard exception class which is base class for all standard exceptions. All objects thrown by components of the standard library are derived from this class. Therefore, all standard exceptions can be caught by catching this type7) Unlike Java, in C++, all exceptions are unchecked. Compiler doesn’t check whether an exception is caught or not (See this for details). For example, in C++, it is not necessary to specify all uncaught exceptions in a function declaration. Although it’s a recommended practice to do so. For example, the following program compiles fine, but ideally signature of fun() should list unchecked exceptions.\xa0', '(Note : The use of Dynamic Exception Specification has been deprecated after C++11, one of the reason maybe because it can randomly abort your program. This can happen when you throw an exception of an another type which is not mentioned in the dynamic exception specification, your program will abort itself, because in that scenario program calls(indrectly) terminate(), and which is by default call abort()).']","['#include <iostream>using namespace std; int main(){   int x = -1;    // Some code   cout << ""Before try \\n"";   try {      cout << ""Inside try \\n"";      if (x < 0)      {         throw x;         cout << ""After throw (Never executed) \\n"";      }   }   catch (int x ) {      cout << ""Exception Caught \\n"";   }    cout << ""After catch (Will be executed) \\n"";   return 0;}', '#include <iostream>using namespace std; int main(){    try  {       throw 10;    }    catch (char *excp)  {        cout << ""Caught "" << excp;    }    catch (...)  {        cout << ""Default Exception\\n"";    }    return 0;}', '#include <iostream>using namespace std; int main(){    try  {       throw \'a\';    }    catch (int x)  {        cout << ""Caught "" << x;    }    catch (...)  {        cout << ""Default Exception\\n"";    }    return 0;}', '#include <iostream>using namespace std; int main(){    try  {       throw \'a\';    }    catch (int x)  {        cout << ""Caught "";    }    return 0;}', '#include <iostream>using namespace std; // This function signature is fine by the compiler, but not recommended.// Ideally, the function should specify all uncaught exceptions and function// signature should be ""void fun(int *ptr, int x) throw (int *, int)""void fun(int *ptr, int x){    if (ptr == NULL)        throw ptr;    if (x == 0)        throw x;    /* Some functionality */} int main(){    try {       fun(NULL, 0);    }    catch(...) {        cout << ""Caught exception from fun()"";    }    return 0;}', '#include <iostream>using namespace std; // Here we specify the exceptions that this function// throws.void fun(int *ptr, int x) throw (int *, int) // Dynamic Exception specification{    if (ptr == NULL)        throw ptr;    if (x == 0)        throw x;    /* Some functionality */} int main(){    try {       fun(NULL, 0);    }    catch(...) {        cout << ""Caught exception from fun()"";    }    return 0;}', '#include <iostream>using namespace std; int main(){    try {        try {            throw 20;        }        catch (int n) {            cout << ""Handle Partially "";            throw; // Re-throwing an exception        }    }    catch (int n) {        cout << ""Handle remaining "";    }    return 0;}', '#include <iostream>using namespace std; class Test {public:    Test() { cout << ""Constructor of Test "" << endl; }    ~Test() { cout << ""Destructor of Test "" << endl; }}; int main(){    try {        Test t1;        throw 10;    }    catch (int i) {        cout << ""Caught "" << i << endl;    }}']","['Before try\nInside try\nException Caught\nAfter catch (Will be executed)', 'Default Exception', 'Default Exception', ""terminate called after throwing an instance of 'char'\n\nThis application has requested the Runtime to terminate it in an \nunusual way. Please contact the application's support team for \nmore information."", 'Caught exception from fun()', 'Caught exception from fun()', 'Handle Partially Handle remaining', 'Constructor of Test\nDestructor of Test\nCaught 10']",[],[]
48,['Stack Unwinding in C++'],['CPP'],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/exception-handling-c/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['For example, the output of the following program is:\xa0', 'Explanation:', '\xa0Note that the following lines inside f1() and f2() are not executed at all.\xa0', 'Note: Stack Unwinding also happens in Java when exception is not handled in same function.\xa0']","['Stack Unwinding is the process of removing function entries from function call stack at run time. The local objects are destroyed in reverse order in which they were constructed.\xa0', 'If there were some local class objects inside f1() and f2(), destructors for those local objects would have been called in the Stack Unwinding process.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['Stack Unwinding is generally related to Exception Handling. In C++, when an exception occurs, the function call stack is linearly searched for the exception handler, and all the entries before the function with exception handler are removed from the function call stack. So, exception handling involves Stack Unwinding if an exception is not handled in the same function (where it is thrown). Basically, Stack unwinding is a process of calling the destructors (whenever an exception is thrown) for all the automatic objects constructed at run time.\xa0']","['// CPP Program to demonstrate Stack Unwinding#include <iostream>using namespace std;  // A sample function f1() that throws an int exceptionvoid f1() throw(int){    cout << ""\\n f1() Start "";    throw 100;    cout << ""\\n f1() End "";}  // Another sample function f2() that calls f1()void f2() throw(int){    cout << ""\\n f2() Start "";    f1();    cout << ""\\n f2() End "";}  // Another sample function f3() that calls f2() and handles// exception thrown by f1()void f3(){    cout << ""\\n f3() Start "";    try {        f2();    }    catch (int i) {        cout << ""\\n Caught Exception: "" << i;    }    cout << ""\\n f3() End"";}  // Driver Codeint main(){    f3();      getchar();    return 0;}']","['f3() Start \n f2() Start \n f1() Start \n Caught Exception: 100\n f3() End', 'cout<<""\\n f1() End "";  // inside f1()\n\n cout<<""\\n f2() End "";  // inside f2()']",[],"['When f1() throws exception, its entry is removed from the function call stack, because f1() doesn’t contain exception handler for the thrown exception, then next entry in call stack is looked for exception handler.|||The next entry is f2(). Since f2() also doesn’t have a handler, its entry is also removed from the function call stack.|||The next entry in the function call stack is f3(). Since f3() contains an exception handler, the catch block inside f3() is executed, and finally, the code after the catch block is executed.']"
49,['Catching base and derived classes as exceptions'],"['C++', 'C++', 'Java']",[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']",[],"['Exception Handling – catching base and derived classes as exceptions:If both base and derived classes are caught as exceptions then catch block of derived class must appear before the base class.\xa0If we put base class first then the derived class catch block will never be reached. For example, following C++ code prints “Caught Base Exception”\xa0\xa0', 'In the above C++ code, if we change the order of catch statements then both catch statements become reachable. Following is the modified program and it prints “Caught Derived Exception”\xa0', 'In Java, catching a base class exception before derived is not allowed by the compiler itself. In C++, compiler might give warning about it, but compiles the code.\xa0For example, following Java code fails in compilation with error message “exception Derived has already been caught”\xa0\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']",[],"['#include<iostream>using namespace std; class Base {};class Derived: public Base {};int main(){   Derived d;   // some other stuff   try {       // Some monitored code       throw d;   }   catch(Base b) {        cout<<""Caught Base Exception"";   }   catch(Derived d) {  //This catch block is NEVER executed        cout<<""Caught Derived Exception"";   }   getchar();   return 0;}', '#include<iostream>using namespace std; class Base {};class Derived: public Base {};int main(){   Derived d;   // some other stuff   try {       // Some monitored code       throw d;   }   catch(Derived d) {        cout<<""Caught Derived Exception"";   }   catch(Base b) {        cout<<""Caught Base Exception"";   }   getchar();   return 0;}', '//filename Main.javaclass Base extends Exception {}class Derived extends Base  {}public class Main {  public static void main(String args[]) {    try {       throw new Derived();    }    catch(Base b) {}    catch(Derived d) {}  }}']",[],[],[]
50,['Catch block and type conversion in C++'],"['C++', 'C++']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/g-fact-60/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']",['Predict the output of following C++ program.'],"['In the above program, a character ‘x’ is thrown and there is a catch block to catch an int. One might think that the int catch block could be matched by considering ASCII value of ‘x’. But such conversions are not performed for catch blocks. Consider the following program as another example where conversion constructor is not called for thrown object.', 'As a side note, the derived type objects are converted to base type when a derived object is thrown and there is a catch block to catch base type. See this GFact for more details.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']",[],"['#include <iostream>using namespace std; int main(){    try    {        throw \'x\';    }    catch(int x)    {        cout << "" Caught int "" << x;    }    catch(...)    {        cout << ""Default catch block"";    }}', '#include <iostream>using namespace std; class MyExcept1 {}; class MyExcept2{public:     // Conversion constructor    MyExcept2 (const MyExcept1 &e )    {        cout << ""Conversion constructor called"";    }}; int main(){    try    {        MyExcept1 myexp1;        throw myexp1;    }    catch(MyExcept2 e2)    {        cout << ""Caught MyExcept2 "" << endl;    }    catch(...)    {        cout << "" Default catch block "" << endl;    }    return 0;}']","['Default catch block', 'Default catch block']",[],[]
51,['Exception handling and object destruction | Set 1'],[],[],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Predict the output of following C++ program.', 'What happens when an exception is thrown from a constructor? Consider the following program.', 'As an excecise, predict the output of following program.']","['When an exception is thrown, destructors of the objects (whose scope ends with the try block) is automatically called before the catch block gets executed. That is why the above program prints “Destructing an object of Test” before “Caught 10”.', 'Destructors are only called for the completely constructed objects. When constructor of an object throws an exception, destructor for that object is not called.', 'We will be covering more of this topic in a separate post. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['#include <iostream>using namespace std;  class Test {public:  Test() { cout << ""Constructing an object of Test "" << endl; }  ~Test() { cout << ""Destructing an object of Test ""  << endl; }};  int main() {  try {    Test t1;    throw 10;  } catch(int i) {    cout << ""Caught "" << i << endl;  }}', '#include <iostream>using namespace std;  class Test1 {public:  Test1() { cout << ""Constructing an Object of Test1"" << endl; }  ~Test1() { cout << ""Destructing an Object of Test1"" << endl; }};  class Test2 {public:  // Following constructor throws an integer exception  Test2() { cout << ""Constructing an Object of Test2"" << endl;             throw 20; }  ~Test2() { cout << ""Destructing an Object of Test2"" << endl; }};  int main() {  try {    Test1 t1;  // Constructed and destructed    Test2 t2;  // Partially constructed    Test1 t3;  // t3 is not constructed as this statement never gets executed  } catch(int i) {    cout << ""Caught "" << i << endl;  }}', '#include <iostream>using namespace std;  class Test {  static int count;  int id;public:  Test() {    count++;    id = count;    cout << ""Constructing object number "" << id << endl;    if(id == 4)       throw 4;  }  ~Test() { cout << ""Destructing object number "" << id << endl; }};  int Test::count = 0;  int main() {  try {    Test array[5];  } catch(int i) {    cout << ""Caught "" << i << endl;  }}']","['Constructing an object of Test\n  Destructing an object of Test\n  Caught 10', 'Constructing an Object of Test1\n  Constructing an Object of Test2\n  Destructing an Object of Test1\n  Caught 20']",[],[]
52,['File Handling through C++ Classes'],"['C++', 'C++']",[],['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191129162746/CPP-File-Handling.png'],[],"['https://www.geeksforgeeks.org/medium/', 'https://ide.geeksforgeeks.org/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['For e.g.\xa0\xa0', 'Default Open Modes :\xa0\xa0', 'Problem Statement : To read and write a File in C++.\xa0Examples:\xa0', 'Below is the implementation by using ifstream & ofstream classes.\xa0\xa0', 'Below is the implementation by using fstream class.\xa0']","['In C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile.\xa0ofstream: Stream class to write on files\xa0ifstream: Stream class to read from files\xa0fstream: Stream class to both read and write from/to files.\xa0', 'Now the first step to open the particular file for read or write operation. We can open file by\xa01. passing file name in constructor at the time of object creation\xa02. using the open method\xa0', 'Open File by using constructor\xa0ifstream (const char* filename, ios_base::openmode mode = ios_base::in);\xa0ifstream fin(filename, openmode) by default openmode = ios::in\xa0ifstream fin(“filename”);', 'Open File by using open method\xa0Calling of default constructor\xa0ifstream fin;fin.open(filename, openmode)\xa0fin.open(“filename”);\xa0\xa0']",[],"['/* File Handling with C++ using ifstream & ofstream class object*//* To write the Content in File*//* Then to read the content of file*/#include <iostream> /* fstream header file for ifstream, ofstream,  fstream classes */#include <fstream> using namespace std; // Driver Codeint main(){    // Creation of ofstream class object    ofstream fout;     string line;     // by default ios::out mode, automatically deletes    // the content of file. To append the content, open in ios:app    // fout.open(""sample.txt"", ios::app)    fout.open(""sample.txt"");     // Execute a loop If file successfully opened    while (fout) {         // Read a Line from standard input        getline(cin, line);         // Press -1 to exit        if (line == ""-1"")            break;         // Write line in file        fout << line << endl;    }     // Close the File    fout.close();     // Creation of ifstream class object to read the file    ifstream fin;     // by default open mode = ios::in mode    fin.open(""sample.txt"");     // Execute a loop until EOF (End of File)    while (fin) {         // Read a Line from File        getline(fin, line);         // Print line in Console        cout << line << endl;    }     // Close the file    fin.close();     return 0;}', '/* File Handling with C++ using fstream class object *//* To write the Content in File *//* Then to read the content of file*/#include <iostream> /* fstream header file for ifstream, ofstream,   fstream classes */#include <fstream> using namespace std; // Driver Codeint main(){    // Creation of fstream class object    fstream fio;     string line;     // by default openmode = ios::in|ios::out mode    // Automatically overwrites the content of file, To append    // the content, open in ios:app    // fio.open(""sample.txt"", ios::in|ios::out|ios::app)    // ios::trunc mode delete all content before open    fio.open(""sample.txt"", ios::trunc | ios::out | ios::in);     // Execute a loop If file successfully Opened    while (fio) {         // Read a Line from standard input        getline(cin, line);         // Press -1 to exit        if (line == ""-1"")            break;         // Write line in file        fio << line << endl;    }     // Execute a loop until EOF (End of File)    // point read pointer at beginning of file    fio.seekg(0, ios::beg);     while (fio) {         // Read a Line from File        getline(fio, line);         // Print line in Console        cout << line << endl;    }     // Close the file    fio.close();     return 0;}']",['Input : \nWelcome in GeeksforGeeks. Best way to learn things.\n-1\nOutput : \nWelcome in GeeksforGeeks. Best way to learn things.'],"['in *|||input|||File open for reading: the internal stream buffer supports input operations.&&&out|||output|||File open for writing: the internal stream buffer supports output operations.&&&binary|||binary|||Operations are performed in binary mode rather than text.&&&ate|||at end|||The output position starts at the end of the file.&&&app|||append|||All output operations happen at the end of the file, appending to its existing contents.&&&trunc|||truncate|||Any contents that existed in the file before it is open are discarded.', 'ifstream|||ios::in&&&ofstream|||ios::out&&&fstream|||ios::in | ios::out']",[]
53,['Read/Write Class Objects from/to File in C++'],['C++'],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.linkedin.com/in/rohit-thapliyal-515b5913a/', 'http://www.contribute.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']",['Examples:\xa0'],['Given a file “Input.txt” in which every line has values same as instance variables of a class.\xa0Read the values into the class’s object and do necessary operations.Theory :\xa0'],"['This article is contributed by Rohit Thapliyal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// C++ program to demonstrate read/write of class// objects in C++.#include <iostream>#include <fstream>using namespace std; // Class to define the propertiesclass Contestant {public:    // Instance variables    string Name;    int Age, Ratings;     // Function declaration of input() to input info    int input();     // Function declaration of output_highest_rated() to    // extract info from file Data Base    int output_highest_rated();}; // Function definition of input() to input infoint Contestant::input(){    // Object to write in file    ofstream file_obj;     // Opening file in append mode    file_obj.open(""Input.txt"", ios::app);     // Object of class contestant to input data in file    Contestant obj;     // Feeding appropriate data in variables    string str = ""Michael"";    int age = 18, ratings = 2500;     // Assigning data into object    obj.Name = str;    obj.Age = age;    obj.Ratings = ratings;     // Writing the object\'s data in file    file_obj.write((char*)&obj, sizeof(obj));     // Feeding appropriate data in variables    str = ""Terry"";    age = 21;    ratings = 3200;     // Assigning data into object    obj.Name = str;    obj.Age = age;    obj.Ratings = ratings;     // Writing the object\'s data in file    file_obj.write((char*)&obj, sizeof(obj));     return 0;} // Function definition of output_highest_rated() to// extract info from file Data Baseint Contestant::output_highest_rated(){    // Object to read from file    ifstream file_obj;     // Opening file in input mode    file_obj.open(""Input.txt"", ios::in);     // Object of class contestant to input data in file    Contestant obj;     // Reading from file into object ""obj""    file_obj.read((char*)&obj, sizeof(obj));     // max to store maximum ratings    int max = 0;     // Highest_rated stores the name of highest rated contestant    string Highest_rated;     // Checking till we have the feed    while (!file_obj.eof()) {        // Assigning max ratings        if (obj.Ratings > max) {            max = obj.Ratings;            Highest_rated = obj.Name;        }         // Checking further        file_obj.read((char*)&obj, sizeof(obj));    }     // Output is the highest rated contestant    cout << Highest_rated;    return 0;} // Driver codeint main(){    // Creating object of the class    Contestant object;     // Inputting the data    object.input();     // Extracting the max rated contestant    object.output_highest_rated();     return 0;}']","[""The data transfer is usually done using '>>'\nand <<' operators. But if you have\na class with 4 data members and want \nto write all 4 data members from its\nobject directly to a file or vice-versa, \nwe can do that using following syntax :\n\nTo write object's data members in a file :\n// Here file_obj is an object of ofstream\nfile_obj.write((char *) & class_obj, sizeof(class_obj));\n\nTo read file's data members into an object :\n// Here file_obj is an object of ifstream\nfile_obj.read((char *) & class_obj, sizeof(class_obj));"", 'Input : \nInput.txt :\nMichael 19 1806\nKemp 24 2114\nTerry 21 2400\nOperation : Print the name of the highest \n            rated programmer.\n\nOutput : \nTerry', 'Terry']",[],[]
54,['C++ program to create a file'],[],[],['https://media.geeksforgeeks.org/wp-content/uploads/gfg-21.png'],[],"['https://www.geeksforgeeks.org/medium/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['Below is the program to create a file:'],"['Problem Statement: Write a C++ program to create a file using file handling and check whether the file is created successfully or not. If a file is created successfully then it should print “File Created Successfully” otherwise should print some error message.', 'Approach: Declare a stream class file and open that text file in writing mode. If the file is not present then it creates a new text file. Now check if the file does not exist or not created then return false otherwise return true.']",[],"['// C++ implementation to create a file#include <bits/stdc++.h>using namespace std;  // Driver codeint main(){    // fstream is Stream class to both    // read and write from/to files.    // file is object of fstream class   fstream file;     // opening file ""Gfg.txt""   // in out(write) mode   // ios::out Open for output operations.   file.open(""Gfg.txt"",ios::out);     // If no file is created, then   // show the error message.   if(!file)   {       cout<<""Error in creating file!!!"";       return 0;   }     cout<<""File created successfully."";     // closing the file.   // The reason you need to call close()   // at the end of the loop is that trying   // to open a new file without closing the   // first file will fail.   file.close();     return 0;}']",[],[],[]
55,['CSV file management using C++'],"['CREATE', 'READ', 'UPDATE', 'DELETE']",[],"['https://media.geeksforgeeks.org/wp-content/uploads/create-1.png', 'https://media.geeksforgeeks.org/wp-content/uploads/read.png', 'https://media.geeksforgeeks.org/wp-content/uploads/update.png', 'https://media.geeksforgeeks.org/wp-content/uploads/delete-1.png']",[],"['https://www.geeksforgeeks.org/hard/', 'https://www.geeksforgeeks.org/file-handling-c-classes/', 'https://www.geeksforgeeks.org/stringstream-c-applications/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['This article discusses about how to create, update and delete records in a CSV file:', 'In reading a CSV file, the following approach is implemented:-', 'The following approach is implemented while updating a record:-', 'The following approach is implemented while deleting a record']","['CSV is a simple file format used to store tabular data such as a spreadsheet or a database. CSV stands for Comma Separated Values. The data fields in a CSV file are separated/delimited by a comma (‘, ‘) and the individual rows are separated by a newline (‘\\n’). CSV File management in C++ is similar to text-type file management, except for a few modifications.', 'Note: Here, a reportcard.csv file has been created to store the student’s roll number, name and marks in math, physics, chemistry and biology.', 'The create operation is similar to creating a text file, i.e. input data from the user and write it to the csv file using the file pointer and appropriate delimiters(‘, ‘) between different columns and ‘\\n’ after the end of each row.', 'Note: Here, since whatever data reading from the file, is stored in string format, so always convert string to the required datatype before comparing or calculating, etc.', 'References: https://www.geeksforgeeks.org/file-handling-c-classes/, https://www.geeksforgeeks.org/stringstream-c-applications/']",[],"['void create(){    // file pointer    fstream fout;      // opens an existing csv file or creates a new file.    fout.open(""reportcard.csv"", ios::out | ios::app);      cout << ""Enter the details of 5 students:""         << "" roll name maths phy chem bio"";    << endl;      int i, roll, phy, chem, math, bio;    string name;      // Read the input    for (i = 0; i < 5; i++) {          cin >> roll            >> name            >> math            >> phy            >> chem            >> bio;          // Insert the data to file        fout << roll << "", ""             << name << "", ""             << math << "", ""             << phy << "", ""             << chem << "", ""             << bio             << ""\\n"";    }}', 'void read_record(){      // File pointer    fstream fin;      // Open an existing file    fin.open(""reportcard.csv"", ios::in);      // Get the roll number    // of which the data is required    int rollnum, roll2, count = 0;    cout << ""Enter the roll number ""         << ""of the student to display details: "";    cin >> rollnum;      // Read the Data from the file    // as String Vector    vector<string> row;    string line, word, temp;      while (fin >> temp) {          row.clear();          // read an entire row and        // store it in a string variable \'line\'        getline(fin, line);          // used for breaking words        stringstream s(line);          // read every column data of a row and        // store it in a string variable, \'word\'        while (getline(s, word, \', \')) {              // add all the column data            // of a row to a vector            row.push_back(word);        }          // convert string to integer for comparision        roll2 = stoi(row[0]);          // Compare the roll number        if (roll2 == rollnum) {              // Print the found data            count = 1;            cout << ""Details of Roll "" << row[0] << "" : \\n"";            cout << ""Name: "" << row[1] << ""\\n"";            cout << ""Maths: "" << row[2] << ""\\n"";            cout << ""Physics: "" << row[3] << ""\\n"";            cout << ""Chemistry: "" << row[4] << ""\\n"";            cout << ""Biology: "" << row[5] << ""\\n"";            break;        }    }    if (count == 0)        cout << ""Record not found\\n"";}', 'void update_recode(){      // File pointer    fstream fin, fout;      // Open an existing record    fin.open(""reportcard.csv"", ios::in);      // Create a new file to store updated data    fout.open(""reportcardnew.csv"", ios::out);      int rollnum, roll1, marks, count = 0, i;    char sub;    int index, new_marks;    string line, word;    vector<string> row;      // Get the roll number from the user    cout << ""Enter the roll number ""         << ""of the record to be updated: "";    cin >> rollnum;      // Get the data to be updated    cout << ""Enter the subject ""         << ""to be updated(M/P/C/B): "";    cin >> sub;      // Determine the index of the subject    // where Maths has index 2,    // Physics has index 3, and so on    if (sub == \'m\' || sub == \'M\')        index = 2;    else if (sub == \'p\' || sub == \'P\')        index = 3;    else if (sub == \'c\' || sub == \'C\')        index = 4;    else if (sub == \'b\' || sub == \'B\')        index = 5;    else {        cout << ""Wrong choice.Enter again\\n"";        update_record();    }      // Get the new marks    cout << ""Enter new marks: "";    cin >> new_marks;      // Traverse the file    while (!fin.eof()) {          row.clear();          getline(fin, line);        stringstream s(line);          while (getline(s, word, \', \')) {            row.push_back(word);        }          roll1 = stoi(row[0]);        int row_size = row.size();          if (roll1 == rollnum) {            count = 1;            stringstream convert;              // sending a number as a stream into output string            convert << new_marks;              // the str() converts number into string            row[index] = convert.str();              if (!fin.eof()) {                for (i = 0; i < row_size - 1; i++) {                      // write the updated data                    // into a new file \'reportcardnew.csv\'                    // using fout                    fout << row[i] << "", "";                }                  fout << row[row_size - 1] << ""\\n"";            }        }        else {            if (!fin.eof()) {                for (i = 0; i < row_size - 1; i++) {                      // writing other existing records                    // into the new file using fout.                    fout << row[i] << "", "";                }                  // the last column data ends with a \'\\n\'                fout << row[row_size - 1] << ""\\n"";            }        }        if (fin.eof())            break;    }    if (count == 0)        cout << ""Record not found\\n"";      fin.close();    fout.close();      // removing the existing file    remove(""reportcard.csv"");      // renaming the updated file with the existing file name    rename(""reportcardnew.csv"", ""reportcard.csv"");}', 'void delete_record(){      // Open FIle pointers    fstream fin, fout;      // Open the existing file    fin.open(""reportcard.csv"", ios::in);      // Create a new file to store the non-deleted data    fout.open(""reportcardnew.csv"", ios::out);      int rollnum, roll1, marks, count = 0, i;    char sub;    int index, new_marks;    string line, word;    vector<string> row;      // Get the roll number    // to decide the data to be deleted    cout << ""Enter the roll number ""         << ""of the record to be deleted: "";    cin >> rollnum;      // Check if this record exists    // If exists, leave it and    // add all other data to the new file    while (!fin.eof()) {          row.clear();        getline(fin, line);        stringstream s(line);          while (getline(s, word, \', \')) {            row.push_back(word);        }          int row_size = row.size();        roll1 = stoi(row[0]);          // writing all records,        // except the record to be deleted,        // into the new file \'reportcardnew.csv\'        // using fout pointer        if (roll1 != rollnum) {            if (!fin.eof()) {                for (i = 0; i < row_size - 1; i++) {                    fout << row[i] << "", "";                }                fout << row[row_size - 1] << ""\\n"";            }        }        else {            count = 1;        }        if (fin.eof())            break;    }    if (count == 1)        cout << ""Record deleted\\n"";    else        cout << ""Record not found\\n"";      // Close the pointers    fin.close();    fout.close();      // removing the existing file    remove(""reportcard.csv"");      // renaming the new file with the existing file name    rename(""reportcardnew.csv"", ""reportcard.csv"");}']",[],[],"['Create operation:The create operation is similar to creating a text file, i.e. input data from the user and write it to the csv file using the file pointer and appropriate delimiters(‘, ‘) between different columns and ‘\\n’ after the end of each row.CREATEvoid create(){// file pointerfstream fout;// opens an existing csv file or creates a new file.fout.open(""reportcard.csv"", ios::out | ios::app);cout << ""Enter the details of 5 students:""<< "" roll name maths phy chem bio"";<< endl;int i, roll, phy, chem, math, bio;string name;// Read the inputfor (i = 0; i < 5; i++) {cin >> roll>> name>> math>> phy>> chem>> bio;// Insert the data to filefout << roll << "", ""<< name << "", ""<< math << "", ""<< phy << "", ""<< chem << "", ""<< bio<< ""\\n"";}}Output:|||Read a particular record:In reading a CSV file, the following approach is implemented:-Using getline(), file pointer and ‘\\n’ as the delimiter, read an entire row and store it in a string variable.Using stringstream, separate the row into words.Now using getline(), the stringstream pointer and ‘, ‘ as the delimiter, read every word in the row, store it in a string variable and push that variable to a string vector.Retrieve a required column data through row[index]. Here, row[0] always stores the roll number of a student, so compare row[0] with the roll number input by the user, and if it matches, display the details of the student and break from the loop.Note: Here, since whatever data reading from the file, is stored in string format, so always convert string to the required datatype before comparing or calculating, etc.READvoid read_record(){// File pointerfstream fin;// Open an existing filefin.open(""reportcard.csv"", ios::in);// Get the roll number// of which the data is requiredint rollnum, roll2, count = 0;cout << ""Enter the roll number ""<< ""of the student to display details: "";cin >> rollnum;// Read the Data from the file// as String Vectorvector<string> row;string line, word, temp;while (fin >> temp) {row.clear();// read an entire row and// store it in a string variable \'line\'getline(fin, line);// used for breaking wordsstringstream s(line);// read every column data of a row and// store it in a string variable, \'word\'while (getline(s, word, \', \')) {// add all the column data// of a row to a vectorrow.push_back(word);}// convert string to integer for comparisionroll2 = stoi(row[0]);// Compare the roll numberif (roll2 == rollnum) {// Print the found datacount = 1;cout << ""Details of Roll "" << row[0] << "" : \\n"";cout << ""Name: "" << row[1] << ""\\n"";cout << ""Maths: "" << row[2] << ""\\n"";cout << ""Physics: "" << row[3] << ""\\n"";cout << ""Chemistry: "" << row[4] << ""\\n"";cout << ""Biology: "" << row[5] << ""\\n"";break;}}if (count == 0)cout << ""Record not found\\n"";}Output:|||Using getline(), file pointer and ‘\\n’ as the delimiter, read an entire row and store it in a string variable.|||Using stringstream, separate the row into words.|||Now using getline(), the stringstream pointer and ‘, ‘ as the delimiter, read every word in the row, store it in a string variable and push that variable to a string vector.|||Retrieve a required column data through row[index]. Here, row[0] always stores the roll number of a student, so compare row[0] with the roll number input by the user, and if it matches, display the details of the student and break from the loop.|||Update a record:The following approach is implemented while updating a record:-Read data from a file and compare it with the user input, as explained under read operation.Ask the user to enter new values for the record to be updated.update row[index] with the new data. Here, index refers to the required column field that is to be updated.Write the updated record and all other records into a new file(‘reportcardnew.csv’).At the end of operation, remove the old file and rename the new file, with the old file name, i.e. remove ‘reportcard.csv’ and rename ‘reportcardnew.csv’ with ‘reportcard.csv’UPDATEvoid update_recode(){// File pointerfstream fin, fout;// Open an existing recordfin.open(""reportcard.csv"", ios::in);// Create a new file to store updated datafout.open(""reportcardnew.csv"", ios::out);int rollnum, roll1, marks, count = 0, i;char sub;int index, new_marks;string line, word;vector<string> row;// Get the roll number from the usercout << ""Enter the roll number ""<< ""of the record to be updated: "";cin >> rollnum;// Get the data to be updatedcout << ""Enter the subject ""<< ""to be updated(M/P/C/B): "";cin >> sub;// Determine the index of the subject// where Maths has index 2,// Physics has index 3, and so onif (sub == \'m\' || sub == \'M\')index = 2;else if (sub == \'p\' || sub == \'P\')index = 3;else if (sub == \'c\' || sub == \'C\')index = 4;else if (sub == \'b\' || sub == \'B\')index = 5;else {cout << ""Wrong choice.Enter again\\n"";update_record();}// Get the new markscout << ""Enter new marks: "";cin >> new_marks;// Traverse the filewhile (!fin.eof()) {row.clear();getline(fin, line);stringstream s(line);while (getline(s, word, \', \')) {row.push_back(word);}roll1 = stoi(row[0]);int row_size = row.size();if (roll1 == rollnum) {count = 1;stringstream convert;// sending a number as a stream into output stringconvert << new_marks;// the str() converts number into stringrow[index] = convert.str();if (!fin.eof()) {for (i = 0; i < row_size - 1; i++) {// write the updated data// into a new file \'reportcardnew.csv\'// using foutfout << row[i] << "", "";}fout << row[row_size - 1] << ""\\n"";}}else {if (!fin.eof()) {for (i = 0; i < row_size - 1; i++) {// writing other existing records// into the new file using fout.fout << row[i] << "", "";}// the last column data ends with a \'\\n\'fout << row[row_size - 1] << ""\\n"";}}if (fin.eof())break;}if (count == 0)cout << ""Record not found\\n"";fin.close();fout.close();// removing the existing fileremove(""reportcard.csv"");// renaming the updated file with the existing file namerename(""reportcardnew.csv"", ""reportcard.csv"");}Output:|||Read data from a file and compare it with the user input, as explained under read operation.|||Ask the user to enter new values for the record to be updated.|||update row[index] with the new data. Here, index refers to the required column field that is to be updated.|||Write the updated record and all other records into a new file(‘reportcardnew.csv’).|||At the end of operation, remove the old file and rename the new file, with the old file name, i.e. remove ‘reportcard.csv’ and rename ‘reportcardnew.csv’ with ‘reportcard.csv’|||Delete a record:The following approach is implemented while deleting a recordRead data from a file and compare it with the user input, as explained under read and update operation.Write all the updated records, except the data to be deleted, onto a new file(reportcardnew.csv).Remove the old file, and rename the new file, with the old file’s name.DELETEvoid delete_record(){// Open FIle pointersfstream fin, fout;// Open the existing filefin.open(""reportcard.csv"", ios::in);// Create a new file to store the non-deleted datafout.open(""reportcardnew.csv"", ios::out);int rollnum, roll1, marks, count = 0, i;char sub;int index, new_marks;string line, word;vector<string> row;// Get the roll number// to decide the data to be deletedcout << ""Enter the roll number ""<< ""of the record to be deleted: "";cin >> rollnum;// Check if this record exists// If exists, leave it and// add all other data to the new filewhile (!fin.eof()) {row.clear();getline(fin, line);stringstream s(line);while (getline(s, word, \', \')) {row.push_back(word);}int row_size = row.size();roll1 = stoi(row[0]);// writing all records,// except the record to be deleted,// into the new file \'reportcardnew.csv\'// using fout pointerif (roll1 != rollnum) {if (!fin.eof()) {for (i = 0; i < row_size - 1; i++) {fout << row[i] << "", "";}fout << row[row_size - 1] << ""\\n"";}}else {count = 1;}if (fin.eof())break;}if (count == 1)cout << ""Record deleted\\n"";elsecout << ""Record not found\\n"";// Close the pointersfin.close();fout.close();// removing the existing fileremove(""reportcard.csv"");// renaming the new file with the existing file namerename(""reportcardnew.csv"", ""reportcard.csv"");}Output:|||Read data from a file and compare it with the user input, as explained under read and update operation.|||Write all the updated records, except the data to be deleted, onto a new file(reportcardnew.csv).|||Remove the old file, and rename the new file, with the old file’s name.&&&Using getline(), file pointer and ‘\\n’ as the delimiter, read an entire row and store it in a string variable.|||Using stringstream, separate the row into words.|||Now using getline(), the stringstream pointer and ‘, ‘ as the delimiter, read every word in the row, store it in a string variable and push that variable to a string vector.|||Retrieve a required column data through row[index]. Here, row[0] always stores the roll number of a student, so compare row[0] with the roll number input by the user, and if it matches, display the details of the student and break from the loop.&&&Read data from a file and compare it with the user input, as explained under read operation.|||Ask the user to enter new values for the record to be updated.|||update row[index] with the new data. Here, index refers to the required column field that is to be updated.|||Write the updated record and all other records into a new file(‘reportcardnew.csv’).|||At the end of operation, remove the old file and rename the new file, with the old file name, i.e. remove ‘reportcard.csv’ and rename ‘reportcardnew.csv’ with ‘reportcard.csv’&&&Read data from a file and compare it with the user input, as explained under read and update operation.|||Write all the updated records, except the data to be deleted, onto a new file(reportcardnew.csv).|||Remove the old file, and rename the new file, with the old file’s name.']"
56,['Four File Handling Hacks which every C/C++ Programmer should know'],[],[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile3.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile1.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile2.png']",[],"['https://www.geeksforgeeks.org/medium/', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile3.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile1.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/cfile2.png', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['We will discuss about four file hacks listed as below-', 'Screenshot before executing the program :', 'Screenshot after executing the program :']","['This article is contributed by Rachit Belwariar. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']",[],"['// A C++ Program to demonstrate the// four file hacks every C/C++ must know  // Note that we are assuming that the files// are present in the same file as the program// before doing the below four hacks#include<stdio.h>#include<stdlib.h>#include<stdbool.h>  // A Function to get the file sizeunsigned long long int fileSize(const char *filename){    // Open the file    FILE *fh = fopen(filename, ""rb"");    fseek(fh, 0, SEEK_END);    unsigned long long int size = ftell(fh);    fclose(fh);      return (size);}  // A Function to check if the file exists or notbool fileExists(const char * fname){    FILE *file;    if (file = fopen(fname, ""r""))    {        fclose(file);        return (true);    }    return (false);}  // Driver Program to test above functionsint main(){    printf(""%llu Bytes\\n"", fileSize(""Passwords.txt""));    printf(""%llu Bytes\\n"", fileSize(""Notes.docx""));      if (fileExists(""OldData.txt"") == true )        printf(""The File exists\\n"");    else        printf(""The File doen\'t exist\\n"");      rename(""Videos"", ""English_Videos"");    rename(""Songs"", ""English_Songs"");      remove(""OldData.txt"");    remove(""Notes.docx"");      if (fileExists(""OldData.txt"") == true )        printf(""The File exists\\n"");    else        printf(""The File doesn\'t exist\\n"");      return 0;}']",[],[],['Rename – Rename a file using C/C++|||Remove – Remove a file using C/C++|||File Size – Get the file size using C/C++|||Check existence – Check whether a file exists or not in C/C++']
57,['The C++ Standard Template Library (STL)'],[],[],"['https://media.geeksforgeeks.org/wp-content/uploads/20191111161536/Screenshot-from-2019-11-11-16-13-18.png', 'https://media.geeksforgeeks.org/wp-content/uploads/20191111161627/Screenshot-from-2019-11-11-16-15-07.png']",['https://www.youtube.com/embed/qK8PliD5FJY?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/templates-cpp/', 'https://www.geeksforgeeks.org/sort-algorithms-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/c-magicians-stl-algorithms/', 'https://www.geeksforgeeks.org/useful-array-algorithms-in-c-stl/', 'https://www.geeksforgeeks.org/stdpartition-in-c-stl/', 'https://www.geeksforgeeks.org/std-valarray-class-c/', 'https://www.geeksforgeeks.org/vector-in-cpp-stl/', 'https://www.geeksforgeeks.org/list-cpp-stl/', 'https://www.geeksforgeeks.org/deque-cpp-stl/', 'https://www.geeksforgeeks.org/array-class-c/', 'https://www.geeksforgeeks.org/forward-list-c-set-1-introduction-important-functions/', 'https://www.geeksforgeeks.org/queue-cpp-stl/', 'https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/', 'https://www.geeksforgeeks.org/stack-in-cpp-stl/', 'https://www.geeksforgeeks.org/set-in-cpp-stl/', 'https://www.geeksforgeeks.org/multiset-in-cpp-stl/', 'https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/multimap-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/unordered_set-in-cpp-stl/', 'https://www.geeksforgeeks.org/unordered_multiset-and-its-uses/', 'https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/', 'https://www.geeksforgeeks.org/unordered_multimap-and-its-application/', 'https://www.geeksforgeeks.org/functors-in-cpp/', 'https://www.geeksforgeeks.org/iterators-c-stl/', 'https://www.geeksforgeeks.org/pair-in-cpp-stl/', 'https://practice.geeksforgeeks.org/courses/cpp-stl', 'http://en.cppreference.com/w/cpp/', 'http://cs.stmarys.ca/~porter/csc/ref/stl/headers.html', 'http://www.cplusplus.com/reference/stl/', 'https://www.geeksforgeeks.org/tag/stl/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['STL has four components', 'Algorithms', 'Containers', 'Flowchart of Adaptive Containers and Unordered Containers', 'Flowchart of Sequence conatiners and ordered containers', 'Utility Library', 'Defined in header <utility>.', 'References:', 'Recent articles on STL!']","['The Standard Template Library (STL) is a set of C++ template classes to provide common programming data structures and functions such as lists, stacks, arrays, etc. It is a library of container classes, algorithms, and iterators. It is a generalized library and so, its components are parameterized. A working knowledge of template classes is a prerequisite for working with STL.', 'The header algorithm defines a collection of functions especially designed to be used on ranges of elements.They act on containers and provide means for various operations for the contents of the containers.', 'Containers or container classes store objects and data. There are in total seven standard “first-class” container classes and three container adaptor classes and only seven header files that provide access to these containers or container adaptors.', 'The STL includes classes that overload the function call operator. Instances of such classes are called function objects or functors. Functors allow the working of the associated function to be customized with the help of parameters to be passed.', 'As the name suggests, iterators are used for working upon a sequence of values. They are the major feature that allow generality in STL.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']","['To master C++ Standard Template Library (STL) in the most efficient and effective way, do check out this C++ STL Online Course by GeeksforGeeks. The course covers the basics of C++ and in-depth explanations to all C++ STL containers, iterators, etc along with video explanations of a few problems. Also, you’ll learn to use STL inbuilt classes and functions in order to implement some of the complex data structures and perform operations on them conveniently.']",[],[],[],['Algorithms|||Containers|||Functions|||Iterators&&&AlgorithmSortingSearchingImportant STL AlgorithmsUseful Array algorithmsPartition Operations|||Sorting|||Searching|||Important STL Algorithms|||Useful Array algorithms|||Partition Operations|||Numericvalarray class|||valarray class&&&Sorting|||Searching|||Important STL Algorithms|||Useful Array algorithms|||Partition Operations&&&valarray class&&&Sequence Containers: implement data structures which can be accessed in a sequential manner.vectorlistdequearraysforward_list( Introduced in C++11)|||vector|||list|||deque|||arrays|||forward_list( Introduced in C++11)|||Container Adaptors : provide a different interface for sequential containers.queuepriority_queuestack|||queue|||priority_queue|||stack|||Associative Containers : implement sorted data structures that can be quickly searched (O(log n) complexity).setmultisetmapmultimap|||set|||multiset|||map|||multimap|||Unordered Associative Containers : implement unordered data structures that can be quickly searchedunordered_set (Introduced in C++11)unordered_multiset (Introduced in C++11)unordered_map (Introduced in C++11)unordered_multimap (Introduced in C++11)Flowchart of Adaptive Containers and Unordered ContainersFlowchart of Sequence conatiners and ordered containers|||unordered_set (Introduced in C++11)|||unordered_multiset (Introduced in C++11)|||unordered_map (Introduced in C++11)|||unordered_multimap (Introduced in C++11)&&&vector|||list|||deque|||arrays|||forward_list( Introduced in C++11)&&&queue|||priority_queue|||stack&&&set|||multiset|||map|||multimap&&&unordered_set (Introduced in C++11)|||unordered_multiset (Introduced in C++11)|||unordered_map (Introduced in C++11)|||unordered_multimap (Introduced in C++11)&&&Functors&&&Iterators&&&pair&&&http://en.cppreference.com/w/cpp|||http://cs.stmarys.ca/~porter/csc/ref/stl/headers.html|||http://www.cplusplus.com/reference/stl/']
58,['Containers in C++ STL (Standard Template Library)'],[],[],"['https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200219122316/Adaptive-and-Unordered-Containers-in-C-STL.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200219122358/Sequence-and-Unordered-Containers-in-C-STL.png']",[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/array-class-c/', 'https://www.geeksforgeeks.org/vector-in-cpp-stl/', 'https://www.geeksforgeeks.org/deque-cpp-stl/', 'https://www.geeksforgeeks.org/forward-list-c-set-1-introduction-important-functions/', 'https://www.geeksforgeeks.org/list-cpp-stl/', 'https://www.geeksforgeeks.org/set-in-cpp-stl/', 'https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/multiset-in-cpp-stl/', 'https://www.geeksforgeeks.org/multimap-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/unorderd_set-stl-uses/', 'https://www.geeksforgeeks.org/unordered_map-in-stl-and-its-applications/', 'https://www.geeksforgeeks.org/unordered_multiset-and-its-uses/', 'https://www.geeksforgeeks.org/unordered_multimap-and-its-application/', 'https://www.geeksforgeeks.org/stack-in-cpp-stl/', 'https://www.geeksforgeeks.org/queue-cpp-stl/', 'https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200219122316/Adaptive-and-Unordered-Containers-in-C-STL.png', 'https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200219122358/Sequence-and-Unordered-Containers-in-C-STL.png', 'https://www.geeksforgeeks.org/tag/stl/', 'https://www.geeksforgeeks.org/category/cpp/', 'https://practice.geeksforgeeks.org/', 'https://www.geeksforgeeks.org/quiz-corner-gq/#C++%20Programming%20Mock%20Tests', 'https://www.geeksforgeeks.org/c-plus-plus/', 'https://practice.geeksforgeeks.org/courses/cpp-stl', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Sequence containers', 'Sequence containers implement data structures that can be accessed sequentially.\xa0', 'Associative containers', 'Unordered associative containers', 'Container adaptors', 'Container adaptors provide a different interface for sequential containers.\xa0', 'Flowchart of Adaptive Containers and Unordered Containers', 'Flowchart of Sequence conatiners and ordered containers', 'More Useful Links\xa0']","['A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows great flexibility in the types supported as elements.\xa0', 'The container manages the storage space for its elements and provides member functions to access them, either directly or through iterators (reference objects with similar properties to pointers).\xa0', 'Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).\xa0', 'Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).\xa0']","['To master C++ Standard Template Library (STL) in the most efficient and effective way, do check out this C++ STL Online Course by GeeksforGeeks. The course covers the basics of C++ and in-depth explanations to all C++ STL containers, iterators, etc along with video explanations of a few problems. Also, you’ll learn to use STL inbuilt classes and functions in order to implement some of the complex data structures and perform operations on them conveniently.']",[],[],[],"['array: Static contiguous array (class template)|||vector: Dynamic contiguous array (class template)|||deque: Double-ended queue (class template)|||forward_list: Singly-linked list (class template)|||list: Doubly-linked list (class template)&&&Set: Collection of unique keys, sorted by keys(class template)|||Map: Collection of key-value pairs, sorted by keys, keys are unique (class template).|||multiset: Collection of keys, sorted by keys (class template)|||multimap: Collection of key-value pairs, sorted by keys(class template)&&&unordered_set: Collection of unique keys, hashed by keys. (class template)|||unordered_map: Collection of key-value pairs, hashed by keys, keys are unique. (class template)|||unordered_multiset: Collection of keys, hashed by keys (class template)|||unordered_multimap: Collection of key-value pairs, hashed by keys (class template)&&&stack: Adapts a container to provide stack (LIFO data structure) (class template).|||queue: Adapts a container to provide queue (FIFO data structure) (class template).|||priority_queue: Adapts a container to provide priority queue (class template).&&&Recent Articles on C++ STL|||Recent Articles on C++ STL|||Coding Practice Platform|||Multiple Choice Questions|||All articles in C++ Category']"
59,['Pair in C++ Standard Template Library (STL)'],"['CPP', 'CPP', 'C++', 'CPP', 'CPP', 'CPP', 'CPP']","['Member Functions', 'operators(=, ==, !=, >=, <=) in Pair']",[],['https://www.youtube.com/embed/4LG1H3x6-BQ?list=PLqM7alHXFySGg6GSRmE2INI4k8fPH5qVB'],"['https://www.geeksforgeeks.org/easy/', 'http://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/tuples-in-c/', 'http://www.write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']","['Initializing a Pair: We can also initialize a pair.\xa0', 'Different ways to initialize pair: \xa0', 'Another way to initialize a pair is by using the make_pair() function.\xa0', 'Another valid syntax to declare pair is:', 'Note: If not initialized, the first value of the pair gets automatically initialized.\xa0', 'Code to illustrate Functions in Pair:', 'We can use operators with pairs as well.', '1) using equal(=): It assigns a new object for a pair object.\xa0Syntax:']","['Pair is used to combine together two values that may be different in type. Pair provides a way to store two heterogeneous objects as a single unit. It is basically used if we want to store tuples. The pair container is a simple container defined in <utility> header consisting of two data elements or objects.\xa0', '1) make_pair(): This template function allows to create a value pair without writing the types explicitly.\xa0', '2) swap: This function swaps the contents of one pair object with the contents of another pair object. The pairs must be of the same type.\xa0', 'For two given pairs say pair1 and pair2 of the same type, the swap function will swap the pair1.first with pair2.first and pair1.second with pair2.second.\xa0', '3) tie(): This function works the same as in tuples. It creates a tuple of lvalue references to its arguments i.e., to unpack the tuple (or here pair) values into separate variables. Just like in tuples, here are also two variants of the tie, with and without “ignore”. “ignore” keyword ignores a particular tuple element from getting unpacked.\xa0', 'However, tuples can have multiple arguments but pairs only have two arguments. So, in the case of pair of pairs, unpacking needs to be explicitly handled.\xa0', 'This Assigns pr as the new content for the pair object. The first value is assigned the first value of pr and the second value is assigned the second value of pr.', '2) Comparison (==) operator with pair: For the given two pairs say pair1 and pair2, the comparison operator compares the first value and second value of those two pairs i.e. if pair1.first is equal to pair2.first or not AND if pair1.second is equal to pair2.second or not.', '3) Not equal (!=) operator with pair: For the given two pairs say pair1 and pair2, the != operator compares the first values of those two pairs i.e. if pair1.first is equal to pair2.first or not, if they are equal then it checks the second values of both.']","['4) Logical( >=, <= )operators with pair: For the given two pairs say pair1 and pair2, the =, >, can be used with pairs as well. It returns 0 or 1 by only comparing the first value of the pair. For pairs like p1=(1,20) and p2=(1,10)\xa0p2<p1 should give 0 (as it compares 1st element only & they are equal so it is definitely not less), but that isn’t true. Here the pair compares the second element and if it satisfies then returns 1\xa0(this is only the case when the first element gets equal while using a relational operator > or < only, otherwise these operators work as mentioned above)', 'This article is contributed by MAZHAR IMAM KHAN. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// CPP program to illustrate Pair in STL#include <iostream>#include <utility>using namespace std; // Driver Codeint main(){    // defining a pair    pair<int, char> PAIR1;     // first part of the pair    PAIR1.first = 100;    // second part of the pair    PAIR1.second = \'G\';     cout << PAIR1.first << "" "";    cout << PAIR1.second << endl;     return 0;}', '// CPP program to illustrate// Initializing of pair STL#include <iostream>#include <utility>using namespace std; // Driver Codeint main(){    // defining a pair    pair<string, double> PAIR2(""GeeksForGeeks"", 1.23);     cout << PAIR2.first << "" "";    cout << PAIR2.second << endl;     return 0;}', '// CPP program to illustrate// auto-initializing of pair STL#include <iostream>#include <utility> using namespace std; int main(){    pair<int, double> PAIR1;    pair<string, char> PAIR2;     // it is initialised to 0    cout << PAIR1.first;       // it is initialised to 0    cout << PAIR1.second;     cout << "" "";     // // it prints nothing i.e NULL    cout << PAIR2.first;         // it prints nothing i.e NULL    cout << PAIR2.second;     return 0;}', '// CPP Program to demonstrate make_pair()// function in pair#include <iostream>#include <utility>using namespace std; // Driver Codeint main(){    pair<int, char> PAIR1;    pair<string, double> PAIR2(""GeeksForGeeks"", 1.23);    pair<string, double> PAIR3;     PAIR1.first = 100;    PAIR1.second = \'G\';     PAIR3 = make_pair(""GeeksForGeeks is Best"", 4.56);     cout << PAIR1.first << "" "";    cout << PAIR1.second << endl;     cout << PAIR2.first << "" "";    cout << PAIR2.second << endl;     cout << PAIR3.first << "" "";    cout << PAIR3.second << endl;     return 0;}', '// CPP Program to demonstrate swap()// function in pair#include <iostream>#include <utility> using namespace std; // Driver Codeint main(){    pair<char, int> pair1 = make_pair(\'A\', 1);    pair<char, int> pair2 = make_pair(\'B\', 2);     cout << ""Before swapping:\\n "";    cout << ""Contents of pair1 = "" << pair1.first << "" ""         << pair1.second;    cout << ""Contents of pair2 = "" << pair2.first << "" ""         << pair2.second;    pair1.swap(pair2);     cout << ""\\nAfter swapping:\\n "";    cout << ""Contents of pair1 = "" << pair1.first << "" ""         << pair1.second;    cout << ""Contents of pair2 = "" << pair2.first << "" ""         << pair2.second;     return 0;}', '// CPP code to illustrate tie() in Pair#include <bits/stdc++.h>using namespace std; // Driver Codeint main(){    pair<int, int> pair1 = { 1, 2 };    int a, b;    tie(a, b) = pair1;    cout << a << "" "" << b << ""\\n"";     pair<int, int> pair2 = { 3, 4 };    tie(a, ignore) = pair2;     // prints old value of b    cout << a << "" "" << b << ""\\n"";     // Illustrating pair of pairs    pair<int, pair<int, char> > pair3 = { 3, { 4, \'a\' } };    int x, y;    char z;     // tie(x,y,z) = pair3; Gives compilation error    // tie(x, tie(y,z)) = pair3; Gives compilation error    // Each pair needs to be explicitly handled    x = pair3.first;    tie(y, z) = pair3.second;    cout << x << "" "" << y << "" "" << z << ""\\n"";} // contributed by sarthak_eddy.', '// CPP program to illustrate pair in STL#include <iostream>#include <string>#include <utility>using namespace std; int main(){    pair<string, int> g1;    pair<string, int> g2(""Quiz"", 3);    pair<string, int> g3(g2);    pair<int, int> g4(5, 10);     g1 = make_pair(string(""Geeks""), 1);    g2.first = "".com"";    g2.second = 2;     cout << ""This is pair g"" << g1.second << "" with ""         << ""value "" << g1.first << ""."" << endl         << endl;     cout << ""This is pair g"" << g3.second << "" with value ""         << g3.first         << ""This pair was initialized as a copy of ""         << ""pair g2"" << endl         << endl;     cout << ""This is pair g"" << g2.second << "" with value ""         << g2.first << ""\\nThe values of this pair were""         << "" changed after initialization."" << endl         << endl;     cout << ""This is pair g4 with values "" << g4.first         << "" and "" << g4.second         << "" made for showing addition. \\nThe ""         << ""sum of the values in this pair is ""         << g4.first + g4.second << ""."" << endl         << endl;     cout << ""We can concatenate the values of""         << "" the pairs g1, g2 and g3 : ""         << g1.first + g3.first + g2.first << endl         << endl;     cout << ""We can also swap pairs ""         << ""(but type of pairs should be same) : "" << endl;    cout << ""Before swapping, ""         << ""g1 has "" << g1.first << "" and g2 has ""         << g2.first << endl;    swap(g1, g2);    cout << ""After swapping, ""         << ""g1 has "" << g1.first << "" and g2 has ""         << g2.first;     return 0;}']","['pair (data_type1, data_type2) Pair_name', '100 G', 'pair (data_type1, data_type2) Pair_name (value1, value2) ;', ""pair  g1;         //default\npair  g2(1, 'a');  //initialized,  different data type\npair  g3(1, 10);   //initialized,  same data type\npair  g4(g3);    //copy of g3"", ""g2 = make_pair(1, 'a');"", ""g2 = {1, 'a'};"", 'GeeksForGeeks 1.23', '00', 'Pair_name = make_pair (value1,value2);', '100 G\nGeeksForGeeks 1.23\nGeeksForGeeks is Best 4.56', 'pair1.swap(pair2) ;', 'Before swapping:\n Contents of pair1 = A 1Contents of pair2 = B 2\nAfter swapping:\n Contents of pair1 = B 2Contents of pair2 = A 1', 'tie(int &, int &) = pair1;', '1 2\n3 2\n3 4 a', 'This is pair g1 with value Geeks.\n\nThis is pair g3 with value QuizThis pair was initialized as a copy of pair g2\n\nThis is pair g2 with value .com\nThe values of this pair were changed after initialization.\n\nThis is pair g4 with values 5 and 10 made for showing addition. \nThe sum of the values in this pair is 15.\n\nWe can concatenate the values of the pairs g1, g2 and g3 : GeeksQuiz.com\n\nWe can also swap pairs (but type of pairs should be same) : \nBefore swapping, g1 has Geeks and g2 has .com\nAfter swapping, g1 has .com and g2 has Geeks', 'pair& operator= (const pair& pr);']",[],"['The first element is referenced as ‘first’ and the second element as ‘second’ and the order is fixed (first, second).|||Pair can be assigned, copied, and compared. The array of objects allocated in a map or hash_map is of type ‘pair’ by default in which all the ‘first’ elements are unique keys associated with their ‘second’ value objects.|||To access the elements, we use variable name followed by dot operator followed by the keyword first or second.']"
60,['List in C++ Standard Template Library (STL)'],['CPP'],['Functions Used with List'],[],['https://www.youtube.com/embed/VcCRXrLFxyc?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/list-front-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-back-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-push_front-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-push_back-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-pop_front-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-pop_back-function-in-c-stl/', 'https://www.geeksforgeeks.org/listbegin-listend-c-stl/', 'https://www.geeksforgeeks.org/listbegin-listend-c-stl/', 'https://www.geeksforgeeks.org/list-rbegin-and-rend-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-insert-in-c-stl/', 'https://www.geeksforgeeks.org/list-erase-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-assign-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-remove-function-in-c-stl/', 'https://www.geeksforgeeks.org/listremove-listremove_if-c-stl/', 'https://www.geeksforgeeks.org/list-reverse-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-size-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-resize-function-in-c-stl/', 'https://www.geeksforgeeks.org/stdlistsort-c-stl/', 'https://www.geeksforgeeks.org/list-max_size-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-unique-in-c-stl/', 'https://www.geeksforgeeks.org/listemplace_front-listemplace_back-c-stl/', 'https://www.geeksforgeeks.org/listclear-c-stl/', 'https://www.geeksforgeeks.org/listoperator-c-stl/', 'https://www.geeksforgeeks.org/listswap-c-stl/', 'https://www.geeksforgeeks.org/list-splice-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-merge-function-in-c-stl/', 'https://www.geeksforgeeks.org/list-emplace-function-in-c-stl/', 'https://www.geeksforgeeks.org/tag/cpp-list/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Definition', 'Recent Articles on C++ list']","['Lists are sequence containers that allow non-contiguous memory allocation. As compared to vector, the list has slow traversal, but once a position has been found, insertion and deletion are quick. Normally, when we say a List, we talk about a doubly linked list. For implementing a singly linked list, we use a forward list.\xa0Below is the program to show the working of some functions of List:\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// CPP program to show the implementation of List#include <iostream>#include <iterator>#include <list>using namespace std; // function for printing the elements in a listvoid showlist(list<int> g){    list<int>::iterator it;    for (it = g.begin(); it != g.end(); ++it)        cout << \'\\t\' << *it;    cout << \'\\n\';} // Driver Codeint main(){     list<int> gqlist1, gqlist2;     for (int i = 0; i < 10; ++i) {        gqlist1.push_back(i * 2);        gqlist2.push_front(i * 3);    }    cout << ""\\nList 1 (gqlist1) is : "";    showlist(gqlist1);     cout << ""\\nList 2 (gqlist2) is : "";    showlist(gqlist2);     cout << ""\\ngqlist1.front() : "" << gqlist1.front();    cout << ""\\ngqlist1.back() : "" << gqlist1.back();     cout << ""\\ngqlist1.pop_front() : "";    gqlist1.pop_front();    showlist(gqlist1);     cout << ""\\ngqlist2.pop_back() : "";    gqlist2.pop_back();    showlist(gqlist2);     cout << ""\\ngqlist1.reverse() : "";    gqlist1.reverse();    showlist(gqlist1);     cout << ""\\ngqlist2.sort(): "";    gqlist2.sort();    showlist(gqlist2);     return 0;}']",['List 1 (gqlist1) is :     0    2    4    6    8    10    12    14    16    18\n\nList 2 (gqlist2) is :     27    24    21    18    15    12    9    6    3    0\n\ngqlist1.front() : 0\ngqlist1.back() : 18\ngqlist1.pop_front() :     2    4    6    8    10    12    14    16    18\n\ngqlist2.pop_back() :     27    24    21    18    15    12    9    6    3\n\ngqlist1.reverse() :     18    16    14    12    10    8    6    4    2\n\ngqlist2.sort():     3    6    9    12    15    18    21    24    27'],"['front()|||Returns the value of the first element in the list.&&&back()|||Returns the value of the last element in the list.&&&push_front(g)|||Adds a new element ‘g’ at the beginning of the list.&&&push_back(g)\xa0|||Adds a new element ‘g’ at the end of the list.&&&pop_front()|||Removes the first element of the list, and reduces size of the list by 1.&&&pop_back()|||Removes the last element of the list, and reduces size of the list by 1.&&&list::begin()|||begin() function returns an iterator pointing to the first element of the list.&&&list::end()|||end() function returns an iterator pointing to the theoretical last element which follows the last element.&&&list rbegin() and rend()|||rbegin() returns a reverse iterator which points to the last element of the list. rend() returns a reverse iterator which points to the position before the beginning of the list.&&&list cbegin() and cend()\xa0|||\xa0cbegin() returns a constant random access iterator which points to the beginning of the list. cend() returns a constant random access iterator which points to the end of the list.&&&list crbegin() and crend()\xa0|||crbegin() returns a constant reverse iterator which points to the last element of the list i.e reversed beginning of container. crend() returns a constant reverse iterator which points to the theoretical element preceding the first element in the list i.e. the reverse end of the list.&&&empty()\xa0|||Returns whether the list is empty(1) or not(0).&&&insert()|||Inserts new elements in the list before the element at a specified position.&&&erase()|||Removes a single element or a range of elements from the list.&&&assign()|||Assigns new elements to list by replacing current elements and resizes the list.&&&remove()|||Removes all the elements from the list, which are equal to given element.&&&list::remove_if()|||Used to remove all the values from the list that correspond true to the predicate or condition given as parameter to the function.&&&reverse()|||Reverses the list.&&&size()|||Returns the number of elements in the list.&&&list resize()|||Used to resize a list container.&&&sort()|||Sorts the list in increasing order.&&&list max_size()\xa0|||Returns the maximum number of elements a list container can hold.&&&list unique()|||Removes all duplicate consecutive elements from the list.&&&list::emplace_front() and list::emplace_back()|||emplace_front() function is used to insert a new element into the list container, the new element is added to the beginning of the list. emplace_back() function is used to insert a new element into the list container, the new element is added to the end of the list.&&&list::clear()|||clear() function is used to remove all the elements of the list container, thus making it size 0.&&&list::operator=|||This operator is used to assign new contents to the container by replacing the existing contents.&&&list::swap()|||This function is used to swap the contents of one list with another list of same type and size.&&&list splice()|||Used to transfer elements from one list to another.&&&list merge()|||Merges two sorted lists into one.&&&list emplace()|||Extends list by inserting new element at a given position.']",[]
61,['Deque in C++ Standard Template Library (STL)'],['CPP'],['Methods of Deque'],[],[],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/vector-in-cpp-stl/', 'https://www.geeksforgeeks.org/deque-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/deque-rbegin-function-in-c-stl/', 'https://www.geeksforgeeks.org/deque-rend-function-in-c-stl/', 'https://www.geeksforgeeks.org/deque-cbegin-in-c-stl/', 'https://www.geeksforgeeks.org/deque-max_size-function-in-c-stl/', 'https://www.geeksforgeeks.org/deque-assign-function-in-c-stl/', 'https://www.geeksforgeeks.org/deque-resize-function-in-c-stl/', 'https://www.geeksforgeeks.org/dequepush_front-c-stl/', 'https://www.geeksforgeeks.org/dequepush_back-c-stl/', 'https://www.geeksforgeeks.org/dequepop_front-dequepop_back-c-stl/', 'https://www.geeksforgeeks.org/deque-front-deque-back-cpp-stl/', 'https://www.geeksforgeeks.org/dequeclear-dequeerase-c-stl/', 'https://www.geeksforgeeks.org/deque-empty-deque-size-cpp-stl/', 'https://www.geeksforgeeks.org/dequeoperator-dequeoperator-c-stl/', 'https://www.geeksforgeeks.org/dequeat-dequeswap-c-stl/', 'https://www.geeksforgeeks.org/dequebegin-dequeend-c-stl/', 'https://www.geeksforgeeks.org/deque-emplace_front-deque-emplace_back-cpp-stl/', 'https://www.geeksforgeeks.org/tag/cpp-deque/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Definition', 'Recent Articles on Deque']","['Double-ended queues are sequence containers with the feature of expansion and contraction on both ends.\xa0They are similar to vectors, but are more efficient in case of insertion and deletion of elements. Unlike vectors, contiguous storage allocation may not be guaranteed.\xa0', 'Double Ended Queues are basically an implementation of the data structure double-ended queue. A queue data structure allows insertion only at the end and deletion from the front. This is like a queue in real life, wherein people are removed from the front and added at the back. Double-ended queues are a special case of queues where insertion and deletion operations are possible at both the ends.', 'The functions for deque are same as vector, with an addition of push and pop operations for both front and back.\xa0\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']",[],"['// CPP Program to implement Deque in STL#include <deque>#include <iostream> using namespace std; void showdq(deque<int> g){    deque<int>::iterator it;    for (it = g.begin(); it != g.end(); ++it)        cout << \'\\t\' << *it;    cout << \'\\n\';} int main(){    deque<int> gquiz;    gquiz.push_back(10);    gquiz.push_front(20);    gquiz.push_back(30);    gquiz.push_front(15);    cout << ""The deque gquiz is : "";    showdq(gquiz);     cout << ""\\ngquiz.size() : "" << gquiz.size();    cout << ""\\ngquiz.max_size() : "" << gquiz.max_size();     cout << ""\\ngquiz.at(2) : "" << gquiz.at(2);    cout << ""\\ngquiz.front() : "" << gquiz.front();    cout << ""\\ngquiz.back() : "" << gquiz.back();     cout << ""\\ngquiz.pop_front() : "";    gquiz.pop_front();    showdq(gquiz);     cout << ""\\ngquiz.pop_back() : "";    gquiz.pop_back();    showdq(gquiz);     return 0;}']",['The deque gquiz is :     15    20    10    30\n\ngquiz.size() : 4\ngquiz.max_size() : 4611686018427387903\ngquiz.at(2) : 10\ngquiz.front() : 15\ngquiz.back() : 30\ngquiz.pop_front() :     20    10    30\n\ngquiz.pop_back() :     20    10'],"['deque::insert()|||Inserts an element. And returns an iterator that points to the first of the newly inserted elements.&&&deque::rbegin()|||Returns a reverse iterator which points to the last element of the deque (i.e., its reverse beginning).&&&deque::rend()|||Returns a reverse iterator which points to the position before the beginning of the deque (which is considered its reverse end).&&&deque::cbegin()|||Returns a constant iterator pointing to the first element of the container, that is, the iterator cannot be used to modify, only traverse the deque.&&&deque::max_size()|||Returns the maximum number of elements that a deque container can hold.&&&deque::assign()|||Assign values to the same or different deque container.&&&deque::resize()\xa0|||Function which changes the size of the deque.&&&deque::push_front()|||It is used to push elements into a deque from the front.&&&deque::push_back()\xa0|||This function is used to push elements into a deque from the back.&&&deque::pop_front() and deque::pop_back()|||pop_front() function is used to pop or remove elements from a deque from the front. pop_back() function is used to pop or remove elements from a deque from the back.&&&deque::front() and deque::back()|||front() function is used to reference the first element of the deque container. back() function is used to reference the last element of the deque container.&&&deque::clear() and deque::erase()\xa0|||clear() function is used to remove all the elements of the deque container, thus making its size 0. erase() function is used to remove elements from a container from the specified position or range.&&&deque::empty() and deque::size()|||empty() function is used to check if the deque container is empty or not. size() function is used to return the size of the deque container or the number of elements in the deque container.&&&deque::operator= and deque::operator[]|||operator= operator is used to assign new contents to the container by replacing the existing contents. operator[] operator is used to reference the element present at position given inside the operator.&&&deque::at() and deque::swap()|||at() function is used reference the element present at the position given as the parameter to the function. swap() function is used to swap the contents of one deque with another deque of same type and size.&&&deque::begin() and deque::end\xa0|||begin() function is used to return an iterator pointing to the first element of the deque container. end() function is used to return an iterator pointing to the last element of the deque container.&&&deque::emplace_front() and deque::emplace_back()\xa0|||emplace_front() function is used to insert a new element into the deque container. The new element is added to the beginning of the deque. emplace_back() function is used to insert a new element into the deque container. The new element is added to the end of the deque.&&&deque::find()|||Finds the element in the given range of numbers. Returns an iterator to the first element in the range [first,last] that compares equal to val. If no such element is found, the function returns last.']",[]
62,['Queue in C++ Standard Template Library (STL)'],['CPP'],[],[],['https://www.youtube.com/embed/fV_DchJem0U?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/deque-cpp-stl/', 'https://www.geeksforgeeks.org/list-cpp-stl/', 'https://www.geeksforgeeks.org/queueempty-queuesize-c-stl/', 'https://www.geeksforgeeks.org/queueempty-queuesize-c-stl/', 'https://www.geeksforgeeks.org/queue-swap-cpp-stl/', 'https://www.geeksforgeeks.org/queueemplace-c-stl/', 'https://www.geeksforgeeks.org/queuefront-queueback-c-stl/', 'https://www.geeksforgeeks.org/queuefront-queueback-c-stl/', 'https://www.geeksforgeeks.org/queue-push-and-queue-pop-in-cpp-stl/', 'https://www.geeksforgeeks.org/queue-push-and-queue-pop-in-cpp-stl/', 'https://www.geeksforgeeks.org/tag/cpp-queue/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']",['Methods of Queue are:\xa0'],"['Recent Articles on C++ Queue\xa0\xa0\xa0Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['Queues are a type of container adaptors that operate in a first in first out (FIFO) type of arrangement. Elements are inserted at the back (end) and are deleted from the front. Queues use an encapsulated object of deque or list (sequential container class) as its underlying container, providing a specific set of member functions to access its elements. Following is an example to demonstrate the queue and its various methods.']","['// CPP code to illustrate Queue in// Standard Template Library (STL)#include <iostream>#include <queue> using namespace std; // Print the queuevoid showq(queue<int> gq){    queue<int> g = gq;    while (!g.empty()) {        cout << \'\\t\' << g.front();        g.pop();    }    cout << \'\\n\';} // Driver Codeint main(){    queue<int> gquiz;    gquiz.push(10);    gquiz.push(20);    gquiz.push(30);     cout << ""The queue gquiz is : "";    showq(gquiz);     cout << ""\\ngquiz.size() : "" << gquiz.size();    cout << ""\\ngquiz.front() : "" << gquiz.front();    cout << ""\\ngquiz.back() : "" << gquiz.back();     cout << ""\\ngquiz.pop() : "";    gquiz.pop();    showq(gquiz);     return 0;}']",['The queue gquiz is :     10    20    30\n\ngquiz.size() : 3\ngquiz.front() : 10\ngquiz.back() : 30\ngquiz.pop() :     20    30'],"['queue::empty()|||Returns whether the queue is empty.&&&queue::size()|||Returns the size of the queue.&&&queue::swap()|||Exchange the contents of two queues but the queues must be of the same type, although sizes may differ.&&&queue::emplace()|||Insert a new element into the queue container, the new element is added to the end of the queue.&&&queue::front()|||Returns a reference to the first element of the queue.&&&queue::back()|||Returns a reference to the last element of the queue.&&&queue::push(g)\xa0|||Adds the element ‘g’ at the end of the queue.&&&queue::pop()\xa0|||Deletes the first element of the queue.']",[]
63,['Priority Queue in C++ Standard Template Library (STL)'],"['CPP', 'CPP']",[],[],['https://www.youtube.com/embed/vc7i0bBuQEM?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/priority_queueempty-priority_queuesize-c-stl/', 'https://www.geeksforgeeks.org/priority_queueempty-priority_queuesize-c-stl/', 'https://www.geeksforgeeks.org/priority_queuetop-c-stl/', 'https://www.geeksforgeeks.org/priority_queuepush-priority_queuepop-c-stl/', 'https://www.geeksforgeeks.org/priority_queuepush-priority_queuepop-c-stl/', 'https://www.geeksforgeeks.org/priority_queueswap-c-stl/', 'https://www.geeksforgeeks.org/priority_queue-emplace-in-cpp-stl/', 'https://www.geeksforgeeks.org/priority_queue-value_type-in-c-stl/', 'https://www.geeksforgeeks.org/tag/cpp-priority-queue/', 'https://practice.geeksforgeeks.org/contest/job-a-thon-5-hiring-challenge/?utm_source=article&utm_medium=in-article&utm_campaign=in-article']","['Note: By default, C++ creates a max-heap for priority queue.', 'How to create a min-heap for the priority queue?\xa0', 'C++ provides the below syntax for the same.\xa0\xa0', 'Methods of Priority Queue are:\xa0', 'Definition', 'Must Read: Recent articles on priority queue in STL\xa0']","['Priority queues are a type of container adapters, specifically designed such that the first element of the queue is the greatest of all elements in the queue and elements are in nonincreasing order (hence we can see that each element of the queue has a priority {fixed order}). Following is an example to demonstrate the priority queue and its various methods.\xa0', 'Note: The above syntax may be difficult to remember, so in case of numeric values, we can multiply the values with -1 and use max heap to get the effect of min heap.', 'Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above. \xa0']",[],"['// CPP Program to demonstrate Priority Queue#include <iostream>#include <queue>using namespace std; void showpq(priority_queue<int> gq){    priority_queue<int> g = gq;    while (!g.empty()) {        cout << \'\\t\' << g.top();        g.pop();    }    cout << \'\\n\';} // Driver Codeint main(){    priority_queue<int> gquiz;    gquiz.push(10);    gquiz.push(30);    gquiz.push(20);    gquiz.push(5);    gquiz.push(1);     cout << ""The priority queue gquiz is : "";    showpq(gquiz);     cout << ""\\ngquiz.size() : "" << gquiz.size();    cout << ""\\ngquiz.top() : "" << gquiz.top();     cout << ""\\ngquiz.pop() : "";    gquiz.pop();    showpq(gquiz);     return 0;}', '// C++ program to demonstrate min heap for priority queue#include <iostream>#include <queue>using namespace std; void showpq(    priority_queue<int, vector<int>, greater<int> > gq){    priority_queue<int, vector<int>, greater<int> > g = gq;    while (!g.empty()) {        cout << \'\\t\' << g.top();        g.pop();    }    cout << \'\\n\';} // Driver Codeint main(){    priority_queue<int, vector<int>, greater<int> > gquiz;    gquiz.push(10);    gquiz.push(30);    gquiz.push(20);    gquiz.push(5);    gquiz.push(1);     cout << ""The priority queue gquiz is : "";    showpq(gquiz);     cout << ""\\ngquiz.size() : "" << gquiz.size();    cout << ""\\ngquiz.top() : "" << gquiz.top();     cout << ""\\ngquiz.pop() : "";    gquiz.pop();    showpq(gquiz);     return 0;}']","['The priority queue gquiz is :     30    20    10    5    1\n\ngquiz.size() : 5\ngquiz.top() : 30\ngquiz.pop() :     20    10    5    1', 'priority_queue <int, vector<int>, greater<int>> g = gq;', 'The priority queue gquiz is :     1    5    10    20    30\n\ngquiz.size() : 5\ngquiz.top() : 1\ngquiz.pop() :     5    10    20    30']",['priority_queue::empty()|||Returns whether the queue is empty.&&&priority_queue::size()\xa0|||Returns the size of the queue.&&&priority_queue::top()|||Returns a reference to the topmost element of the queue.&&&priority_queue::push()\xa0|||Adds the element ‘g’ at the end of the queue.&&&priority_queue::pop()|||Deletes the first element of the queue.&&&priority_queue::swap()|||Used to swap the contents of one priority queue with another priority queue of the same type and size.&&&priority_queue::emplace()|||Used to insert a new element into the priority queue container.&&&priority_queue value_type\xa0|||Represents the type of object stored as an element in a priority_queue. It acts as a synonym for the template parameter.'],[]
64,['Set in C++ Standard Template Library (STL)'],['CPP'],['Methods of Set in C++ STL'],[],['https://www.youtube.com/embed/YuZPHhniZtw?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/unordered_set-in-cpp-stl/', 'https://www.geeksforgeeks.org/setbegin-setend-c-stl/', 'https://www.geeksforgeeks.org/setbegin-setend-c-stl/', 'https://www.geeksforgeeks.org/setsize-c-stl/', 'https://www.geeksforgeeks.org/set-max_size-function-in-c-stl/', 'https://www.geeksforgeeks.org/setempty-c-stl/', 'https://www.geeksforgeeks.org/setbegin-setend-c-stl/', 'https://www.geeksforgeeks.org/setbegin-setend-c-stl/', 'https://www.geeksforgeeks.org/setrbegin-and-setrend-in-c-stl/', 'https://www.geeksforgeeks.org/setrbegin-and-setrend-in-c-stl/', 'https://www.geeksforgeeks.org/set-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/setsize-c-stl/', 'https://www.geeksforgeeks.org/set-max_size-function-in-c-stl/', 'https://www.geeksforgeeks.org/setempty-c-stl/', 'https://www.geeksforgeeks.org/set-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/seterase-c-stl/', 'https://www.geeksforgeeks.org/seterase-c-stl/', 'https://www.geeksforgeeks.org/setclear-c-stl/', 'https://www.geeksforgeeks.org/setkey_comp-in-c-stl/', 'https://www.geeksforgeeks.org/set-value_comp-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-find-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-count-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-lower_bound-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-upper_bound-function-in-c-stl/', 'https://www.geeksforgeeks.org/set-equal_range-function-in-c-stl/', 'https://www.geeksforgeeks.org/setemplace-c-stl/', 'https://www.geeksforgeeks.org/set-emplace_hint-function-in-c-stl/', 'https://www.geeksforgeeks.org/setswap-c-stl/', 'https://www.geeksforgeeks.org/set-operator-in-c-stl/', 'https://www.geeksforgeeks.org/set-get_allocator-in-c-stl/', 'https://www.geeksforgeeks.org/set-vs-unordered_set-c-stl/', 'https://practice.geeksforgeeks.org/courses/dsa-self-paced?utm_source=geeksforgeeks&utm_medium=article&utm_campaign=gfg_article_dsa_content_bottom']","['Datatype: Set can take any data type depending on the values, e.g. int, char, float, etc.', 'Properties:', 'Note: To store the elements in an unsorted(random) order,\xa0 unordered_set() can be used.', 'Some Basic Functions Associated with Set:\xa0', 'Must Read: Sets vs Unordered Set']","['Sets are a type of associative containers in which each element has to be unique because the value of the element identifies it. The values are stored in a specific order.\xa0', 'Note: set<datatype, greater<datatype>> setname; is used for storing values in a set in descending order.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above']",[],"['// CPP program to demonstrate various functions of// Set in C++ STL#include <iostream>#include <iterator>#include <set> using namespace std; int main(){    // empty set container    set<int, greater<int> > s1;     // insert elements in random order    s1.insert(40);    s1.insert(30);    s1.insert(60);    s1.insert(20);    s1.insert(50);     // only one 50 will be added to the set    s1.insert(50);    s1.insert(10);     // printing set s1    set<int, greater<int> >::iterator itr;    cout << ""\\nThe set s1 is : \\n"";    for (itr = s1.begin(); itr != s1.end(); itr++) {        cout << *itr << "" "";    }    cout << endl;     // assigning the elements from s1 to s2    set<int> s2(s1.begin(), s1.end());     // print all elements of the set s2    cout << ""\\nThe set s2 after assign from s1 is : \\n"";    for (itr = s2.begin(); itr != s2.end(); itr++) {        cout << *itr << "" "";    }    cout << endl;     // remove all elements up to 30 in s2    cout << ""\\ns2 after removal of elements less than 30 ""            "":\\n"";    s2.erase(s2.begin(), s2.find(30));    for (itr = s2.begin(); itr != s2.end(); itr++) {        cout << *itr << "" "";    }     // remove element with value 50 in s2    int num;    num = s2.erase(50);    cout << ""\\ns2.erase(50) : "";    cout << num << "" removed\\n"";    for (itr = s2.begin(); itr != s2.end(); itr++) {        cout << *itr << "" "";    }     cout << endl;     // lower bound and upper bound for set s1    cout << ""s1.lower_bound(40) : \\n""         << *s1.lower_bound(40) << endl;    cout << ""s1.upper_bound(40) : \\n""         << *s1.upper_bound(40) << endl;     // lower bound and upper bound for set s2    cout << ""s2.lower_bound(40) :\\n""         << *s2.lower_bound(40) << endl;    cout << ""s2.upper_bound(40) : \\n""         << *s2.upper_bound(40) << endl;     return 0;}']","['set<datatype> setname;', 'set<int> val; // defining an empty set\nset<int> val = {6, 10, 5, 1}; // defining a set with values', 'The set s1 is : \n60 50 40 30 20 10 \n\nThe set s2 after assign from s1 is : \n10 20 30 40 50 60 \n\ns2 after removal of elements less than 30 :\n30 40 50 60 \ns2.erase(50) : 1 removed\n30 40 60 \ns1.lower_bound(40) : \n40\ns1.upper_bound(40) : \n30\ns2.lower_bound(40) :\n40\ns2.upper_bound(40) : \n60']","['begin()|||Returns an iterator to the first element in the set.&&&end()|||Returns an iterator to the theoretical element that follows the last element in the set.&&&rbegin()|||Returns a reverse iterator pointing to the last element in the container.&&&rend()|||Returns a reverse iterator pointing to the theoretical element right before the first element in the set container.&&&crbegin()|||Returns a constant iterator pointing to the last element in the container.&&&crend()|||Returns a constant iterator pointing to the position just before the first element in the container.&&&cbegin()|||Returns a constant iterator pointing to the first element in the container.&&&cend()|||Returns a constant iterator pointing to the position past the last element in the container.&&&size()|||Returns the number of elements in the set.&&&max_size()|||Returns the maximum number of elements that the set can hold.&&&empty()|||Returns whether the set is empty.&&&insert(const g)\xa0|||Adds a new element ‘g’ to the set.&&&iterator insert (iterator position, const g)|||Adds a new element ‘g’ at the position pointed by the iterator.&&&erase(iterator position)\xa0|||Removes the element at the position pointed by the iterator.&&&erase(const g)|||Removes the value ‘g’ from the set.&&&clear()\xa0|||Removes all the elements from the set.&&&key_comp() / value_comp()|||Returns the object that determines how the elements in the set are ordered (‘<‘ by default).&&&find(const g)|||Returns an iterator to the element ‘g’ in the set if found, else returns the iterator to end.&&&count(const g)|||Returns 1 or 0 based on the element ‘g’ is present in the set or not.&&&lower_bound(const g)|||Returns an iterator to the first element that is equivalent to ‘g’ or definitely will not go before the element ‘g’ in the set.&&&upper_bound(const g)|||Returns an iterator to the first element that will go after the element ‘g’ in the set.&&&equal_range()|||The function returns an iterator of pairs. (key_comp). The pair refers to the range that includes all the elements in the container which have a key equivalent to k.&&&emplace()|||This function is used to insert a new element into the set container, only if the element to be inserted is unique and does not already exist in the set.&&&emplace_hint()|||Returns an iterator pointing to the position where the insertion is done. If the element passed in the parameter already exists, then it returns an iterator pointing to the position where the existing element is.&&&swap()|||This function is used to exchange the contents of two sets but the sets must be of the same type, although sizes may differ.&&&operator=|||The ‘=’ is an operator in C++ STL which copies (or moves) a set to another set and set::operator= is the corresponding operator function.&&&get_allocator()|||Returns the copy of the allocator object associated with the set.']","['begin() – Returns an iterator to the first element in the set.|||end() – Returns an iterator to the theoretical element that follows the last element in the set.|||size() – Returns the number of elements in the set.|||max_size() – Returns the maximum number of elements that the set can hold.|||empty() – Returns whether the set is empty.&&&&&&The set stores the elements in sorted order.|||All the elements in a set have unique values.|||The value of the element cannot be modified once it is added to the set, though it is possible to remove and then add the modified value of that element. Thus, the values are immutable.|||Sets follow the Binary search tree implementation.|||The values in a set are unindexed.&&&']"
65,['Unordered Sets in C++ Standard Template Library'],"['CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/easy/', 'http://geeksquiz.com/set-associative-containers-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/unordered_set-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-begin-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-end-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-count-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-find-function-in-c-stl/', 'https://www.geeksforgeeks.org/unoredered_set-clear-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-cbegin-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-bucket_size-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-erase-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-size-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-swap-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-emplace-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-max_size-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-empty-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-equal_range-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-operator-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-hash_function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-reserve-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-bucket-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-bucket_count-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-load_factor-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-rehash-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-max_load_factor-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-emplace_hint-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-operator-in-c-stl-3/', 'https://www.geeksforgeeks.org/unordered_set-key_eq-function-in-c-stl/', 'https://www.geeksforgeeks.org/unordered_set-operator-in-c-stl-2/', 'https://www.geeksforgeeks.org/unordered_set-max_bucket_count-function-in-c-stl/', 'https://www.geeksforgeeks.org/tag/cpp-unordered_set/', 'http://qa.geeksforgeeks.org/user/utkarsh111', 'https://practice.geeksforgeeks.org/courses/ds-in-c??utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_DS_C']","['Below is C++ solution using unordered_set.\xa0', 'Methods of unordered_set:\xa0\xa0']","['Recent articles on unordered_setThis article is contributed by Utkarsh Trivedi. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']","['An unordered_set is implemented using a hash table where keys are hashed into indices of a hash table so that the insertion is always randomized. All operations on the unordered_set takes constant time O(1) on an average which can go up to linear time O(n) in worst case which depends on the internally used hash function, but practically they perform very well and generally provide a constant time lookup operation.\xa0The unordered_set can contain key of any type – predefined or user-defined data structure but when we define key of type user define the type, we need to specify our comparison function according to which keys will be compared.\xa0Sets vs Unordered Sets\xa0Set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered. Set is implemented as a balanced tree structure that is why it is possible to maintain order between the elements (by specific tree traversal). The time complexity of set operations is O(log n) while for unordered_set, it is O(1).\xa0Methods on Unordered Sets:\xa0For unordered_set many functions are defined among which most used are the size and empty for capacity, find for searching a key, insert and erase for modification.\xa0The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.\xa0Example of declaration, find, insert and iteration in unordered_set is given below :', 'find, insert and erase take constant amount of time on average. The find() function returns an iterator to end() if key is not there in set, otherwise an iterator to the key position is returned. The iterator works as a pointer to the key values so that we can get the key by dereferencing them using * operator.\xa0A practical problem based on unordered_set – Given an array(list) of integers, find all the duplicates among them.\xa0']","['// C++ program to demonstrate various function of unordered_set#include <bits/stdc++.h>using namespace std; int main(){    // declaring set for storing string data-type    unordered_set <string> stringSet ;     // inserting various string, same string will be stored    // once in set     stringSet.insert(""code"") ;    stringSet.insert(""in"") ;    stringSet.insert(""c++"") ;    stringSet.insert(""is"") ;    stringSet.insert(""fast"") ;     string key = ""slow"" ;     //  find returns end iterator if key is not found,    //  else it returns iterator to that key     if (stringSet.find(key) == stringSet.end())        cout << key << "" not found"" << endl << endl ;    else        cout << ""Found "" << key << endl << endl ;     key = ""c++"";    if (stringSet.find(key) == stringSet.end())        cout << key << "" not found\\n"" ;    else        cout << ""Found "" << key << endl ;     // now iterating over whole set and printing its    // content    cout << ""\\nAll elements : "";    unordered_set<string> :: iterator itr;    for (itr = stringSet.begin(); itr != stringSet.end(); itr++)        cout << (*itr) << endl;}', '// C++ program to find duplicate from an array using// unordered_set#include <bits/stdc++.h>using namespace std; // Print duplicates in arr[0..n-1] using unordered_setvoid printDuplicates(int arr[], int n){    // declaring unordered sets for checking and storing    // duplicates    unordered_set<int> intSet;    unordered_set<int> duplicate;     // looping through array elements    for (int i = 0; i < n; i++)    {        // if element is not there then insert that        if (intSet.find(arr[i]) == intSet.end())            intSet.insert(arr[i]);         // if element is already there then insert into        // duplicate set        else            duplicate.insert(arr[i]);    }     // printing the result    cout << ""Duplicate item are : "";    unordered_set<int> :: iterator itr;     // iterator itr loops from begin() till end()    for (itr = duplicate.begin(); itr != duplicate.end(); itr++)        cout << *itr << "" "";} // Driver codeint main(){    int arr[] = {1, 5, 2, 1, 4, 3, 1, 7, 2, 8, 9, 5};    int n = sizeof(arr) / sizeof(int);     printDuplicates(arr, n);    return 0;}']","['slow not found\n\nFound c++\n\nAll elements : \nis\nfast\nc++\nin\ncode', 'Input  : arr[] = {1, 5, 2, 1, 4, 3, 1, 7, 2, 8, 9, 5}\nOutput : Duplicate item are : 5 2 1', 'Duplicate item are : 5 1 2']",[],"['insert()– Insert a new {element} in the unordered_set container.|||begin()– Return an iterator pointing to the first element in the unordered_set container.|||end()– Returns an iterator pointing to the past-the-end-element.|||count()– Count occurrences of a particular element in an unordered_set container.|||find()– Search for an element in the container.|||clear()– Removes all of the elements from an unordered_set and empties it.|||cbegin()– Return a const_iterator pointing to the first element in the unordered_set container.|||cend()– Return a const_iterator pointing to past-the-end element in the unordered_set container or in one of it’s bucket.|||bucket_size()– Returns the total number of elements present in a specific bucket in an unordered_set container.|||erase()– Remove either a single element or a range of elements ranging from start(inclusive) to end(exclusive).|||size()– Return the number of elements in the unordered_set container.|||swap()– Exchange values of two unordered_set containers.|||emplace()– Insert an element in an unordered_set container.|||max_size()– Returns maximum number of elements that an unordered_set container can hold.|||empty()– Check if an unordered_set container is empty or not.|||equal_range– Returns range that includes all elements equal to given value.|||operator= – Copies (or moves) an unordered_set to another unordered_set and unordered_set::operator= is the corresponding operator function.|||hash_function() – This hash function is a unary function which takes asingle argument only and returns a unique value of type size_t based on it.|||reserve()– Used to request capacity change of unordered_set.|||bucket()– Returns the bucket number of a specific element.|||bucket_count() – Returns the total number of buckets present in an unordered_set container.|||load_factor()– Returns the current load factor in the unordered_set container.|||rehash()– Set the number of buckets in the container of unordered_set to given size or more.|||max_load_factor()– Returns(Or sets) the current maximum load factor of the unordered set container.|||emplace_hint()– Inserts a new element in the unordered_set only if the value to be inserted is unique, with a given hint.|||== operator – The ‘==’ is an operator in C++ STL performs equality comparison operation between two unordered sets and unordered_set::operator== is the corresponding operator function for the same.|||key_eq()– Returns a boolean value according to the comparison. It returns the key equivalence comparison predicate used by the unordered_set.|||operator!=– The != is a relational operator in C++ STL which compares the equality and inequality between unordered_set containers.|||max_bucket_count() – Find the maximum number of buckets that unordered_set can have.']"
66,['Multiset in C++ Standard Template Library (STL)'],"['CPP', 'C++']",['List of Functions of Multiset'],[],['https://www.youtube.com/embed/xelzlR_OGnI?feature=oembed'],"['https://www.geeksforgeeks.org/easy/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/multiset-begin-and-end-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-begin-and-end-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-size-in-c-stl-with-examples/', 'https://www.geeksforgeeks.org/multiset-max_size-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-empty-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-erase-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-erase-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-begin-and-end-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-begin-and-end-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-size-in-c-stl-with-examples/', 'https://www.geeksforgeeks.org/multiset-max_size-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-empty-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-insert-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-erase-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-erase-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-clear-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-value_comp-method-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-find-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-count-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-lower_bound-in-cpp-stl-with-examples/', 'https://www.geeksforgeeks.org/multiset-upper_bound-in-cpp-stl-with-examples/', 'https://www.geeksforgeeks.org/multisetswap-c-stl/', 'https://www.geeksforgeeks.org/multisetoperator-c-stl/', 'https://www.geeksforgeeks.org/multisetemplace-c-stl/', 'https://www.geeksforgeeks.org/multiset-equal_range-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-emplace_hint-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-rbegin-and-rend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-rbegin-and-rend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/multiset-get_allocator-function-in-c-stl/', 'https://www.geeksforgeeks.org/tag/cpp-multiset/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Implementation:\xa0', '\xa0Removing Element From Multiset Which Have Same Value:', 'Definition', 'Recent Articles on Multiset\xa0\xa0']","['Multisets are a type of associative containers similar to the set, with the exception that multiple elements can have the same values. Some Basic Functions associated with multiset:\xa0', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// CPP Program to demonstrate the// implementation of multiset#include <iostream>#include <iterator>#include <set> using namespace std; int main(){    // empty multiset container    multiset<int, greater<int> > gquiz1;     // insert elements in random order    gquiz1.insert(40);    gquiz1.insert(30);    gquiz1.insert(60);    gquiz1.insert(20);    gquiz1.insert(50);     // 50 will be added again to    // the multiset unlike set    gquiz1.insert(50);    gquiz1.insert(10);     // printing multiset gquiz1    multiset<int, greater<int> >::iterator itr;    cout << ""\\nThe multiset gquiz1 is : \\n"";    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) {        cout << *itr << "" "";    }    cout << endl;     // assigning the elements from gquiz1 to gquiz2    multiset<int> gquiz2(gquiz1.begin(), gquiz1.end());     // print all elements of the multiset gquiz2    cout << ""\\nThe multiset gquiz2 \\n""            ""after assign from gquiz1 is : \\n"";    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << *itr << "" "";    }    cout << endl;     // remove all elements up to element    // with value 30 in gquiz2    cout << ""\\ngquiz2 after removal \\n""            ""of elements less than 30 : \\n"";    gquiz2.erase(gquiz2.begin(), gquiz2.find(30));    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << *itr << "" "";    }     // remove all elements with value 50 in gquiz2    int num;    num = gquiz2.erase(50);    cout << ""\\ngquiz2.erase(50) : \\n"";    cout << num << "" removed \\n"";    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << *itr << "" "";    }     cout << endl;     // lower bound and upper bound for multiset gquiz1    cout << ""\\ngquiz1.lower_bound(40) : \\n""         << *gquiz1.lower_bound(40) << endl;    cout << ""gquiz1.upper_bound(40) : \\n""         << *gquiz1.upper_bound(40) << endl;     // lower bound and upper bound for multiset gquiz2    cout << ""gquiz2.lower_bound(40) : \\n""         << *gquiz2.lower_bound(40) << endl;    cout << ""gquiz2.upper_bound(40) : \\n""         << *gquiz2.upper_bound(40) << endl;     return 0;}', '// CPP Code to remove an element from multiset which have// same value#include <bits/stdc++.h>using namespace std; int main(){    multiset<int> a;    a.insert(10);    a.insert(10);    a.insert(10);     // it will give output 3    cout << a.count(10) << endl;     // removing single instance from multiset     // it will remove only one value of    // 10 from multiset    a.erase(a.find(10));     // it will give output 2    cout << a.count(10) << endl;     // removing all instance of element from multiset    // it will remove all instance of value 10    a.erase(10);     // it will give output 0 because all    // instance of value is removed from    // multiset    cout << a.count(10) << endl;     return 0;}']","['The multiset gquiz1 is : \n60 50 50 40 30 20 10 \n\nThe multiset gquiz2 \nafter assign from gquiz1 is : \n10 20 30 40 50 50 60 \n\ngquiz2 after removal \nof elements less than 30 : \n30 40 50 50 60 \ngquiz2.erase(50) : \n2 removed \n30 40 60 \n\ngquiz1.lower_bound(40) : \n40\ngquiz1.upper_bound(40) : \n30\ngquiz2.lower_bound(40) : \n40\ngquiz2.upper_bound(40) : \n60', '3\n2\n0']","['begin()|||Returns an iterator to the first element in the multiset.&&&end()|||Returns an iterator to the theoretical element that follows the last element in the multiset.&&&size()|||Returns the number of elements in the multiset.&&&max_size()|||Returns the maximum number of elements that the multiset can hold.&&&empty()|||Returns whether the multiset is empty.&&&pair insert(const g)|||Adds a new element ‘g’ to the multiset.&&&iterator insert (iterator position,const g)|||Adds a new element ‘g’ at the position pointed by the iterator.&&&erase(iterator position)|||Removes the element at the position pointed by the iterator.&&&erase(const g)|||Removes the value ‘g’ from the multiset.&&&clear()|||Removes all the elements from the multiset.&&&key_comp() / value_comp()|||Returns the object that determines how the elements in the multiset are ordered (‘<‘ by default).&&&find(const g)|||Returns an iterator to the element ‘g’ in the multiset if found, else returns the iterator to end.&&&count(const g)|||Returns the number of matches to element ‘g’ in the multiset.&&&lower_bound(const g)|||Returns an iterator to the first element that is equivalent to ‘g’ or definitely will not go before the element ‘g’ in the multiset if found, else returns the iterator to end.&&&upper_bound(const g)|||Returns an iterator to the first element that is equivalent to ‘g’ or definitely will go after the element ‘g’ in the multiset if found, else returns the iterator to end.&&&multiset::swap()|||This function is used to exchange the contents of two multisets but the sets must be of the same type, although sizes may differ.&&&multiset::operator=|||This operator is used to assign new contents to the container by replacing the existing contents.&&&multiset::emplace()|||This function is used to insert a new element into the multiset container.&&&multiset equal_range()|||Returns an iterator of pairs. The pair refers to the range that includes all the elements in the container which have a key equivalent to k.&&&multiset::emplace_hint()|||Inserts a new element in the multiset.&&&multiset::rbegin()|||Returns a reverse iterator pointing to the last element in the multiset container.&&&multiset::rend()|||Returns a reverse iterator pointing to the theoretical element right before the first element in the multiset container.&&&multiset::cbegin()|||Returns a constant iterator pointing to the first element in the container.&&&multiset::cend()|||Returns a constant iterator pointing to the position past the last element in the container.&&&multiset::crbegin()|||Returns a constant reverse iterator pointing to the last element in the container.&&&multiset::crend()|||Returns a constant reverse iterator pointing to the position just before the first element in the container.&&&multiset::get_allocator()|||Returns a copy of the allocator object associated with the multiset.']",['begin() – Returns an iterator to the first element in the multiset.|||end() – Returns an iterator to the theoretical element that follows the last element in the multiset.|||size() – Returns the number of elements in the multiset.|||max_size() – Returns the maximum number of elements that the multiset can hold.|||empty() – Returns whether the multiset is empty&&&a.erase() – Remove all instances of element from multiset having the same value|||a.erase(a.find()) – Remove only one instance of element from multiset having same value']
67,['Map in C++ Standard Template Library (STL)'],['CPP'],['List of all Functions of Map\xa0'],[],['https://www.youtube.com/embed/kDwXAmLz47w?feature=oembed'],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/containers-cpp-stl/', 'https://www.geeksforgeeks.org/mapbegin-end-c-stl/', 'https://www.geeksforgeeks.org/mapbegin-end-c-stl/', 'https://www.geeksforgeeks.org/mapsize-c-stl/', 'https://www.geeksforgeeks.org/map-max_size-in-c-stl/', 'https://www.geeksforgeeks.org/mapempty-c-stl/', 'https://www.geeksforgeeks.org/map-insert-in-c-stl/', 'https://www.geeksforgeeks.org/map-erase-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-erase-function-in-c-stl/', 'https://www.geeksforgeeks.org/mapclear-c-stl/', 'https://www.geeksforgeeks.org/map-insert-in-c-stl/', 'https://www.geeksforgeeks.org/map-count-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-equal_range-in-c-stl/', 'https://www.geeksforgeeks.org/map-erase-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-rend-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-rbegin-function-in-c-stl-2/', 'https://www.geeksforgeeks.org/map-find-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-crbegin-and-crend-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-cbegin-and-cend-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-emplace-in-c-stl/', 'https://www.geeksforgeeks.org/map-max_size-in-c-stl/', 'https://www.geeksforgeeks.org/map-upper_bound-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-operator-in-c-stl/', 'https://www.geeksforgeeks.org/map-lower_bound-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-emplace_hint-function-in-c-stl/', 'https://www.geeksforgeeks.org/map-value_comp-in-c-stl/', 'https://www.geeksforgeeks.org/map-key_comp-function-in-c-stl/', 'https://www.geeksforgeeks.org/mapsize-c-stl/', 'https://www.geeksforgeeks.org/mapempty-c-stl/', 'https://www.geeksforgeeks.org/mapbegin-end-c-stl/', 'https://www.geeksforgeeks.org/map-operator-cpp-stl/', 'https://www.geeksforgeeks.org/mapclear-c-stl/', 'https://www.geeksforgeeks.org/mapat-mapswap-c-stl/', 'https://www.geeksforgeeks.org/tag/cpp-map/', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Some basic functions associated with Map:\xa0', 'Implementation:', '\xa0Recent Articles on Map\xa0']","['Maps are associative containers that store elements in a mapped fashion. Each element has a key value and a mapped value. No two mapped values can have the same key values.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.']",[],"['// CPP Program to demonstrate the implementation in Map#include <iostream>#include <iterator>#include <map>using namespace std; int main(){     // empty map container    map<int, int> gquiz1;     // insert elements in random order    gquiz1.insert(pair<int, int>(1, 40));    gquiz1.insert(pair<int, int>(2, 30));    gquiz1.insert(pair<int, int>(3, 60));    gquiz1.insert(pair<int, int>(4, 20));    gquiz1.insert(pair<int, int>(5, 50));    gquiz1.insert(pair<int, int>(6, 50));    gquiz1.insert(pair<int, int>(7, 10));     // printing map gquiz1    map<int, int>::iterator itr;    cout << ""\\nThe map gquiz1 is : \\n"";    cout << ""\\tKEY\\tELEMENT\\n"";    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) {        cout << \'\\t\' << itr->first << \'\\t\' << itr->second             << \'\\n\';    }    cout << endl;     // assigning the elements from gquiz1 to gquiz2    map<int, int> gquiz2(gquiz1.begin(), gquiz1.end());     // print all elements of the map gquiz2    cout << ""\\nThe map gquiz2 after""         << "" assign from gquiz1 is : \\n"";    cout << ""\\tKEY\\tELEMENT\\n"";    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << \'\\t\' << itr->first << \'\\t\' << itr->second             << \'\\n\';    }    cout << endl;     // remove all elements up to    // element with key=3 in gquiz2    cout << ""\\ngquiz2 after removal of""            "" elements less than key=3 : \\n"";    cout << ""\\tKEY\\tELEMENT\\n"";    gquiz2.erase(gquiz2.begin(), gquiz2.find(3));    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << \'\\t\' << itr->first << \'\\t\' << itr->second             << \'\\n\';    }     // remove all elements with key = 4    int num;    num = gquiz2.erase(4);    cout << ""\\ngquiz2.erase(4) : "";    cout << num << "" removed \\n"";    cout << ""\\tKEY\\tELEMENT\\n"";    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) {        cout << \'\\t\' << itr->first << \'\\t\' << itr->second             << \'\\n\';    }     cout << endl;     // lower bound and upper bound for map gquiz1 key = 5    cout << ""gquiz1.lower_bound(5) : ""         << ""\\tKEY = "";    cout << gquiz1.lower_bound(5)->first << \'\\t\';    cout << ""\\tELEMENT = "" << gquiz1.lower_bound(5)->second         << endl;    cout << ""gquiz1.upper_bound(5) : ""         << ""\\tKEY = "";    cout << gquiz1.upper_bound(5)->first << \'\\t\';    cout << ""\\tELEMENT = "" << gquiz1.upper_bound(5)->second         << endl;     return 0;}']",['The map gquiz1 is : \n    KEY    ELEMENT\n    1    40\n    2    30\n    3    60\n    4    20\n    5    50\n    6    50\n    7    10\n\n\nThe map gquiz2 after assign from gquiz1 is : \n    KEY    ELEMENT\n    1    40\n    2    30\n    3    60\n    4    20\n    5    50\n    6    50\n    7    10\n\n\ngquiz2 after removal of elements less than key=3 : \n    KEY    ELEMENT\n    3    60\n    4    20\n    5    50\n    6    50\n    7    10\n\ngquiz2.erase(4) : 1 removed \n    KEY    ELEMENT\n    3    60\n    5    50\n    6    50\n    7    10\n\ngquiz1.lower_bound(5) :     KEY = 5        ELEMENT = 50\ngquiz1.upper_bound(5) :     KEY = 6        ELEMENT = 50'],"['map::insert()|||Insert elements with a particular key in the map container.&&&map:: count()|||Returns the number of matches to element with key-value ‘g’ in the map.&&&map equal_range()|||Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k.&&&map erase()|||Used to erase elements from the container.&&&map rend()|||Returns a reverse iterator pointing to the theoretical element right before the first key-value pair in the map(which is considered its reverse end).&&&map rbegin()\xa0|||Returns a reverse iterator which points to the last element of the map.&&&map find()|||Returns an iterator to the element with key-value ‘g’ in the map if found, else returns the iterator to end.&&&map crbegin() and crend()\xa0|||crbegin() returns a constant reverse iterator referring to the last element in the map container. crend() returns a constant reverse iterator pointing to the theoretical element before the first element in the map.&&&map cbegin() and cend()|||\xa0cbegin() returns a constant iterator referring to the first element in the map container. cend() returns a constant iterator pointing to the theoretical element that follows the last element in the multimap.&&&map emplace()|||Inserts the key and its element in the map container.&&&map max_size()\xa0|||Returns the maximum number of elements a map container can hold.&&&map upper_bound()|||Returns an iterator to the first element that is equivalent to mapped value with key-value ‘g’ or definitely will go after the element with key-value ‘g’ in the map&&&map operator=|||Assigns contents of a container to a different container, replacing its current content.&&&map lower_bound()|||Returns an iterator to the first element that is equivalent to the mapped value with key-value ‘g’ or definitely will not go before the element with key-value ‘g’ in the map.&&&map emplace_hint()|||Inserts the key and its element in the map container with a given hint.&&&map value_comp()\xa0|||Returns the object that determines how the elements in the map are ordered (‘<‘ by default).&&&map key_comp()\xa0|||Returns the object that determines how the elements in the map are ordered (‘<‘ by default).&&&map::size()|||Returns the number of elements in the map.&&&map::empty()|||Returns whether the map is empty&&&map::begin() and end()|||begin() returns an iterator to the first element in the map. end() returns an iterator to the theoretical element that follows the last element in the map&&&map::operator[]|||This operator is used to reference the element present at the position given inside the operator.&&&map::clear()\xa0|||Removes all the elements from the map.&&&map::at() and map::swap()|||at() function is used to return the reference to the element associated with the key k. swap() function is used to exchange the contents of two maps but the maps must be of the same type, although sizes may differ.']","['begin() – Returns an iterator to the first element in the map.|||end() – Returns an iterator to the theoretical element that follows the last element in the map.|||size() – Returns the number of elements in the map.|||max_size() – Returns the maximum number of elements that the map can hold.|||empty() – Returns whether the map is empty.|||pair insert(keyvalue, mapvalue) – Adds a new element to the map.|||erase(iterator position) – Removes the element at the position pointed by the iterator.|||erase(const g)– Removes the key-value ‘g’ from the map.|||clear() – Removes all the elements from the map.']"
68,['Advanced C++ with Boost Library'],"['CPP', 'CPP', 'CPP']",[],[],[],"['https://www.geeksforgeeks.org/medium/', 'http://www.boost.org/doc/libs/1_62_0/more/getting_started/unix-variants.html#errors-and-warnings', 'http://www.write.geeksforgeeks.org', 'https://practice.geeksforgeeks.org/contest/step-up-bi-wizard/?utm_source=banner&utm_medium=in-article&utm_campaign=in-article']","['Installation', 'Example Applications', 'Below C++ implementation code for finding the product of large numbers:', 'Below implementation of C++ code for finding the factorial of 30.\xa0']","['Boost Libraries are intended to be widely useful, and usable across a broad spectrum of applications. For example, they are helpful for handling large numbers having a range beyond the long long, long double data type (264) in C++.\xa0', 'Please refer to this Article for the installation of boost. We can download the zip file. After that, we just need to extract the whole in a specified folder of gcc or we can do this easily by command prompt.', 'We can efficiently use this library in Competitive Programming but before this, we must ensure that your online judge must support boost. Here are some cool tricks that you can use:\xa0', '1) Big Integer Data Type: We can use either int128_t, int256_t, int512_t, or int1024_t data type according to your requirement. By using these ones, we can achieve precision up to 1024 easily.\xa0', '2) Arbitrary Precision Data Type: We can use any precision with the help of the cpp_int data type if we are not sure about how much precision is needed in the future. It automatically converts the desired precision at the Run-time.\xa0', '3) Multiprecision Float: With Boost Multiprecision float, we can achieve precision up to 50 and 100 decimal with cpp_float_50 and cpp_dec_float_100 respectively.\xa0', 'Below is C++ code to calculate the area of a circle with different precision by using a float, decimal, and cpp_float_50 types:']","['This article is contributed by Shubham Bansal. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\xa0']","['// CPP Program to demonstrate Big Integer data type#include <boost/multiprecision/cpp_int.hpp>using namespace boost::multiprecision;using namespace std; int128_t boost_product(long long A, long long B){    int128_t ans = (int128_t)A * B;    return ans;} int main(){    long long first = 98745636214564698;    long long second = 7459874565236544789;    cout << ""Product of "" << first << "" * "" << second         << "" = \\n""         << boost_product(first, second);    return 0;}', '// CPP Program to demonstrate Arbitrary precision data type#include <boost/multiprecision/cpp_int.hpp>using namespace boost::multiprecision;using namespace std; cpp_int boost_factorial(int num){    cpp_int fact = 1;    for (int i = num; i > 1; --i)        fact *= i;    return fact;} int main(){    int num = 30;    cout << ""Factorial of "" << num << "" = ""         << boost_factorial(num);    return 0;}', '// CPP Program to demonstrate Boost Multiprecision float#include <boost/math/constants/constants.hpp>#include <boost/multiprecision/cpp_dec_float.hpp>#include <iostream> using boost::multiprecision::cpp_dec_float_50; using namespace std; template <typename T> inline T area_of_a_circle(T r){    // pi represent predefined constant having value    // 3.1415926535897932384...    using boost::math::constants::pi;    return pi<T>() * r * r;} int main(){    float radius_f = 123.0 / 100;    float area_f = area_of_a_circle(radius_f);     double radius_d = 123.0 / 100;    double area_d = area_of_a_circle(radius_d);     cpp_dec_float_50 r_mp = 123.0 / 100;    cpp_dec_float_50 area_mp = area_of_a_circle(r_mp);     // numeric_limits::digits10 represent the number    // of decimal digits that can be held of particular    // data type without any loss.     // Area by using float data type    cout << ""Float: ""         << setprecision(numeric_limits<float>::digits10)         << area_f << endl;     // Area by using double data type    cout << ""Double: ""         << setprecision(numeric_limits<double>::digits10)         << area_d << endl;     // Area by using Boost Multiprecision    cout << ""Boost Multiprecision: ""         << setprecision(                numeric_limits<cpp_dec_float_50>::digits10)         << area_mp << endl;    return 0;}']","['Product of 98745636214564698 * 7459874565236544789 = \n736630060025131838840151335215258722', 'Factorial of 30 = 265252859812191058636308480000000', 'Float: 4.75292\nDouble: 4.752915525616\nBoost Multiprecision: 4.7529155256159980531876290929438093413108253981451']",[],[]
69,['library in C++ STL'],[],[],[],[],"['https://www.geeksforgeeks.org/medium/', 'https://www.geeksforgeeks.org/stdall_of-in-cpp/', 'https://www.geeksforgeeks.org/useful-array-algorithms-in-c-stl/', 'https://www.geeksforgeeks.org/stdnone_of-in-c/', 'https://www.geeksforgeeks.org/for_each-loop-c/', 'https://www.geeksforgeeks.org/stdfind-in-c/', 'https://www.geeksforgeeks.org/stdfind_if-stdfind_if_not-in-c/', 'https://www.geeksforgeeks.org/stdfind_if-stdfind_if_not-in-c/', 'https://www.geeksforgeeks.org/stdfind_end-in-cpp/', 'https://www.geeksforgeeks.org/stdfind_first_of-in-cpp/', 'https://www.geeksforgeeks.org/stdadjacent_find-in-c/', 'https://www.geeksforgeeks.org/std-count-cpp-stl/', 'https://www.geeksforgeeks.org/count_if-in-c/', 'https://www.geeksforgeeks.org/stdmismatch-examples-c/', 'https://www.geeksforgeeks.org/stdequal-in-cpp/', 'https://www.geeksforgeeks.org/stdis_permutation-c-stl/', 'https://www.geeksforgeeks.org/stdsearch-in-c/', 'https://www.geeksforgeeks.org/stdsearch_n-with-example-in-cpp/', 'https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/', 'https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/', 'https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/', 'https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/', 'https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/', 'https://www.geeksforgeeks.org/stdmove-in-c/', 'https://www.geeksforgeeks.org/stdmove_backward-in-c/', 'https://www.geeksforgeeks.org/swap-in-cpp/', 'https://www.geeksforgeeks.org/stdswap_ranges-in-c/', 'https://www.geeksforgeeks.org/stditer_swap-in-cpp/', 'https://www.geeksforgeeks.org/transform-c-stl-perform-operation-elements/', 'https://www.geeksforgeeks.org/stdreplace-stdreplace_if-c/', 'https://www.geeksforgeeks.org/stdreplace-stdreplace_if-c/', 'https://www.geeksforgeeks.org/stdstringreplace_copy-stdstringreplace_copy_if-cpp/', 'https://www.geeksforgeeks.org/stdstringreplace_copy-stdstringreplace_copy_if-cpp/', 'https://www.geeksforgeeks.org/populating-vector-c-using-fill-fill_n/', 'https://www.geeksforgeeks.org/populating-vector-c-using-fill-fill_n/', 'https://www.geeksforgeeks.org/stdgenerate-in-c/', 'https://www.geeksforgeeks.org/stdgenerate_n-in-cpp/', 'https://www.geeksforgeeks.org/stdremove-stdremove_if-c/', 'https://www.geeksforgeeks.org/stdremove-stdremove_if-c/', 'https://www.geeksforgeeks.org/std-string-remove_copy-std-string-remove_copy_if-c/', 'https://www.geeksforgeeks.org/std-string-remove_copy-std-string-remove_copy_if-c/', 'https://www.geeksforgeeks.org/stdunique-in-cpp/', 'https://www.geeksforgeeks.org/stdunique_copy-in-c/', 'https://www.geeksforgeeks.org/stdreverse-in-c/', 'https://www.geeksforgeeks.org/std-reverse_copy-in-c-stl/', 'https://www.geeksforgeeks.org/rotate-in-cpp-stl/', 'https://www.geeksforgeeks.org/stdrotate-vs-stdrotate_copy-c-stl/', 'https://www.geeksforgeeks.org/shuffle-an-array-using-stl-in-c/', 'https://www.geeksforgeeks.org/shuffle-an-array-using-stl-in-c/', 'https://www.geeksforgeeks.org/stdis_partitioned-in-c/', 'https://www.geeksforgeeks.org/stdpartition-in-c-stl/', 'https://www.geeksforgeeks.org/stdstable_partition-in-c/', 'https://www.geeksforgeeks.org/stdpartition-in-c-stl/', 'https://www.geeksforgeeks.org/stdpartition-in-c-stl/', 'https://www.geeksforgeeks.org/sort-c-stl/', 'https://www.geeksforgeeks.org/stable_sort-c-stl/', 'https://www.geeksforgeeks.org/stdpartial_sort-in-cpp/', 'https://www.geeksforgeeks.org/stdpartial_sort_copy-in-cpp/', 'https://www.geeksforgeeks.org/stdis_sorted-in-cpp/', 'https://www.geeksforgeeks.org/stdis_sorted_until-in-cpp/', 'https://www.geeksforgeeks.org/stdnth_element-in-cpp/', 'https://www.geeksforgeeks.org/stdlower_bound-in-c/', 'https://www.geeksforgeeks.org/upper_bound-and-lower_bound-for-vector-in-cpp-stl/', 'https://www.geeksforgeeks.org/stdequal_range-in-cpp/', 'https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/', 'https://www.geeksforgeeks.org/merge-operations-using-stl-in-c-merge-includes-set_union-set_intersection-set_difference/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/stdmerge-c-stl/', 'https://www.geeksforgeeks.org/heap-using-stl-c/', 'https://www.geeksforgeeks.org/heap-using-stl-c/', 'https://www.geeksforgeeks.org/stdmake_heap-c-stl/', 'https://www.geeksforgeeks.org/stdsort_heap-in-cpp/', 'https://www.geeksforgeeks.org/heap-using-stl-c/', 'https://www.geeksforgeeks.org/heap-using-stl-c/', 'https://www.geeksforgeeks.org/stdmax-in-cpp/', 'https://www.geeksforgeeks.org/stdminmax-stdminmax_element-c-stl/', 'https://www.geeksforgeeks.org/stdmin_element-in-cpp/', 'https://www.geeksforgeeks.org/stdmax_element-in-cpp/', 'https://www.geeksforgeeks.org/stdminmax-stdminmax_element-c-stl/', 'https://www.geeksforgeeks.org/stdlexicographical_compare-in-cpp/', 'https://www.geeksforgeeks.org/stdnext_permutation-prev_permutation-c/', 'https://www.geeksforgeeks.org/stdnext_permutation-prev_permutation-c/', 'https://www.geeksforgeeks.org/tag/stl/', 'https://practice.geeksforgeeks.org/courses/CPP-Foundation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP', 'https://practice.geeksforgeeks.org/courses/cpp-stl?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CPP_STL', 'https://practice.geeksforgeeks.org/courses/complete-interview-preparation?utm_source=GeeksforGeeks&utm_medium=Text&utm_campaign=GFG_Article_Bottom_Text_CIP']","['Non-modifying sequence operations\xa0', 'Modifying sequence operations', 'Partition Operations', 'Binary search (operating on partitioned/sorted ranges)', 'Merge (operating on sorted ranges)', 'Heap Operations', 'Other Operations', 'All STL articles of C++\xa0']",[],[],[],[],[],['std :: all_of : Test condition on all elements in range|||std :: any_of : Test if any element in range fulfills condition|||std :: none_of :Test if no elements fulfill condition|||std :: for_each :Apply function to range|||std :: find :Find value in range|||std :: find_if :Find element in range|||std :: find_if_not :Find element in range (negative condition)|||std :: find_end : Find last subsequence in range|||std :: find_first_of :Find element from set in range|||std :: adjacent_find :Find equal adjacent elements in range|||std :: count :Count appearances of value in range|||std :: count_if :Return number of elements in range satisfying condition|||std :: mismatch :Return first position where two ranges differ|||std::equal : Test whether the elements in two ranges are equal|||std :: is_permutation :Test whether range is permutation of another|||std :: search : Search range for subsequence|||std :: search_n :Search range for element&&&std :: copy : Copy range of elements|||std :: copy_n :Copy elements|||std :: copy_if :Copy certain elements of range|||std :: copy_backward :Copy range of elements backward|||std::move : Move range of elements|||std :: move_backward :Move range of elements backward|||std :: swap :Exchange values of two objects|||std ::swap_ranges :Exchange values of two ranges|||std :: iter_swap :Exchange values of objects pointed to by two iterators|||std ::transform :Transform range|||std ::replace :Replace value in range|||std ::replace_if :Replace values in range|||std :: replace_copy :Copy range replacing value|||std :: replace_copy_if :Copy range replacing value|||std ::fill :Fill range with value|||std :: fill_n :Fill sequence with value|||std ::generate :Generate values for range with function|||std ::generate_n : Generate values for sequence with function|||std ::remove :Remove value from range|||std :: remove_if :Remove elements from range|||remove_copy :Copy range removing value|||remove_copy_if :Copy range removing values|||std ::unique :Remove consecutive duplicates in range|||std :: unique_copy :Copy range removing duplicates|||std ::reverse :Reverse range|||std :: reverse_copy :Copy range reversed|||std :: rotate :Rotate left the elements in range|||std :: rotate_copy : Copy range rotated left|||std :: random_shuffle :Randomly rearrange elements in range|||std :: shuffle :Randomly rearrange elements in range using generator&&&std :: is_partitioned :Test whether range is partitioned|||std :: partition : Partition range in two|||std :: stable_partition :Partition range in two – stable ordering|||partition_copy :Partition range into two|||partition_point :Get partition point&&&std :: sort :Sort elements in range|||std :: stable_sort :Sort elements preserving order of equivalents|||std :: partial_sort : Partially sort elements in range|||std :: partial_sort_copy :Copy and partially sort range|||std :: is_sorted :Check whether range is sorted|||std :: is_sorted_until :Find first unsorted element in range|||std :: nth_element : Sort element in range&&&std :: lower_bound :Return iterator to lower bound|||std :: upper_bound : Return iterator to upper bound|||std :: equal_range : Get subrange of equal elements|||std :: binary_search :Test if value exists in sorted sequence&&&std :: merge :Merge sorted ranges|||std :: inplace_merge :Merge consecutive sorted ranges|||std :: includes :Test whether sorted range includes another sorted range|||std :: set_union :Union of two sorted ranges|||std :: set_intersection :Intersection of two sorted ranges|||std :: set_difference :Difference of two sorted ranges|||std :: set_symmetric_difference :Symmetric difference of two sorted ranges&&&std :: push_heap :Push element into heap range|||std :: pop_heap :Pop element from heap range|||std :: make_heap :Make heap from range|||std :: sort_heap :Sort elements of heap|||std :: is_heap : Test if range is heap|||std :: is_heap_until :Find first element not in heap order|||std :: max : Return the largest|||std :: minmax : Return smallest and largest elements|||std :: min_element : Return smallest element in range|||std :: max_element : Return largest element in range|||std :: minmax_element : Return smallest and largest elements in range&&&std :: lexicographical_compare : Lexicographical less-than comparison|||std :: next_permutation :Transform range to next permutation|||std :: prev_permutation : Transform range to previous permutation']
